{"version":3,"file":"index.esm.js","sources":["../src/Interfaces.ts","../src/utils/implementsAbstractType.ts","../src/wrap/transforms/ExpandAbstractTypes.ts","../src/wrap/transforms/FilterToSchema.ts","../src/wrap/transforms/AddReplacementSelectionSets.ts","../src/wrap/transforms/AddReplacementFragments.ts","../src/wrap/transforms/AddMergedTypeSelectionSets.ts","../src/delegate/addTypenameToAbstract.ts","../src/wrap/transforms/AddTypenameToAbstract.ts","../src/stitch/getResponseKeyFromInfo.ts","../src/stitch/symbols.ts","../src/stitch/errors.ts","../src/delegate/results/handleNull.ts","../node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs","../node_modules/graphql/jsutils/inspect.mjs","../node_modules/graphql/jsutils/invariant.mjs","../node_modules/graphql/jsutils/devAssert.mjs","../node_modules/graphql/jsutils/isInvalid.mjs","../node_modules/graphql/jsutils/isObjectLike.mjs","../node_modules/graphql/language/location.mjs","../node_modules/graphql/language/printLocation.mjs","../node_modules/graphql/error/GraphQLError.mjs","../node_modules/graphql/language/kinds.mjs","../node_modules/graphql/polyfills/find.mjs","../node_modules/graphql/polyfills/objectValues.mjs","../node_modules/graphql/polyfills/objectEntries.mjs","../node_modules/graphql/jsutils/keyMap.mjs","../node_modules/graphql/jsutils/mapValue.mjs","../node_modules/graphql/jsutils/toObjMap.mjs","../node_modules/graphql/jsutils/keyValMap.mjs","../node_modules/graphql/jsutils/instanceOf.mjs","../node_modules/graphql/jsutils/identityFunc.mjs","../node_modules/graphql/jsutils/defineToJSON.mjs","../node_modules/graphql/jsutils/defineToStringTag.mjs","../node_modules/graphql/utilities/valueFromASTUntyped.mjs","../node_modules/graphql/type/definition.mjs","../node_modules/graphql/language/directiveLocation.mjs","../node_modules/graphql/polyfills/isFinite.mjs","../node_modules/graphql/polyfills/isInteger.mjs","../node_modules/graphql/type/scalars.mjs","../node_modules/graphql/type/directives.mjs","../node_modules/graphql/language/visitor.mjs","../node_modules/graphql/language/blockString.mjs","../node_modules/graphql/language/printer.mjs","../node_modules/graphql/utilities/typeFromAST.mjs","../node_modules/graphql/utilities/valueFromAST.mjs","../node_modules/graphql/execution/values.mjs","../node_modules/graphql/execution/execute.mjs","../src/stitch/subSchema.ts","../src/stitch/resolveFromParentTypename.ts","../src/utils/graphqlVersion.ts","../src/polyfills/toConfig.ts","../src/polyfills/isSpecifiedScalarType.ts","../src/utils/map.ts","../src/utils/filterSchema.ts","../src/utils/clone.ts","../src/polyfills/buildSchema.ts","../src/utils/getResolversFromSchema.ts","../src/polyfills/extendSchema.ts","../src/utils/each.ts","../src/utils/updateEachKey.ts","../src/utils/stub.ts","../src/utils/heal.ts","../src/utils/SchemaVisitor.ts","../src/utils/valueFromASTUntyped.ts","../src/utils/visitSchema.ts","../src/utils/SchemaDirectiveVisitor.ts","../src/utils/forEachField.ts","../src/utils/forEachDefaultValue.ts","../src/utils/transformInputValue.ts","../src/utils/fragments.ts","../src/utils/selectionSets.ts","../src/utils/mergeDeep.ts","../src/utils/fieldNodes.ts","../src/utils/fields.ts","../src/stitch/proxiedResult.ts","../src/stitch/mergeFields.ts","../src/delegate/results/handleObject.ts","../src/delegate/results/handleList.ts","../src/delegate/checkResultAndHandleErrors.ts","../src/wrap/transforms/CheckResultAndHandleErrors.ts","../src/utils/astFromType.ts","../src/utils/updateArgument.ts","../src/wrap/transforms/AddArgumentsAsVariables.ts","../src/wrap/transforms.ts","../src/stitch/linkToFetcher.ts","../src/stitch/observableToAsyncIterable.ts","../src/stitch/mapAsyncIterator.ts","../src/delegate/createRequest.ts","../src/delegate/delegateToSchema.ts","../src/generate/SchemaError.ts","../src/generate/checkForResolveTypeResolver.ts","../src/generate/extendResolversFromInterfaces.ts","../src/generate/addResolversToSchema.ts","../src/generate/addSchemaLevelResolver.ts","../src/generate/assertResolversPresent.ts","../src/generate/attachDirectiveResolvers.ts","../src/generate/attachConnectorsToContext.ts","../src/generate/extensionDefinitions.ts","../src/generate/concatenateTypeDefs.ts","../src/generate/buildSchemaFromTypeDefinitions.ts","../src/generate/chainResolvers.ts","../src/generate/decorateWithLogger.ts","../src/generate/makeExecutableSchema.ts","../src/generate/index.ts","../src/links/createServerHttpLink.ts","../src/mock/index.ts","../src/scalars/GraphQLUpload.ts","../src/stitch/introspectSchema.ts","../src/stitch/defaultMergedResolver.ts","../src/stitch/makeMergedType.ts","../src/wrap/resolvers.ts","../src/wrap/wrapSchema.ts","../src/stitch/typeFromAST.ts","../src/stitch/mergeInfo.ts","../src/stitch/mergeSchemas.ts","../src/stitch/createMergedResolver.ts","../src/wrap/transformSchema.ts","../src/wrap/transforms/RenameTypes.ts","../src/wrap/transforms/FilterTypes.ts","../src/wrap/transforms/RenameRootTypes.ts","../src/utils/isEmptyObject.ts","../src/wrap/transforms/TransformCompositeFields.ts","../src/wrap/transforms/TransformObjectFields.ts","../src/wrap/transforms/TransformRootFields.ts","../src/wrap/transforms/RenameRootFields.ts","../src/wrap/transforms/FilterRootFields.ts","../src/wrap/transforms/RenameObjectFields.ts","../src/wrap/transforms/FilterObjectFields.ts","../src/wrap/transforms/TransformInterfaceFields.ts","../src/wrap/transforms/RenameInterfaceFields.ts","../src/wrap/transforms/FilterInterfaceFields.ts","../src/wrap/transforms/TransformQuery.ts","../src/wrap/transforms/MapFields.ts","../src/wrap/transforms/ExtendSchema.ts","../src/wrap/transforms/WrapFields.ts","../src/wrap/transforms/WrapType.ts","../src/wrap/transforms/HoistField.ts","../src/wrap/transforms/ReplaceFieldWithFragment.ts","../src/wrap/transforms/WrapQuery.ts","../src/wrap/transforms/ExtractField.ts","../src/wrap/makeRemoteExecutableSchema.ts"],"sourcesContent":["import {\n  GraphQLSchema,\n  GraphQLField,\n  ExecutionResult,\n  GraphQLInputType,\n  GraphQLType,\n  GraphQLNamedType,\n  GraphQLFieldResolver,\n  GraphQLResolveInfo,\n  GraphQLIsTypeOfFn,\n  GraphQLTypeResolver,\n  GraphQLScalarType,\n  DocumentNode,\n  FieldNode,\n  GraphQLEnumValue,\n  GraphQLEnumType,\n  GraphQLUnionType,\n  GraphQLArgument,\n  GraphQLInputField,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  InlineFragmentNode,\n  GraphQLOutputType,\n  SelectionSetNode,\n  GraphQLDirective,\n  GraphQLFieldConfig,\n  FragmentDefinitionNode,\n  SelectionNode,\n  VariableDefinitionNode,\n} from 'graphql';\n\nimport { TypeMap } from 'graphql/type/schema';\nimport { ApolloLink } from 'apollo-link';\n\nimport { SchemaVisitor } from './utils/SchemaVisitor';\nimport { SchemaDirectiveVisitor } from './utils/SchemaDirectiveVisitor';\n\nexport interface IResolverValidationOptions {\n  requireResolversForArgs?: boolean;\n  requireResolversForNonScalar?: boolean;\n  requireResolversForAllFields?: boolean;\n  requireResolversForResolveType?: boolean;\n  allowResolversNotInSchema?: boolean;\n}\n\n// for backwards compatibility\nexport interface IAddResolveFunctionsToSchemaOptions {\n  schema: GraphQLSchema;\n  resolvers: IResolvers;\n  defaultFieldResolver: IFieldResolver<any, any>;\n  resolverValidationOptions: IResolverValidationOptions;\n  inheritResolversFromInterfaces: boolean;\n}\n\nexport interface IAddResolversToSchemaOptions {\n  schema: GraphQLSchema;\n  resolvers: IResolvers;\n  defaultFieldResolver?: IFieldResolver<any, any>;\n  resolverValidationOptions?: IResolverValidationOptions;\n  inheritResolversFromInterfaces?: boolean;\n}\n\nexport interface IResolverOptions<TSource = any, TContext = any, TArgs = any> {\n  fragment?: string;\n  resolve?: IFieldResolver<TSource, TContext, TArgs>;\n  subscribe?: IFieldResolver<TSource, TContext, TArgs>;\n  extensions?: Record<string, any>;\n  __resolveType?: GraphQLTypeResolver<TSource, TContext>;\n  __isTypeOf?: GraphQLIsTypeOfFn<TSource, TContext>;\n}\n\nexport interface Transform {\n  transformSchema?: (schema: GraphQLSchema) => GraphQLSchema;\n  transformRequest?: (originalRequest: Request) => Request;\n  transformResult?: (result: Result) => Result;\n}\n\nexport type FieldTransformer = (\n  typeName: string,\n  fieldName: string,\n  field: GraphQLField<any, any>,\n) => GraphQLFieldConfig<any, any> | RenamedField | null | undefined;\n\nexport type FieldNodeTransformer = (\n  typeName: string,\n  fieldName: string,\n  fieldNode: FieldNode,\n  fragments: Record<string, FragmentDefinitionNode>,\n) => SelectionNode | Array<SelectionNode>;\n\nexport type RenamedField = {\n  name: string;\n  field?: GraphQLFieldConfig<any, any>;\n};\n\nexport type FieldFilter = (\n  typeName?: string,\n  fieldName?: string,\n  field?: GraphQLField<any, any>,\n) => boolean;\n\nexport type RootFieldFilter = (\n  operation?: 'Query' | 'Mutation' | 'Subscription',\n  rootFieldName?: string,\n  field?: GraphQLField<any, any>,\n) => boolean;\n\nexport interface IGraphQLToolsResolveInfo extends GraphQLResolveInfo {\n  mergeInfo?: MergeInfo;\n}\n\nexport type Fetcher = (\n  operation: IFetcherOperation,\n) => Promise<ExecutionResult>;\n\nexport interface IFetcherOperation {\n  query: DocumentNode;\n  operationName?: string;\n  variables?: { [key: string]: any };\n  context?: { [key: string]: any };\n}\n\nexport type Dispatcher = (context: any) => ApolloLink | Fetcher;\n\nexport interface SubschemaConfig {\n  schema: GraphQLSchema;\n  rootValue?: Record<string, any>;\n  executor?: Delegator;\n  subscriber?: Delegator;\n  link?: ApolloLink;\n  fetcher?: Fetcher;\n  dispatcher?: Dispatcher;\n  transforms?: Array<Transform>;\n  merge?: Record<string, MergedTypeConfig>;\n}\n\nexport interface MergedTypeConfig {\n  selectionSet?: string;\n  fieldName?: string;\n  args?: (originalResult: any) => Record<string, any>;\n  resolve?: MergedTypeResolver;\n}\n\nexport type MergedTypeResolver = (\n  originalResult: any,\n  context: Record<string, any>,\n  info: IGraphQLToolsResolveInfo,\n  subschema: GraphQLSchema | SubschemaConfig,\n  selectionSet: SelectionSetNode,\n) => any;\n\nexport interface GraphQLSchemaWithTransforms extends GraphQLSchema {\n  transforms?: Array<Transform>;\n}\n\nexport type SchemaLikeObject =\n  | SubschemaConfig\n  | GraphQLSchema\n  | string\n  | DocumentNode\n  | Array<GraphQLNamedType>;\n\nexport function isSubschemaConfig(\n  value: SchemaLikeObject,\n): value is SubschemaConfig {\n  return Boolean((value as SubschemaConfig).schema);\n}\n\nexport interface IDelegateToSchemaOptions<TContext = { [key: string]: any }> {\n  schema: GraphQLSchema | SubschemaConfig;\n  operation?: Operation;\n  fieldName?: string;\n  returnType?: GraphQLOutputType;\n  args?: { [key: string]: any };\n  selectionSet?: SelectionSetNode;\n  fieldNodes?: ReadonlyArray<FieldNode>;\n  context?: TContext;\n  info: IGraphQLToolsResolveInfo;\n  rootValue?: Record<string, any>;\n  transforms?: Array<Transform>;\n  skipValidation?: boolean;\n  skipTypeMerging?: boolean;\n}\n\nexport interface ICreateRequestFromInfo {\n  info: IGraphQLToolsResolveInfo;\n  operation: Operation;\n  fieldName: string;\n  selectionSet?: SelectionSetNode;\n  fieldNodes?: ReadonlyArray<FieldNode>;\n}\n\nexport interface ICreateRequest {\n  sourceSchema: GraphQLSchema;\n  sourceParentType: GraphQLObjectType;\n  sourceFieldName: string;\n  fragments: Record<string, FragmentDefinitionNode>;\n  variableDefinitions: ReadonlyArray<VariableDefinitionNode>;\n  variableValues: Record<string, any>;\n  targetOperation: Operation;\n  targetFieldName: string;\n  selectionSet: SelectionSetNode;\n  fieldNodes: ReadonlyArray<FieldNode>;\n}\n\nexport interface IDelegateRequestOptions extends IDelegateToSchemaOptions {\n  request: Request;\n}\n\nexport type Delegator = ({\n  document,\n  context,\n  variables,\n}: {\n  document: DocumentNode;\n  context?: { [key: string]: any };\n  variables?: { [key: string]: any };\n}) => any;\n\nexport interface MergeInfo {\n  delegate: (\n    type: 'query' | 'mutation' | 'subscription',\n    fieldName: string,\n    args: { [key: string]: any },\n    context: { [key: string]: any },\n    info: GraphQLResolveInfo,\n    transforms?: Array<Transform>,\n  ) => any;\n  fragments: Array<{\n    field: string;\n    fragment: string;\n  }>;\n  replacementSelectionSets: ReplacementSelectionSetMapping;\n  replacementFragments: ReplacementFragmentMapping;\n  mergedTypes: Record<string, MergedTypeInfo>;\n  delegateToSchema<TContext>(options: IDelegateToSchemaOptions<TContext>): any;\n}\n\nexport interface ReplacementSelectionSetMapping {\n  [typeName: string]: { [fieldName: string]: SelectionSetNode };\n}\n\nexport interface ReplacementFragmentMapping {\n  [typeName: string]: { [fieldName: string]: InlineFragmentNode };\n}\n\nexport interface MergedTypeInfo {\n  subschemas: Array<SubschemaConfig>;\n  selectionSet?: SelectionSetNode;\n  uniqueFields: Record<string, SubschemaConfig>;\n  nonUniqueFields: Record<string, Array<SubschemaConfig>>;\n  typeMaps: Map<SubschemaConfig, TypeMap>;\n  selectionSets: Map<SubschemaConfig, SelectionSetNode>;\n  containsSelectionSet: Map<SubschemaConfig, Map<SelectionSetNode, boolean>>;\n}\n\nexport type IFieldResolver<TSource, TContext, TArgs = Record<string, any>> = (\n  source: TSource,\n  args: TArgs,\n  context: TContext,\n  info: IGraphQLToolsResolveInfo,\n) => any;\n\nexport type ITypedef = (() => Array<ITypedef>) | string | DocumentNode;\n\nexport type ITypeDefinitions = ITypedef | Array<ITypedef>;\n\nexport interface IResolverObject<TSource = any, TContext = any, TArgs = any> {\n  [key: string]:\n    | IFieldResolver<TSource, TContext, TArgs>\n    | IResolverOptions<TSource, TContext>\n    | IResolverObject<TSource, TContext>;\n}\n\nexport interface IEnumResolver {\n  [key: string]: string | number;\n}\n\nexport interface IResolvers<TSource = any, TContext = any> {\n  [key: string]:\n    | (() => any)\n    | IResolverObject<TSource, TContext>\n    | IResolverOptions<TSource, TContext>\n    | GraphQLScalarType\n    | IEnumResolver;\n}\n\nexport type IResolversParameter =\n  | Array<IResolvers | ((mergeInfo: MergeInfo) => IResolvers)>\n  | IResolvers\n  | ((mergeInfo: MergeInfo) => IResolvers);\n\nexport interface ILogger {\n  log: (error: Error) => void;\n}\n\nexport type IConnectorCls<TContext = any> = new (context?: TContext) => any;\n\nexport type IConnectorFn<TContext = any> = (context?: TContext) => any;\n\nexport type IConnector<TContext = any> =\n  | IConnectorCls<TContext>\n  | IConnectorFn<TContext>;\n\nexport interface IConnectors<TContext = any> {\n  [key: string]: IConnector<TContext>;\n}\n\nexport interface IExecutableSchemaDefinition<TContext = any> {\n  typeDefs: ITypeDefinitions;\n  resolvers?: IResolvers<any, TContext> | Array<IResolvers<any, TContext>>;\n  connectors?: IConnectors<TContext>;\n  logger?: ILogger;\n  allowUndefinedInResolve?: boolean;\n  resolverValidationOptions?: IResolverValidationOptions;\n  directiveResolvers?: IDirectiveResolvers<any, TContext>;\n  schemaDirectives?: { [name: string]: typeof SchemaDirectiveVisitor };\n  parseOptions?: GraphQLParseOptions;\n  inheritResolversFromInterfaces?: boolean;\n}\n\nexport type IFieldIteratorFn = (\n  fieldDef: GraphQLField<any, any>,\n  typeName: string,\n  fieldName: string,\n) => void;\n\nexport type IDefaultValueIteratorFn = (\n  type: GraphQLInputType,\n  value: any,\n) => void;\n\nexport type NextResolverFn = () => Promise<any>;\n\nexport type DirectiveResolverFn<TSource = any, TContext = any> = (\n  next: NextResolverFn,\n  source: TSource,\n  args: { [argName: string]: any },\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => any;\n\nexport interface IDirectiveResolvers<TSource = any, TContext = any> {\n  [directiveName: string]: DirectiveResolverFn<TSource, TContext>;\n}\n\n/* XXX on mocks, args are optional, Not sure if a bug. */\nexport type IMockFn = GraphQLFieldResolver<any, any>;\n\nexport interface IMocks {\n  [key: string]: IMockFn;\n}\n\nexport type IMockTypeFn = (\n  type: GraphQLType,\n  typeName?: string,\n  fieldName?: string,\n) => GraphQLFieldResolver<any, any>;\n\nexport interface IMockOptions {\n  schema?: GraphQLSchema;\n  mocks?: IMocks;\n  preserveResolvers?: boolean;\n}\n\nexport interface IMockServer {\n  query: (\n    query: string,\n    vars?: { [key: string]: any },\n  ) => Promise<ExecutionResult>;\n}\n\nexport type OnTypeConflict = (\n  left: GraphQLNamedType,\n  right: GraphQLNamedType,\n  info?: {\n    left: {\n      schema?: GraphQLSchema | SubschemaConfig;\n    };\n    right: {\n      schema?: GraphQLSchema | SubschemaConfig;\n    };\n  },\n) => GraphQLNamedType;\n\nexport type Operation = 'query' | 'mutation' | 'subscription';\n\nexport interface Request {\n  document: DocumentNode;\n  variables: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface Result extends ExecutionResult {\n  extensions?: Record<string, any>;\n}\n\nexport interface GraphQLParseOptions {\n  noLocation?: boolean;\n  allowLegacySDLEmptyFields?: boolean;\n  allowLegacySDLImplementsInterfaces?: boolean;\n  experimentalFragmentVariables?: boolean;\n}\n\nexport type IndexedObject<V> = { [key: string]: V } | ReadonlyArray<V>;\n\nexport type VisitableSchemaType =\n  | GraphQLSchema\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLInputObjectType\n  | GraphQLNamedType\n  | GraphQLScalarType\n  | GraphQLField<any, any>\n  | GraphQLInputField\n  | GraphQLArgument\n  | GraphQLUnionType\n  | GraphQLEnumType\n  | GraphQLEnumValue;\n\nexport type VisitorSelector = (\n  type: VisitableSchemaType,\n  methodName: string,\n) => Array<SchemaVisitor | SchemaVisitorMap>;\n\nexport enum VisitSchemaKind {\n  TYPE = 'VisitSchemaKind.TYPE',\n  SCALAR_TYPE = 'VisitSchemaKind.SCALAR_TYPE',\n  ENUM_TYPE = 'VisitSchemaKind.ENUM_TYPE',\n  COMPOSITE_TYPE = 'VisitSchemaKind.COMPOSITE_TYPE',\n  OBJECT_TYPE = 'VisitSchemaKind.OBJECT_TYPE',\n  INPUT_OBJECT_TYPE = 'VisitSchemaKind.INPUT_OBJECT_TYPE',\n  ABSTRACT_TYPE = 'VisitSchemaKind.ABSTRACT_TYPE',\n  UNION_TYPE = 'VisitSchemaKind.UNION_TYPE',\n  INTERFACE_TYPE = 'VisitSchemaKind.INTERFACE_TYPE',\n  ROOT_OBJECT = 'VisitSchemaKind.ROOT_OBJECT',\n  QUERY = 'VisitSchemaKind.QUERY',\n  MUTATION = 'VisitSchemaKind.MUTATION',\n  SUBSCRIPTION = 'VisitSchemaKind.SUBSCRIPTION',\n}\n\nexport interface SchemaVisitorMap {\n  [VisitSchemaKind.TYPE]?: NamedTypeVisitor;\n  [VisitSchemaKind.SCALAR_TYPE]?: ScalarTypeVisitor;\n  [VisitSchemaKind.ENUM_TYPE]?: EnumTypeVisitor;\n  [VisitSchemaKind.COMPOSITE_TYPE]?: CompositeTypeVisitor;\n  [VisitSchemaKind.OBJECT_TYPE]?: ObjectTypeVisitor;\n  [VisitSchemaKind.INPUT_OBJECT_TYPE]?: InputObjectTypeVisitor;\n  [VisitSchemaKind.ABSTRACT_TYPE]?: AbstractTypeVisitor;\n  [VisitSchemaKind.UNION_TYPE]?: UnionTypeVisitor;\n  [VisitSchemaKind.INTERFACE_TYPE]?: InterfaceTypeVisitor;\n  [VisitSchemaKind.ROOT_OBJECT]?: ObjectTypeVisitor;\n  [VisitSchemaKind.QUERY]?: ObjectTypeVisitor;\n  [VisitSchemaKind.MUTATION]?: ObjectTypeVisitor;\n  [VisitSchemaKind.SUBSCRIPTION]?: ObjectTypeVisitor;\n}\n\nexport type NamedTypeVisitor = (\n  type: GraphQLNamedType,\n  schema: GraphQLSchema,\n) => GraphQLNamedType | null | undefined;\n\nexport type ScalarTypeVisitor = (\n  type: GraphQLScalarType,\n  schema: GraphQLSchema,\n) => GraphQLScalarType | null | undefined;\n\nexport type EnumTypeVisitor = (\n  type: GraphQLEnumType,\n  schema: GraphQLSchema,\n) => GraphQLEnumType | null | undefined;\n\nexport type CompositeTypeVisitor = (\n  type: GraphQLObjectType | GraphQLInterfaceType | GraphQLUnionType,\n  schema: GraphQLSchema,\n) =>\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType\n  | null\n  | undefined;\n\nexport type ObjectTypeVisitor = (\n  type: GraphQLObjectType,\n  schema: GraphQLSchema,\n) => GraphQLObjectType | null | undefined;\n\nexport type InputObjectTypeVisitor = (\n  type: GraphQLInputObjectType,\n  schema: GraphQLSchema,\n) => GraphQLInputObjectType | null | undefined;\n\nexport type AbstractTypeVisitor = (\n  type: GraphQLInterfaceType | GraphQLUnionType,\n  schema: GraphQLSchema,\n) => GraphQLInterfaceType | GraphQLUnionType | null | undefined;\n\nexport type UnionTypeVisitor = (\n  type: GraphQLUnionType,\n  schema: GraphQLSchema,\n) => GraphQLUnionType | null | undefined;\n\nexport type InterfaceTypeVisitor = (\n  type: GraphQLInterfaceType,\n  schema: GraphQLSchema,\n) => GraphQLInterfaceType | null | undefined;\n\nexport enum MapperKind {\n  TYPE = 'MapperKind.TYPE',\n  SCALAR_TYPE = 'MapperKind.SCALAR_TYPE',\n  ENUM_TYPE = 'MapperKind.ENUM_TYPE',\n  COMPOSITE_TYPE = 'MapperKind.COMPOSITE_TYPE',\n  OBJECT_TYPE = 'MapperKind.OBJECT_TYPE',\n  INPUT_OBJECT_TYPE = 'MapperKind.INPUT_OBJECT_TYPE',\n  ABSTRACT_TYPE = 'MapperKind.ABSTRACT_TYPE',\n  UNION_TYPE = 'MapperKind.UNION_TYPE',\n  INTERFACE_TYPE = 'MapperKind.INTERFACE_TYPE',\n  ROOT_OBJECT = 'MapperKind.ROOT_OBJECT',\n  QUERY = 'MapperKind.QUERY',\n  MUTATION = 'MapperKind.MUTATION',\n  SUBSCRIPTION = 'MapperKind.SUBSCRIPTION',\n  DIRECTIVE = 'MapperKind.DIRECTIVE',\n}\n\nexport interface SchemaMapper {\n  [MapperKind.TYPE]?: NamedTypeMapper;\n  [MapperKind.SCALAR_TYPE]?: ScalarTypeMapper;\n  [MapperKind.ENUM_TYPE]?: EnumTypeMapper;\n  [MapperKind.COMPOSITE_TYPE]?: CompositeTypeMapper;\n  [MapperKind.OBJECT_TYPE]?: ObjectTypeMapper;\n  [MapperKind.INPUT_OBJECT_TYPE]?: InputObjectTypeMapper;\n  [MapperKind.ABSTRACT_TYPE]?: AbstractTypeMapper;\n  [MapperKind.UNION_TYPE]?: UnionTypeMapper;\n  [MapperKind.INTERFACE_TYPE]?: InterfaceTypeMapper;\n  [MapperKind.ROOT_OBJECT]?: ObjectTypeMapper;\n  [MapperKind.QUERY]?: ObjectTypeMapper;\n  [MapperKind.MUTATION]?: ObjectTypeMapper;\n  [MapperKind.SUBSCRIPTION]?: ObjectTypeMapper;\n  [MapperKind.DIRECTIVE]?: DirectiveMapper;\n}\n\nexport type NamedTypeMapper = (\n  type: GraphQLNamedType,\n  schema: GraphQLSchema,\n) => GraphQLNamedType | null | undefined;\n\nexport type ScalarTypeMapper = (\n  type: GraphQLScalarType,\n  schema: GraphQLSchema,\n) => GraphQLScalarType | null | undefined;\n\nexport type EnumTypeMapper = (\n  type: GraphQLEnumType,\n  schema: GraphQLSchema,\n) => GraphQLEnumType | null | undefined;\n\nexport type CompositeTypeMapper = (\n  type: GraphQLObjectType | GraphQLInterfaceType | GraphQLUnionType,\n  schema: GraphQLSchema,\n) =>\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType\n  | null\n  | undefined;\n\nexport type ObjectTypeMapper = (\n  type: GraphQLObjectType,\n  schema: GraphQLSchema,\n) => GraphQLObjectType | null | undefined;\n\nexport type InputObjectTypeMapper = (\n  type: GraphQLInputObjectType,\n  schema: GraphQLSchema,\n) => GraphQLInputObjectType | null | undefined;\n\nexport type AbstractTypeMapper = (\n  type: GraphQLInterfaceType | GraphQLUnionType,\n  schema: GraphQLSchema,\n) => GraphQLInterfaceType | GraphQLUnionType | null | undefined;\n\nexport type UnionTypeMapper = (\n  type: GraphQLUnionType,\n  schema: GraphQLSchema,\n) => GraphQLUnionType | null | undefined;\n\nexport type InterfaceTypeMapper = (\n  type: GraphQLInterfaceType,\n  schema: GraphQLSchema,\n) => GraphQLInterfaceType | null | undefined;\n\nexport type DirectiveMapper = (\n  directive: GraphQLDirective,\n  schema: GraphQLSchema,\n) => GraphQLDirective | null | undefined;\n","import {\n  GraphQLType,\n  GraphQLSchema,\n  doTypesOverlap,\n  isCompositeType,\n} from 'graphql';\n\nexport default function implementsAbstractType(\n  schema: GraphQLSchema,\n  typeA: GraphQLType,\n  typeB: GraphQLType,\n) {\n  if (typeA === typeB) {\n    return true;\n  } else if (isCompositeType(typeA) && isCompositeType(typeB)) {\n    return doTypesOverlap(schema, typeA, typeB);\n  }\n\n  return false;\n}\n","import {\n  DocumentNode,\n  FragmentDefinitionNode,\n  GraphQLNamedType,\n  GraphQLSchema,\n  Kind,\n  OperationDefinitionNode,\n  SelectionNode,\n  SelectionSetNode,\n  TypeInfo,\n  getNamedType,\n  isAbstractType,\n  visit,\n  visitWithTypeInfo,\n} from 'graphql';\n\nimport implementsAbstractType from '../../utils/implementsAbstractType';\nimport { Transform, Request } from '../../Interfaces';\n\ntype TypeMapping = { [key: string]: Array<string> };\n\nexport default class ExpandAbstractTypes implements Transform {\n  private readonly targetSchema: GraphQLSchema;\n  private readonly mapping: TypeMapping;\n  private readonly reverseMapping: TypeMapping;\n\n  constructor(sourceSchema: GraphQLSchema, targetSchema: GraphQLSchema) {\n    this.targetSchema = targetSchema;\n    this.mapping = extractPossibleTypes(sourceSchema, targetSchema);\n    this.reverseMapping = flipMapping(this.mapping);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = expandAbstractTypes(\n      this.targetSchema,\n      this.mapping,\n      this.reverseMapping,\n      originalRequest.document,\n    );\n    return {\n      ...originalRequest,\n      document,\n    };\n  }\n}\n\nfunction extractPossibleTypes(\n  sourceSchema: GraphQLSchema,\n  targetSchema: GraphQLSchema,\n) {\n  const typeMap = sourceSchema.getTypeMap();\n  const mapping: TypeMapping = {};\n  Object.keys(typeMap).forEach((typeName) => {\n    const type = typeMap[typeName];\n    if (isAbstractType(type)) {\n      const targetType = targetSchema.getType(typeName);\n      if (!isAbstractType(targetType)) {\n        const implementations = sourceSchema.getPossibleTypes(type);\n        mapping[typeName] = implementations\n          .filter((impl) => targetSchema.getType(impl.name))\n          .map((impl) => impl.name);\n      }\n    }\n  });\n  return mapping;\n}\n\nfunction flipMapping(mapping: TypeMapping): TypeMapping {\n  const result: TypeMapping = {};\n  Object.keys(mapping).forEach((typeName) => {\n    const toTypeNames = mapping[typeName];\n    toTypeNames.forEach((toTypeName) => {\n      if (result[toTypeName] == null) {\n        result[toTypeName] = [];\n      }\n      result[toTypeName].push(typeName);\n    });\n  });\n  return result;\n}\n\nfunction expandAbstractTypes(\n  targetSchema: GraphQLSchema,\n  mapping: TypeMapping,\n  reverseMapping: TypeMapping,\n  document: DocumentNode,\n): DocumentNode {\n  const operations: Array<OperationDefinitionNode> = document.definitions.filter(\n    (def) => def.kind === Kind.OPERATION_DEFINITION,\n  ) as Array<OperationDefinitionNode>;\n  const fragments: Array<FragmentDefinitionNode> = document.definitions.filter(\n    (def) => def.kind === Kind.FRAGMENT_DEFINITION,\n  ) as Array<FragmentDefinitionNode>;\n\n  const existingFragmentNames = fragments.map(\n    (fragment) => fragment.name.value,\n  );\n  let fragmentCounter = 0;\n  const generateFragmentName = (typeName: string) => {\n    let fragmentName;\n    do {\n      fragmentName = `_${typeName}_Fragment${fragmentCounter.toString()}`;\n      fragmentCounter++;\n    } while (existingFragmentNames.indexOf(fragmentName) !== -1);\n    return fragmentName;\n  };\n\n  const newFragments: Array<FragmentDefinitionNode> = [];\n  const fragmentReplacements: {\n    [fragmentName: string]: Array<{ fragmentName: string; typeName: string }>;\n  } = {};\n\n  fragments.forEach((fragment: FragmentDefinitionNode) => {\n    newFragments.push(fragment);\n    const possibleTypes = mapping[fragment.typeCondition.name.value];\n    if (possibleTypes != null) {\n      fragmentReplacements[fragment.name.value] = [];\n      possibleTypes.forEach((possibleTypeName) => {\n        const name = generateFragmentName(possibleTypeName);\n        existingFragmentNames.push(name);\n        const newFragment: FragmentDefinitionNode = {\n          kind: Kind.FRAGMENT_DEFINITION,\n          name: {\n            kind: Kind.NAME,\n            value: name,\n          },\n          typeCondition: {\n            kind: Kind.NAMED_TYPE,\n            name: {\n              kind: Kind.NAME,\n              value: possibleTypeName,\n            },\n          },\n          selectionSet: fragment.selectionSet,\n        };\n        newFragments.push(newFragment);\n\n        fragmentReplacements[fragment.name.value].push({\n          fragmentName: name,\n          typeName: possibleTypeName,\n        });\n      });\n    }\n  });\n\n  const newDocument = {\n    ...document,\n    definitions: [...operations, ...newFragments],\n  };\n  const typeInfo = new TypeInfo(targetSchema);\n  return visit(\n    newDocument,\n    visitWithTypeInfo(typeInfo, {\n      [Kind.SELECTION_SET](node: SelectionSetNode) {\n        const newSelections = [...node.selections];\n        const maybeType = typeInfo.getParentType();\n        if (maybeType != null) {\n          const parentType: GraphQLNamedType = getNamedType(maybeType);\n          node.selections.forEach((selection: SelectionNode) => {\n            if (selection.kind === Kind.INLINE_FRAGMENT) {\n              if (selection.typeCondition != null) {\n                const possibleTypes =\n                  mapping[selection.typeCondition.name.value];\n                if (possibleTypes != null) {\n                  possibleTypes.forEach((possibleType) => {\n                    const maybePossibleType = targetSchema.getType(\n                      possibleType,\n                    );\n                    if (\n                      maybePossibleType != null &&\n                      implementsAbstractType(\n                        targetSchema,\n                        parentType,\n                        maybePossibleType,\n                      )\n                    ) {\n                      newSelections.push({\n                        kind: Kind.INLINE_FRAGMENT,\n                        typeCondition: {\n                          kind: Kind.NAMED_TYPE,\n                          name: {\n                            kind: Kind.NAME,\n                            value: possibleType,\n                          },\n                        },\n                        selectionSet: selection.selectionSet,\n                      });\n                    }\n                  });\n                }\n              }\n            } else if (selection.kind === Kind.FRAGMENT_SPREAD) {\n              const fragmentName = selection.name.value;\n              const replacements = fragmentReplacements[fragmentName];\n              if (replacements != null) {\n                replacements.forEach((replacement) => {\n                  const typeName = replacement.typeName;\n                  const maybeReplacementType = targetSchema.getType(typeName);\n                  if (\n                    maybeReplacementType != null &&\n                    implementsAbstractType(targetSchema, parentType, maybeType)\n                  ) {\n                    newSelections.push({\n                      kind: Kind.FRAGMENT_SPREAD,\n                      name: {\n                        kind: Kind.NAME,\n                        value: replacement.fragmentName,\n                      },\n                    });\n                  }\n                });\n              }\n            }\n          });\n\n          if (reverseMapping[parentType.name] != null) {\n            newSelections.push({\n              kind: Kind.FIELD,\n              name: {\n                kind: Kind.NAME,\n                value: '__typename',\n              },\n            });\n          }\n        }\n\n        if (newSelections.length !== node.selections.length) {\n          return {\n            ...node,\n            selections: newSelections,\n          };\n        }\n      },\n    }),\n  );\n}\n","import {\n  ArgumentNode,\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n  GraphQLSchema,\n  GraphQLType,\n  InlineFragmentNode,\n  Kind,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  TypeNameMetaFieldDef,\n  VariableDefinitionNode,\n  VariableNode,\n  visit,\n  TypeInfo,\n  visitWithTypeInfo,\n  getNamedType,\n  isObjectType,\n  isInterfaceType,\n} from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\nimport implementsAbstractType from '../../utils/implementsAbstractType';\n\nexport default class FilterToSchema implements Transform {\n  private readonly targetSchema: GraphQLSchema;\n\n  constructor(targetSchema: GraphQLSchema) {\n    this.targetSchema = targetSchema;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return {\n      ...originalRequest,\n      ...filterToSchema(\n        this.targetSchema,\n        originalRequest.document,\n        originalRequest.variables,\n      ),\n    };\n  }\n}\n\nfunction filterToSchema(\n  targetSchema: GraphQLSchema,\n  document: DocumentNode,\n  variables: Record<string, any>,\n): { document: DocumentNode; variables: Record<string, any> } {\n  const operations: Array<OperationDefinitionNode> = document.definitions.filter(\n    (def) => def.kind === Kind.OPERATION_DEFINITION,\n  ) as Array<OperationDefinitionNode>;\n  const fragments: Array<FragmentDefinitionNode> = document.definitions.filter(\n    (def) => def.kind === Kind.FRAGMENT_DEFINITION,\n  ) as Array<FragmentDefinitionNode>;\n\n  let usedVariables: Array<string> = [];\n  let usedFragments: Array<string> = [];\n  const newOperations: Array<OperationDefinitionNode> = [];\n  let newFragments: Array<FragmentDefinitionNode> = [];\n\n  const validFragments: Array<FragmentDefinitionNode> = fragments.filter(\n    (fragment: FragmentDefinitionNode) => {\n      const typeName = fragment.typeCondition.name.value;\n      return Boolean(targetSchema.getType(typeName));\n    },\n  );\n\n  const validFragmentsWithType: { [name: string]: GraphQLType } = {};\n  validFragments.forEach((fragment: FragmentDefinitionNode) => {\n    const typeName = fragment.typeCondition.name.value;\n    const type = targetSchema.getType(typeName);\n    validFragmentsWithType[fragment.name.value] = type;\n  });\n\n  let fragmentSet = Object.create(null);\n\n  operations.forEach((operation: OperationDefinitionNode) => {\n    let type;\n    if (operation.operation === 'subscription') {\n      type = targetSchema.getSubscriptionType();\n    } else if (operation.operation === 'mutation') {\n      type = targetSchema.getMutationType();\n    } else {\n      type = targetSchema.getQueryType();\n    }\n\n    const {\n      selectionSet,\n      usedFragments: operationUsedFragments,\n      usedVariables: operationUsedVariables,\n    } = filterSelectionSet(\n      targetSchema,\n      type,\n      validFragmentsWithType,\n      operation.selectionSet,\n    );\n\n    usedFragments = union(usedFragments, operationUsedFragments);\n\n    const {\n      usedVariables: collectedUsedVariables,\n      newFragments: collectedNewFragments,\n      fragmentSet: collectedFragmentSet,\n    } = collectFragmentVariables(\n      targetSchema,\n      fragmentSet,\n      validFragments,\n      validFragmentsWithType,\n      usedFragments,\n    );\n    const operationOrFragmentVariables = union(\n      operationUsedVariables,\n      collectedUsedVariables,\n    );\n    usedVariables = union(usedVariables, operationOrFragmentVariables);\n    newFragments = collectedNewFragments;\n    fragmentSet = collectedFragmentSet;\n\n    const variableDefinitions = operation.variableDefinitions.filter(\n      (variable: VariableDefinitionNode) =>\n        operationOrFragmentVariables.indexOf(variable.variable.name.value) !==\n        -1,\n    );\n\n    newOperations.push({\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation.operation,\n      name: operation.name,\n      directives: operation.directives,\n      variableDefinitions,\n      selectionSet,\n    });\n  });\n\n  const newVariables: Record<string, any> = {};\n  usedVariables.forEach((variableName) => {\n    newVariables[variableName] = variables[variableName];\n  });\n\n  return {\n    document: {\n      kind: Kind.DOCUMENT,\n      definitions: [...newOperations, ...newFragments],\n    },\n    variables: newVariables,\n  };\n}\n\nfunction collectFragmentVariables(\n  targetSchema: GraphQLSchema,\n  fragmentSet: object,\n  validFragments: Array<FragmentDefinitionNode>,\n  validFragmentsWithType: { [name: string]: GraphQLType },\n  usedFragments: Array<string>,\n) {\n  let remainingFragments = usedFragments.slice();\n\n  let usedVariables: Array<string> = [];\n  const newFragments: Array<FragmentDefinitionNode> = [];\n\n  while (remainingFragments.length !== 0) {\n    const nextFragmentName = remainingFragments.pop();\n    const fragment = validFragments.find(\n      (fr) => fr.name.value === nextFragmentName,\n    );\n    if (fragment != null) {\n      const name = nextFragmentName;\n      const typeName = fragment.typeCondition.name.value;\n      const type = targetSchema.getType(typeName);\n      const {\n        selectionSet,\n        usedFragments: fragmentUsedFragments,\n        usedVariables: fragmentUsedVariables,\n      } = filterSelectionSet(\n        targetSchema,\n        type,\n        validFragmentsWithType,\n        fragment.selectionSet,\n      );\n      remainingFragments = union(remainingFragments, fragmentUsedFragments);\n      usedVariables = union(usedVariables, fragmentUsedVariables);\n\n      if (!fragmentSet[name]) {\n        fragmentSet[name] = true;\n        newFragments.push({\n          kind: Kind.FRAGMENT_DEFINITION,\n          name: {\n            kind: Kind.NAME,\n            value: name,\n          },\n          typeCondition: fragment.typeCondition,\n          selectionSet,\n        });\n      }\n    }\n  }\n\n  return {\n    usedVariables,\n    newFragments,\n    fragmentSet,\n  };\n}\n\nfunction filterSelectionSet(\n  schema: GraphQLSchema,\n  type: GraphQLType,\n  validFragments: { [name: string]: GraphQLType },\n  selectionSet: SelectionSetNode,\n) {\n  const usedFragments: Array<string> = [];\n  const usedVariables: Array<string> = [];\n\n  const typeInfo = new TypeInfo(schema, undefined, type);\n  const filteredSelectionSet = visit(\n    selectionSet,\n    visitWithTypeInfo(typeInfo, {\n      [Kind.FIELD]: {\n        enter(node: FieldNode): null | undefined | FieldNode {\n          const parentType = typeInfo.getParentType();\n          if (isObjectType(parentType) || isInterfaceType(parentType)) {\n            const fields = parentType.getFields();\n            const field =\n              node.name.value === '__typename'\n                ? TypeNameMetaFieldDef\n                : fields[node.name.value];\n            if (!field) {\n              return null;\n            }\n\n            const argNames = (field.args != null ? field.args : []).map(\n              (arg) => arg.name,\n            );\n            if (node.arguments != null) {\n              const args = node.arguments.filter(\n                (arg: ArgumentNode) => argNames.indexOf(arg.name.value) !== -1,\n              );\n              if (args.length !== node.arguments.length) {\n                return {\n                  ...node,\n                  arguments: args,\n                };\n              }\n            }\n          }\n        },\n        leave(node: FieldNode): null | undefined | FieldNode {\n          const resolvedType = getNamedType(typeInfo.getType());\n          if (isObjectType(resolvedType) || isInterfaceType(resolvedType)) {\n            const selections =\n              node.selectionSet != null ? node.selectionSet.selections : null;\n            if (selections == null || selections.length === 0) {\n              // need to remove any added variables. Is there a better way to do this?\n              visit(node, {\n                [Kind.VARIABLE](variableNode: VariableNode) {\n                  const index = usedVariables.indexOf(variableNode.name.value);\n                  if (index !== -1) {\n                    usedVariables.splice(index, 1);\n                  }\n                },\n              });\n              return null;\n            }\n          }\n        },\n      },\n      [Kind.FRAGMENT_SPREAD](node: FragmentSpreadNode): null | undefined {\n        if (node.name.value in validFragments) {\n          const parentType = typeInfo.getParentType();\n          const innerType = validFragments[node.name.value];\n          if (!implementsAbstractType(schema, parentType, innerType)) {\n            return null;\n          }\n\n          usedFragments.push(node.name.value);\n          return;\n        }\n\n        return null;\n      },\n      [Kind.INLINE_FRAGMENT]: {\n        enter(node: InlineFragmentNode): null | undefined {\n          if (node.typeCondition != null) {\n            const parentType = typeInfo.getParentType();\n            const innerType = schema.getType(node.typeCondition.name.value);\n            if (!implementsAbstractType(schema, parentType, innerType)) {\n              return null;\n            }\n          }\n        },\n      },\n      [Kind.VARIABLE](node: VariableNode) {\n        usedVariables.push(node.name.value);\n      },\n    }),\n  );\n\n  return {\n    selectionSet: filteredSelectionSet,\n    usedFragments,\n    usedVariables,\n  };\n}\n\nfunction union(...arrays: Array<Array<string>>): Array<string> {\n  const cache: { [key: string]: boolean } = {};\n  const result: Array<string> = [];\n  arrays.forEach((array) => {\n    array.forEach((item) => {\n      if (!cache[item]) {\n        cache[item] = true;\n        result.push(item);\n      }\n    });\n  });\n  return result;\n}\n","import {\n  DocumentNode,\n  GraphQLSchema,\n  GraphQLType,\n  Kind,\n  SelectionSetNode,\n  TypeInfo,\n  visit,\n  visitWithTypeInfo,\n} from 'graphql';\n\nimport {\n  Transform,\n  Request,\n  ReplacementSelectionSetMapping,\n} from '../../Interfaces';\n\nexport default class AddReplacementSelectionSets implements Transform {\n  private readonly schema: GraphQLSchema;\n  private readonly mapping: ReplacementSelectionSetMapping;\n\n  constructor(schema: GraphQLSchema, mapping: ReplacementSelectionSetMapping) {\n    this.schema = schema;\n    this.mapping = mapping;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = replaceFieldsWithSelectionSet(\n      this.schema,\n      originalRequest.document,\n      this.mapping,\n    );\n    return {\n      ...originalRequest,\n      document,\n    };\n  }\n}\n\nfunction replaceFieldsWithSelectionSet(\n  schema: GraphQLSchema,\n  document: DocumentNode,\n  mapping: ReplacementSelectionSetMapping,\n): DocumentNode {\n  const typeInfo = new TypeInfo(schema);\n  return visit(\n    document,\n    visitWithTypeInfo(typeInfo, {\n      [Kind.SELECTION_SET](\n        node: SelectionSetNode,\n      ): SelectionSetNode | null | undefined {\n        const parentType:\n          | GraphQLType\n          | null\n          | undefined = typeInfo.getParentType();\n        if (parentType != null) {\n          const parentTypeName = parentType.name;\n          let selections = node.selections;\n\n          if (mapping[parentTypeName] != null) {\n            node.selections.forEach((selection) => {\n              if (selection.kind === Kind.FIELD) {\n                const name = selection.name.value;\n                const selectionSet = mapping[parentTypeName][name];\n                if (selectionSet != null) {\n                  selections = selections.concat(selectionSet.selections);\n                }\n              }\n            });\n          }\n\n          if (selections !== node.selections) {\n            return {\n              ...node,\n              selections,\n            };\n          }\n        }\n      },\n    }),\n  );\n}\n","import {\n  DocumentNode,\n  GraphQLSchema,\n  GraphQLType,\n  Kind,\n  SelectionSetNode,\n  TypeInfo,\n  visit,\n  visitWithTypeInfo,\n} from 'graphql';\n\nimport {\n  Transform,\n  Request,\n  ReplacementFragmentMapping,\n} from '../../Interfaces';\n\nexport default class AddReplacementFragments implements Transform {\n  private readonly targetSchema: GraphQLSchema;\n  private readonly mapping: ReplacementFragmentMapping;\n\n  constructor(\n    targetSchema: GraphQLSchema,\n    mapping: ReplacementFragmentMapping,\n  ) {\n    this.targetSchema = targetSchema;\n    this.mapping = mapping;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = replaceFieldsWithFragments(\n      this.targetSchema,\n      originalRequest.document,\n      this.mapping,\n    );\n    return {\n      ...originalRequest,\n      document,\n    };\n  }\n}\n\nfunction replaceFieldsWithFragments(\n  targetSchema: GraphQLSchema,\n  document: DocumentNode,\n  mapping: ReplacementFragmentMapping,\n): DocumentNode {\n  const typeInfo = new TypeInfo(targetSchema);\n  return visit(\n    document,\n    visitWithTypeInfo(typeInfo, {\n      [Kind.SELECTION_SET](\n        node: SelectionSetNode,\n      ): SelectionSetNode | null | undefined {\n        const parentType:\n          | GraphQLType\n          | null\n          | undefined = typeInfo.getParentType();\n        if (parentType != null) {\n          const parentTypeName = parentType.name;\n          let selections = node.selections;\n\n          if (mapping[parentTypeName] != null) {\n            node.selections.forEach((selection) => {\n              if (selection.kind === Kind.FIELD) {\n                const name = selection.name.value;\n                const fragment = mapping[parentTypeName][name];\n                if (fragment != null) {\n                  selections = selections.concat(fragment);\n                }\n              }\n            });\n          }\n\n          if (selections !== node.selections) {\n            return {\n              ...node,\n              selections,\n            };\n          }\n        }\n      },\n    }),\n  );\n}\n","import {\n  DocumentNode,\n  GraphQLSchema,\n  GraphQLType,\n  Kind,\n  SelectionSetNode,\n  TypeInfo,\n  visit,\n  visitWithTypeInfo,\n} from 'graphql';\n\nimport { Transform, Request, MergedTypeInfo } from '../../Interfaces';\n\nexport default class AddMergedTypeFragments implements Transform {\n  private readonly targetSchema: GraphQLSchema;\n  private readonly mapping: Record<string, MergedTypeInfo>;\n\n  constructor(\n    targetSchema: GraphQLSchema,\n    mapping: Record<string, MergedTypeInfo>,\n  ) {\n    this.targetSchema = targetSchema;\n    this.mapping = mapping;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = addMergedTypeSelectionSets(\n      this.targetSchema,\n      originalRequest.document,\n      this.mapping,\n    );\n    return {\n      ...originalRequest,\n      document,\n    };\n  }\n}\n\nfunction addMergedTypeSelectionSets(\n  targetSchema: GraphQLSchema,\n  document: DocumentNode,\n  mapping: Record<string, MergedTypeInfo>,\n): DocumentNode {\n  const typeInfo = new TypeInfo(targetSchema);\n  return visit(\n    document,\n    visitWithTypeInfo(typeInfo, {\n      [Kind.SELECTION_SET](\n        node: SelectionSetNode,\n      ): SelectionSetNode | null | undefined {\n        const parentType:\n          | GraphQLType\n          | null\n          | undefined = typeInfo.getParentType();\n        if (parentType != null) {\n          const parentTypeName = parentType.name;\n          let selections = node.selections;\n\n          if (mapping[parentTypeName] != null) {\n            const selectionSet = mapping[parentTypeName].selectionSet;\n            if (selectionSet != null) {\n              selections = selections.concat(selectionSet.selections);\n            }\n          }\n\n          if (selections !== node.selections) {\n            return {\n              ...node,\n              selections,\n            };\n          }\n        }\n      },\n    }),\n  );\n}\n","import {\n  GraphQLType,\n  DocumentNode,\n  TypeInfo,\n  visit,\n  visitWithTypeInfo,\n  SelectionSetNode,\n  Kind,\n  GraphQLSchema,\n  isAbstractType,\n} from 'graphql';\n\nexport function addTypenameToAbstract(\n  targetSchema: GraphQLSchema,\n  document: DocumentNode,\n): DocumentNode {\n  const typeInfo = new TypeInfo(targetSchema);\n  return visit(\n    document,\n    visitWithTypeInfo(typeInfo, {\n      [Kind.SELECTION_SET](\n        node: SelectionSetNode,\n      ): SelectionSetNode | null | undefined {\n        const parentType: GraphQLType = typeInfo.getParentType();\n        let selections = node.selections;\n        if (parentType != null && isAbstractType(parentType)) {\n          selections = selections.concat({\n            kind: Kind.FIELD,\n            name: {\n              kind: Kind.NAME,\n              value: '__typename',\n            },\n          });\n        }\n\n        if (selections !== node.selections) {\n          return {\n            ...node,\n            selections,\n          };\n        }\n      },\n    }),\n  );\n}\n","import { GraphQLSchema } from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\nimport { addTypenameToAbstract } from '../../delegate/addTypenameToAbstract';\n\nexport default class AddTypenameToAbstract implements Transform {\n  private readonly targetSchema: GraphQLSchema;\n\n  constructor(targetSchema: GraphQLSchema) {\n    this.targetSchema = targetSchema;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = addTypenameToAbstract(\n      this.targetSchema,\n      originalRequest.document,\n    );\n    return {\n      ...originalRequest,\n      document,\n    };\n  }\n}\n","import { GraphQLResolveInfo } from 'graphql';\n\n/**\n * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just\n * resolves aliases.\n * @param info The info argument to the resolver.\n */\nexport function getResponseKeyFromInfo(info: GraphQLResolveInfo) {\n  return info.fieldNodes[0].alias != null\n    ? info.fieldNodes[0].alias.value\n    : info.fieldName;\n}\n","const hasSymbol =\n  (typeof global !== 'undefined' && 'Symbol' in global) ||\n  // eslint-disable-next-line no-undef\n  (typeof window !== 'undefined' && 'Symbol' in window);\n\nexport const OBJECT_SUBSCHEMA_SYMBOL = hasSymbol\n  ? Symbol('initialSubschema')\n  : '@@__initialSubschema';\nexport const FIELD_SUBSCHEMA_MAP_SYMBOL = hasSymbol\n  ? Symbol('subschemaMap')\n  : '@@__subschemaMap';\nexport const ERROR_SYMBOL = hasSymbol\n  ? Symbol('subschemaErrors')\n  : '@@__subschemaErrors';\n","import { GraphQLError, ASTNode } from 'graphql';\n\nimport { ERROR_SYMBOL } from './symbols';\n\nexport function relocatedError(\n  originalError: Error | GraphQLError,\n  nodes: ReadonlyArray<ASTNode>,\n  path: ReadonlyArray<string | number>,\n): GraphQLError {\n  if (Array.isArray((originalError as GraphQLError).path)) {\n    return new GraphQLError(\n      (originalError as GraphQLError).message,\n      (originalError as GraphQLError).nodes,\n      (originalError as GraphQLError).source,\n      (originalError as GraphQLError).positions,\n      path != null ? path : (originalError as GraphQLError).path,\n      (originalError as GraphQLError).originalError,\n      (originalError as GraphQLError).extensions,\n    );\n  }\n\n  if (originalError == null) {\n    return new GraphQLError(\n      undefined,\n      nodes,\n      undefined,\n      undefined,\n      path,\n      originalError,\n    );\n  }\n\n  return new GraphQLError(\n    originalError.message,\n    (originalError as GraphQLError).nodes != null\n      ? (originalError as GraphQLError).nodes\n      : nodes,\n    (originalError as GraphQLError).source,\n    (originalError as GraphQLError).positions,\n    path,\n    originalError,\n  );\n}\n\nexport function slicedError(originalError: GraphQLError) {\n  return relocatedError(\n    originalError,\n    originalError.nodes,\n    originalError.path != null ? originalError.path.slice(1) : undefined,\n  );\n}\n\nexport function getErrorsByPathSegment(\n  errors: ReadonlyArray<GraphQLError>,\n): Record<string, Array<GraphQLError>> {\n  const record = Object.create(null);\n  errors.forEach((error) => {\n    if (!error.path || error.path.length < 2) {\n      return;\n    }\n\n    const pathSegment = error.path[1];\n\n    const current = record[pathSegment] != null ? record[pathSegment] : [];\n    current.push(slicedError(error));\n    record[pathSegment] = current;\n  });\n\n  return record;\n}\n\nclass CombinedError extends Error {\n  public errors: ReadonlyArray<GraphQLError>;\n  constructor(message: string, errors: ReadonlyArray<GraphQLError>) {\n    super(message);\n    this.errors = errors;\n  }\n}\n\nexport function combineErrors(\n  errors: ReadonlyArray<GraphQLError>,\n): GraphQLError | CombinedError {\n  if (errors.length === 1) {\n    return new GraphQLError(\n      errors[0].message,\n      errors[0].nodes,\n      errors[0].source,\n      errors[0].positions,\n      errors[0].path,\n      errors[0].originalError,\n      errors[0].extensions,\n    );\n  }\n\n  return new CombinedError(\n    errors.map((error) => error.message).join('\\n'),\n    errors,\n  );\n}\n\nexport function setErrors(result: any, errors: Array<GraphQLError>) {\n  result[ERROR_SYMBOL] = errors;\n}\n\nexport function getErrors(\n  result: any,\n  pathSegment: string,\n): Array<GraphQLError> {\n  const errors = result != null ? result[ERROR_SYMBOL] : result;\n\n  if (!Array.isArray(errors)) {\n    return null;\n  }\n\n  const fieldErrors = [];\n\n  for (const error of errors) {\n    if (!error.path || error.path[0] === pathSegment) {\n      fieldErrors.push(error);\n    }\n  }\n\n  return fieldErrors;\n}\n","import { FieldNode, GraphQLError } from 'graphql';\n\nimport {\n  getErrorsByPathSegment,\n  combineErrors,\n  relocatedError,\n} from '../../stitch/errors';\n\nexport function handleNull(\n  fieldNodes: ReadonlyArray<FieldNode>,\n  path: Array<string | number>,\n  errors: ReadonlyArray<GraphQLError>,\n) {\n  if (errors.length) {\n    if (errors.some((error) => !error.path || error.path.length < 2)) {\n      return relocatedError(combineErrors(errors), fieldNodes, path);\n    } else if (errors.some((error) => typeof error.path[1] === 'string')) {\n      const childErrors = getErrorsByPathSegment(errors);\n\n      const result = Object.create(null);\n      Object.keys(childErrors).forEach((pathSegment) => {\n        result[pathSegment] = handleNull(\n          fieldNodes,\n          [...path, pathSegment],\n          childErrors[pathSegment],\n        );\n      });\n\n      return result;\n    }\n\n    const childErrors = getErrorsByPathSegment(errors);\n\n    const result: Array<any> = [];\n    Object.keys(childErrors).forEach((pathSegment) => {\n      result.push(\n        handleNull(\n          fieldNodes,\n          [...path, parseInt(pathSegment, 10)],\n          childErrors[pathSegment],\n        ),\n      );\n    });\n\n    return result;\n  }\n\n  return null;\n}\n","var nodejsCustomInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : undefined;\nexport default nodejsCustomInspectSymbol;\n","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport nodejsCustomInspectSymbol from './nodejsCustomInspectSymbol';\nvar MAX_ARRAY_LENGTH = 10;\nvar MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\n\nexport default function inspect(value) {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value, seenValues) {\n  switch (_typeof(value)) {\n    case 'string':\n      return JSON.stringify(value);\n\n    case 'function':\n      return value.name ? \"[function \".concat(value.name, \"]\") : '[function]';\n\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      return formatObjectValue(value, seenValues);\n\n    default:\n      return String(value);\n  }\n}\n\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (previouslySeenValues.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  var seenValues = [].concat(previouslySeenValues, [value]);\n  var customInspectFn = getCustomFn(value);\n\n  if (customInspectFn !== undefined) {\n    // $FlowFixMe(>=0.90.0)\n    var customValue = customInspectFn.call(value); // check for infinite recursion\n\n    if (customValue !== value) {\n      return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction formatObject(object, seenValues) {\n  var keys = Object.keys(object);\n\n  if (keys.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  var properties = keys.map(function (key) {\n    var value = formatValue(object[key], seenValues);\n    return key + ': ' + value;\n  });\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  var len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  var remaining = array.length - len;\n  var items = [];\n\n  for (var i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(\"... \".concat(remaining, \" more items\"));\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getCustomFn(object) {\n  var customInspectFn = object[String(nodejsCustomInspectSymbol)];\n\n  if (typeof customInspectFn === 'function') {\n    return customInspectFn;\n  }\n\n  if (typeof object.inspect === 'function') {\n    return object.inspect;\n  }\n}\n\nfunction getObjectTag(object) {\n  var tag = Object.prototype.toString.call(object).replace(/^\\[object /, '').replace(/]$/, '');\n\n  if (tag === 'Object' && typeof object.constructor === 'function') {\n    var name = object.constructor.name;\n\n    if (typeof name === 'string' && name !== '') {\n      return name;\n    }\n  }\n\n  return tag;\n}\n","export default function invariant(condition, message) {\n  var booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(message || 'Unexpected invariant triggered');\n  }\n}\n","export default function devAssert(condition, message) {\n  var booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(message);\n  }\n}\n","/**\n * Returns true if a value is undefined, or NaN.\n */\nexport default function isInvalid(value) {\n  return value === undefined || value !== value;\n}\n","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nexport default function isObjectLike(value) {\n  return _typeof(value) == 'object' && value !== null;\n}\n","/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport function getLocation(source, position) {\n  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n  var line = 1;\n  var column = position + 1;\n  var match;\n\n  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n    line += 1;\n    column = position + 1 - (match.index + match[0].length);\n  }\n\n  return {\n    line: line,\n    column: column\n  };\n}\n","import { getLocation } from '../language/location';\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printLocation(location) {\n  return printSourceLocation(location.source, getLocation(location.source, location.start));\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printSourceLocation(source, sourceLocation) {\n  var firstLineColumnOffset = source.locationOffset.column - 1;\n  var body = whitespace(firstLineColumnOffset) + source.body;\n  var lineIndex = sourceLocation.line - 1;\n  var lineOffset = source.locationOffset.line - 1;\n  var lineNum = sourceLocation.line + lineOffset;\n  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  var columnNum = sourceLocation.column + columnOffset;\n  var locationStr = \"\".concat(source.name, \":\").concat(lineNum, \":\").concat(columnNum, \"\\n\");\n  var lines = body.split(/\\r\\n|[\\n\\r]/g);\n  var locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    var sublineIndex = Math.floor(columnNum / 80);\n    var sublineColumnNum = columnNum % 80;\n    var sublines = [];\n\n    for (var i = 0; i < locationLine.length; i += 80) {\n      sublines.push(locationLine.slice(i, i + 80));\n    }\n\n    return locationStr + printPrefixedLines([[\"\".concat(lineNum), sublines[0]]].concat(sublines.slice(1, sublineIndex + 1).map(function (subline) {\n      return ['', subline];\n    }), [[' ', whitespace(sublineColumnNum - 1) + '^'], ['', sublines[sublineIndex + 1]]]));\n  }\n\n  return locationStr + printPrefixedLines([// Lines specified like this: [\"prefix\", \"string\"],\n  [\"\".concat(lineNum - 1), lines[lineIndex - 1]], [\"\".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], [\"\".concat(lineNum + 1), lines[lineIndex + 1]]]);\n}\n\nfunction printPrefixedLines(lines) {\n  var existingLines = lines.filter(function (_ref) {\n    var _ = _ref[0],\n        line = _ref[1];\n    return line !== undefined;\n  });\n  var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {\n    var prefix = _ref2[0];\n    return prefix.length;\n  }));\n  return existingLines.map(function (_ref3) {\n    var prefix = _ref3[0],\n        line = _ref3[1];\n    return lpad(padLen, prefix) + (line ? ' | ' + line : ' |');\n  }).join('\\n');\n}\n\nfunction whitespace(len) {\n  return Array(len + 1).join(' ');\n}\n\nfunction lpad(len, str) {\n  return whitespace(len - str.length) + str;\n}\n","import isObjectLike from '../jsutils/isObjectLike';\nimport { getLocation } from '../language/location';\nimport { printLocation, printSourceLocation } from '../language/printLocation';\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nexport function GraphQLError( // eslint-disable-line no-redeclare\nmessage, nodes, source, positions, path, originalError, extensions) {\n  // Compute list of blame nodes.\n  var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.\n\n\n  var _source = source;\n\n  if (!_source && _nodes) {\n    var node = _nodes[0];\n    _source = node && node.loc && node.loc.source;\n  }\n\n  var _positions = positions;\n\n  if (!_positions && _nodes) {\n    _positions = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(node.loc.start);\n      }\n\n      return list;\n    }, []);\n  }\n\n  if (_positions && _positions.length === 0) {\n    _positions = undefined;\n  }\n\n  var _locations;\n\n  if (positions && source) {\n    _locations = positions.map(function (pos) {\n      return getLocation(source, pos);\n    });\n  } else if (_nodes) {\n    _locations = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(getLocation(node.loc.source, node.loc.start));\n      }\n\n      return list;\n    }, []);\n  }\n\n  var _extensions = extensions;\n\n  if (_extensions == null && originalError != null) {\n    var originalExtensions = originalError.extensions;\n\n    if (isObjectLike(originalExtensions)) {\n      _extensions = originalExtensions;\n    }\n  }\n\n  Object.defineProperties(this, {\n    message: {\n      value: message,\n      // By being enumerable, JSON.stringify will include `message` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: true,\n      writable: true\n    },\n    locations: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _locations || undefined,\n      // By being enumerable, JSON.stringify will include `locations` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(_locations)\n    },\n    path: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: path || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(path)\n    },\n    nodes: {\n      value: _nodes || undefined\n    },\n    source: {\n      value: _source || undefined\n    },\n    positions: {\n      value: _positions || undefined\n    },\n    originalError: {\n      value: originalError\n    },\n    extensions: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _extensions || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(_extensions)\n    }\n  }); // Include (non-enumerable) stack trace.\n\n  if (originalError && originalError.stack) {\n    Object.defineProperty(this, 'stack', {\n      value: originalError.stack,\n      writable: true,\n      configurable: true\n    });\n  } else if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, GraphQLError);\n  } else {\n    Object.defineProperty(this, 'stack', {\n      value: Error().stack,\n      writable: true,\n      configurable: true\n    });\n  }\n}\nGraphQLError.prototype = Object.create(Error.prototype, {\n  constructor: {\n    value: GraphQLError\n  },\n  name: {\n    value: 'GraphQLError'\n  },\n  toString: {\n    value: function toString() {\n      return printError(this);\n    }\n  }\n});\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n */\n\nexport function printError(error) {\n  var output = error.message;\n\n  if (error.nodes) {\n    for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {\n      var node = _error$nodes2[_i2];\n\n      if (node.loc) {\n        output += '\\n\\n' + printLocation(node.loc);\n      }\n    }\n  } else if (error.source && error.locations) {\n    for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {\n      var location = _error$locations2[_i4];\n      output += '\\n\\n' + printSourceLocation(error.source, location);\n    }\n  }\n\n  return output;\n}\n","/**\n * The set of allowed kind values for AST nodes.\n */\nexport var Kind = Object.freeze({\n  // Name\n  NAME: 'Name',\n  // Document\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  // Fragments\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  // Values\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  // Directives\n  DIRECTIVE: 'Directive',\n  // Types\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n  // Type System Definitions\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  // Type Definitions\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  // Directive Definitions\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  // Type System Extensions\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  // Type Extensions\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'\n});\n/**\n * The enum type representing the possible kind values of AST nodes.\n */\n","/* eslint-disable no-redeclare */\n// $FlowFixMe\nvar find = Array.prototype.find ? function (list, predicate) {\n  return Array.prototype.find.call(list, predicate);\n} : function (list, predicate) {\n  for (var _i2 = 0; _i2 < list.length; _i2++) {\n    var value = list[_i2];\n\n    if (predicate(value)) {\n      return value;\n    }\n  }\n};\nexport default find;\n","/* eslint-disable no-redeclare */\n// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/2221\nvar objectValues = Object.values || function (obj) {\n  return Object.keys(obj).map(function (key) {\n    return obj[key];\n  });\n};\n\nexport default objectValues;\n","/* eslint-disable no-redeclare */\n// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/5838\nvar objectEntries = Object.entries || function (obj) {\n  return Object.keys(obj).map(function (key) {\n    return [key, obj[key]];\n  });\n};\n\nexport default objectEntries;\n","/**\n * Creates a keyed JS object from an array, given a function to produce the keys\n * for each value in the array.\n *\n * This provides a convenient lookup for the array items if the key function\n * produces unique results.\n *\n *     const phoneBook = [\n *       { name: 'Jon', num: '555-1234' },\n *       { name: 'Jenny', num: '867-5309' }\n *     ]\n *\n *     // { Jon: { name: 'Jon', num: '555-1234' },\n *     //   Jenny: { name: 'Jenny', num: '867-5309' } }\n *     const entriesByName = keyMap(\n *       phoneBook,\n *       entry => entry.name\n *     )\n *\n *     // { name: 'Jenny', num: '857-6309' }\n *     const jennyEntry = entriesByName['Jenny']\n *\n */\nexport default function keyMap(list, keyFn) {\n  return list.reduce(function (map, item) {\n    map[keyFn(item)] = item;\n    return map;\n  }, Object.create(null));\n}\n","import objectEntries from '../polyfills/objectEntries';\n\n/**\n * Creates an object map with the same keys as `map` and values generated by\n * running each value of `map` thru `fn`.\n */\nexport default function mapValue(map, fn) {\n  var result = Object.create(null);\n\n  for (var _i2 = 0, _objectEntries2 = objectEntries(map); _i2 < _objectEntries2.length; _i2++) {\n    var _ref2 = _objectEntries2[_i2];\n    var _key = _ref2[0];\n    var _value = _ref2[1];\n    result[_key] = fn(_value, _key);\n  }\n\n  return result;\n}\n","import objectEntries from '../polyfills/objectEntries';\nexport default function toObjMap(obj) {\n  /* eslint-enable no-redeclare */\n  if (Object.getPrototypeOf(obj) === null) {\n    return obj;\n  }\n\n  var map = Object.create(null);\n\n  for (var _i2 = 0, _objectEntries2 = objectEntries(obj); _i2 < _objectEntries2.length; _i2++) {\n    var _ref2 = _objectEntries2[_i2];\n    var key = _ref2[0];\n    var value = _ref2[1];\n    map[key] = value;\n  }\n\n  return map;\n}\n","/**\n * Creates a keyed JS object from an array, given a function to produce the keys\n * and a function to produce the values from each item in the array.\n *\n *     const phoneBook = [\n *       { name: 'Jon', num: '555-1234' },\n *       { name: 'Jenny', num: '867-5309' }\n *     ]\n *\n *     // { Jon: '555-1234', Jenny: '867-5309' }\n *     const phonesByName = keyValMap(\n *       phoneBook,\n *       entry => entry.name,\n *       entry => entry.num\n *     )\n *\n */\nexport default function keyValMap(list, keyFn, valFn) {\n  return list.reduce(function (map, item) {\n    map[keyFn(item)] = valFn(item);\n    return map;\n  }, Object.create(null));\n}\n","/**\n * A replacement for instanceof which includes an error warning when multi-realm\n * constructors are detected.\n */\n// See: https://expressjs.com/en/advanced/best-practice-performance.html#set-node_env-to-production\n// See: https://webpack.js.org/guides/production/\nexport default process.env.NODE_ENV === 'production' ? // eslint-disable-next-line no-shadow\nfunction instanceOf(value, constructor) {\n  return value instanceof constructor;\n} : // eslint-disable-next-line no-shadow\nfunction instanceOf(value, constructor) {\n  if (value instanceof constructor) {\n    return true;\n  }\n\n  if (value) {\n    var valueClass = value.constructor;\n    var className = constructor.name;\n\n    if (className && valueClass && valueClass.name === className) {\n      throw new Error(\"Cannot use \".concat(className, \" \\\"\").concat(value, \"\\\" from another module or realm.\\n\\nEnsure that there is only one instance of \\\"graphql\\\" in the node_modules\\ndirectory. If different versions of \\\"graphql\\\" are the dependencies of other\\nrelied on modules, use \\\"resolutions\\\" to ensure only one version is installed.\\n\\nhttps://yarnpkg.com/en/docs/selective-version-resolutions\\n\\nDuplicate \\\"graphql\\\" modules cannot be used at the same time since different\\nversions may have different capabilities and behavior. The data from one\\nversion used in the function from another could produce confusing and\\nspurious results.\"));\n    }\n  }\n\n  return false;\n};\n","/**\n * Returns the first argument it receives.\n */\nexport default function identityFunc(x) {\n  return x;\n}\n","import nodejsCustomInspectSymbol from './nodejsCustomInspectSymbol';\n/**\n * The `defineToJSON()` function defines toJSON() and inspect() prototype\n * methods, if no function provided they become aliases for toString().\n */\n\nexport default function defineToJSON(classObject) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : classObject.prototype.toString;\n  classObject.prototype.toJSON = fn;\n  classObject.prototype.inspect = fn;\n\n  if (nodejsCustomInspectSymbol) {\n    classObject.prototype[nodejsCustomInspectSymbol] = fn;\n  }\n}\n","/**\n * The `defineToStringTag()` function checks first to see if the runtime\n * supports the `Symbol` class and then if the `Symbol.toStringTag` constant\n * is defined as a `Symbol` instance. If both conditions are met, the\n * Symbol.toStringTag property is defined as a getter that returns the\n * supplied class constructor's name.\n *\n * @method defineToStringTag\n *\n * @param {Class<any>} classObject a class such as Object, String, Number but\n * typically one of your own creation through the class keyword; `class A {}`,\n * for example.\n */\nexport default function defineToStringTag(classObject) {\n  if (typeof Symbol === 'function' && Symbol.toStringTag) {\n    Object.defineProperty(classObject.prototype, Symbol.toStringTag, {\n      get: function get() {\n        return this.constructor.name;\n      }\n    });\n  }\n}\n","import inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport keyValMap from '../jsutils/keyValMap';\nimport isInvalid from '../jsutils/isInvalid';\nimport { Kind } from '../language/kinds';\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * Unlike `valueFromAST()`, no type is provided. The resulting JavaScript value\n * will reflect the provided GraphQL value AST.\n *\n * | GraphQL Value        | JavaScript Value |\n * | -------------------- | ---------------- |\n * | Input Object         | Object           |\n * | List                 | Array            |\n * | Boolean              | Boolean          |\n * | String / Enum        | String           |\n * | Int / Float          | Number           |\n * | Null                 | null             |\n *\n */\nexport function valueFromASTUntyped(valueNode, variables) {\n  switch (valueNode.kind) {\n    case Kind.NULL:\n      return null;\n\n    case Kind.INT:\n      return parseInt(valueNode.value, 10);\n\n    case Kind.FLOAT:\n      return parseFloat(valueNode.value);\n\n    case Kind.STRING:\n    case Kind.ENUM:\n    case Kind.BOOLEAN:\n      return valueNode.value;\n\n    case Kind.LIST:\n      return valueNode.values.map(function (node) {\n        return valueFromASTUntyped(node, variables);\n      });\n\n    case Kind.OBJECT:\n      return keyValMap(valueNode.fields, function (field) {\n        return field.name.value;\n      }, function (field) {\n        return valueFromASTUntyped(field.value, variables);\n      });\n\n    case Kind.VARIABLE:\n      {\n        var variableName = valueNode.name.value;\n        return variables && !isInvalid(variables[variableName]) ? variables[variableName] : undefined;\n      }\n  } // Not reachable. All possible value nodes have been considered.\n\n\n  /* istanbul ignore next */\n  invariant(false, 'Unexpected value node: ' + inspect(valueNode));\n}\n","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport objectEntries from '../polyfills/objectEntries';\nimport inspect from '../jsutils/inspect';\nimport keyMap from '../jsutils/keyMap';\nimport mapValue from '../jsutils/mapValue';\nimport toObjMap from '../jsutils/toObjMap';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport instanceOf from '../jsutils/instanceOf';\nimport isObjectLike from '../jsutils/isObjectLike';\nimport identityFunc from '../jsutils/identityFunc';\nimport defineToJSON from '../jsutils/defineToJSON';\nimport defineToStringTag from '../jsutils/defineToStringTag';\nimport { Kind } from '../language/kinds';\nimport { valueFromASTUntyped } from '../utilities/valueFromASTUntyped';\nexport function isType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);\n}\nexport function assertType(type) {\n  if (!isType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL type.\"));\n  }\n\n  return type;\n}\n/**\n * There are predicates for each kind of GraphQL type.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function isScalarType(type) {\n  return instanceOf(type, GraphQLScalarType);\n}\nexport function assertScalarType(type) {\n  if (!isScalarType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Scalar type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isObjectType(type) {\n  return instanceOf(type, GraphQLObjectType);\n}\nexport function assertObjectType(type) {\n  if (!isObjectType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Object type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isInterfaceType(type) {\n  return instanceOf(type, GraphQLInterfaceType);\n}\nexport function assertInterfaceType(type) {\n  if (!isInterfaceType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Interface type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isUnionType(type) {\n  return instanceOf(type, GraphQLUnionType);\n}\nexport function assertUnionType(type) {\n  if (!isUnionType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Union type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isEnumType(type) {\n  return instanceOf(type, GraphQLEnumType);\n}\nexport function assertEnumType(type) {\n  if (!isEnumType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Enum type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isInputObjectType(type) {\n  return instanceOf(type, GraphQLInputObjectType);\n}\nexport function assertInputObjectType(type) {\n  if (!isInputObjectType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Input Object type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isListType(type) {\n  return instanceOf(type, GraphQLList);\n}\nexport function assertListType(type) {\n  if (!isListType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL List type.\"));\n  }\n\n  return type;\n}\n// eslint-disable-next-line no-redeclare\nexport function isNonNullType(type) {\n  return instanceOf(type, GraphQLNonNull);\n}\nexport function assertNonNullType(type) {\n  if (!isNonNullType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL Non-Null type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may be used as input types for arguments and directives.\n */\n\nexport function isInputType(type) {\n  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);\n}\nexport function assertInputType(type) {\n  if (!isInputType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL input type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may be used as output types as the result of fields.\n */\n\nexport function isOutputType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);\n}\nexport function assertOutputType(type) {\n  if (!isOutputType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL output type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may describe types which may be leaf values.\n */\n\nexport function isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\nexport function assertLeafType(type) {\n  if (!isLeafType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL leaf type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isCompositeType(type) {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\nexport function assertCompositeType(type) {\n  if (!isCompositeType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL composite type.\"));\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\nexport function assertAbstractType(type) {\n  if (!isAbstractType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL abstract type.\"));\n  }\n\n  return type;\n}\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         parents: { type: GraphQLList(PersonType) },\n *         children: { type: GraphQLList(PersonType) },\n *       })\n *     })\n *\n */\n\n// eslint-disable-next-line no-redeclare\nexport function GraphQLList(ofType) {\n  if (this instanceof GraphQLList) {\n    this.ofType = assertType(ofType);\n  } else {\n    return new GraphQLList(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\nGraphQLList.prototype.toString = function toString() {\n  return '[' + String(this.ofType) + ']';\n}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\ndefineToStringTag(GraphQLList);\ndefineToJSON(GraphQLList);\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n *     const RowType = new GraphQLObjectType({\n *       name: 'Row',\n *       fields: () => ({\n *         id: { type: GraphQLNonNull(GraphQLString) },\n *       })\n *     })\n *\n * Note: the enforcement of non-nullability occurs within the executor.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function GraphQLNonNull(ofType) {\n  if (this instanceof GraphQLNonNull) {\n    this.ofType = assertNullableType(ofType);\n  } else {\n    return new GraphQLNonNull(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\nGraphQLNonNull.prototype.toString = function toString() {\n  return String(this.ofType) + '!';\n}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\ndefineToStringTag(GraphQLNonNull);\ndefineToJSON(GraphQLNonNull);\n/**\n * These types wrap and modify other types\n */\n\nexport function isWrappingType(type) {\n  return isListType(type) || isNonNullType(type);\n}\nexport function assertWrappingType(type) {\n  if (!isWrappingType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL wrapping type.\"));\n  }\n\n  return type;\n}\n/**\n * These types can all accept null as a value.\n */\n\nexport function isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\nexport function assertNullableType(type) {\n  if (!isNullableType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL nullable type.\"));\n  }\n\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNullableType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\nexport function isNamedType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);\n}\nexport function assertNamedType(type) {\n  if (!isNamedType(type)) {\n    throw new Error(\"Expected \".concat(inspect(type), \" to be a GraphQL named type.\"));\n  }\n\n  return type;\n}\n/* eslint-disable no-redeclare */\n\nexport function getNamedType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    var unwrappedType = type;\n\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n\n    return unwrappedType;\n  }\n}\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\nfunction resolveThunk(thunk) {\n  // $FlowFixMe(>=0.90.0)\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\nfunction undefineIfEmpty(arr) {\n  return arr && arr.length > 0 ? arr : undefined;\n}\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function does not return a value (i.e. it returns\n * `undefined`) then an error will be raised and a `null` value will be returned\n * in the response. If the serialize function returns `null`, then no error will\n * be included in the response.\n *\n * Example:\n *\n *     const OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         if (value % 2 === 1) {\n *           return value;\n *         }\n *       }\n *     });\n *\n */\n\n\nexport var GraphQLScalarType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLScalarType(config) {\n    var parseValue = config.parseValue || identityFunc;\n    this.name = config.name;\n    this.description = config.description;\n    this.serialize = config.serialize || identityFunc;\n    this.parseValue = parseValue;\n\n    this.parseLiteral = config.parseLiteral || function (node) {\n      return parseValue(valueFromASTUntyped(node));\n    };\n\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.serialize == null || typeof config.serialize === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"serialize\\\" function. If this custom Scalar is also used as an input type, ensure \\\"parseValue\\\" and \\\"parseLiteral\\\" functions are also provided.\"));\n\n    if (config.parseLiteral) {\n      typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function' || devAssert(0, \"\".concat(this.name, \" must provide both \\\"parseValue\\\" and \\\"parseLiteral\\\" functions.\"));\n    }\n  }\n\n  var _proto = GraphQLScalarType.prototype;\n\n  _proto.toConfig = function toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      serialize: this.serialize,\n      parseValue: this.parseValue,\n      parseLiteral: this.parseLiteral,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLScalarType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLScalarType);\ndefineToJSON(GraphQLScalarType);\n\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     const AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */\nexport var GraphQLObjectType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLObjectType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.isTypeOf = config.isTypeOf;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._fields = defineFieldMap.bind(undefined, config);\n    this._interfaces = defineInterfaces.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.isTypeOf == null || typeof config.isTypeOf === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"isTypeOf\\\" as a function, \") + \"but got: \".concat(inspect(config.isTypeOf), \".\"));\n  }\n\n  var _proto2 = GraphQLObjectType.prototype;\n\n  _proto2.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto2.getInterfaces = function getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  };\n\n  _proto2.toConfig = function toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      isTypeOf: this.isTypeOf,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto2.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLObjectType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLObjectType);\ndefineToJSON(GraphQLObjectType);\n\nfunction defineInterfaces(config) {\n  var interfaces = resolveThunk(config.interfaces) || [];\n  Array.isArray(interfaces) || devAssert(0, \"\".concat(config.name, \" interfaces must be an Array or a function which returns an Array.\"));\n  return interfaces;\n}\n\nfunction defineFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields) || {};\n  isPlainObj(fieldMap) || devAssert(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a function which returns such an object.\"));\n  return mapValue(fieldMap, function (fieldConfig, fieldName) {\n    isPlainObj(fieldConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" field config must be an object\"));\n    !('isDeprecated' in fieldConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" should provide \\\"deprecationReason\\\" instead of \\\"isDeprecated\\\".\"));\n    fieldConfig.resolve == null || typeof fieldConfig.resolve === 'function' || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" field resolver must be a function if \") + \"provided, but got: \".concat(inspect(fieldConfig.resolve), \".\"));\n    var argsConfig = fieldConfig.args || {};\n    isPlainObj(argsConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" args must be an object with argument names as keys.\"));\n    var args = objectEntries(argsConfig).map(function (_ref) {\n      var argName = _ref[0],\n          arg = _ref[1];\n      return {\n        name: argName,\n        description: arg.description === undefined ? null : arg.description,\n        type: arg.type,\n        defaultValue: arg.defaultValue,\n        extensions: arg.extensions && toObjMap(arg.extensions),\n        astNode: arg.astNode\n      };\n    });\n    return _objectSpread({}, fieldConfig, {\n      name: fieldName,\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      args: args,\n      resolve: fieldConfig.resolve,\n      subscribe: fieldConfig.subscribe,\n      isDeprecated: Boolean(fieldConfig.deprecationReason),\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    });\n  });\n}\n\nfunction isPlainObj(obj) {\n  return isObjectLike(obj) && !Array.isArray(obj);\n}\n\nfunction fieldsToFieldsConfig(fields) {\n  return mapValue(fields, function (field) {\n    return {\n      description: field.description,\n      type: field.type,\n      args: argsToArgsConfig(field.args),\n      resolve: field.resolve,\n      subscribe: field.subscribe,\n      deprecationReason: field.deprecationReason,\n      extensions: field.extensions,\n      astNode: field.astNode\n    };\n  });\n}\n\nexport function argsToArgsConfig(args) {\n  return keyValMap(args, function (arg) {\n    return arg.name;\n  }, function (arg) {\n    return {\n      description: arg.description,\n      type: arg.type,\n      defaultValue: arg.defaultValue,\n      extensions: arg.extensions,\n      astNode: arg.astNode\n    };\n  });\n}\nexport function isRequiredArgument(arg) {\n  return isNonNullType(arg.type) && arg.defaultValue === undefined;\n}\n\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     const EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */\nexport var GraphQLInterfaceType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLInterfaceType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._fields = defineFieldMap.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.resolveType == null || typeof config.resolveType === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat(inspect(config.resolveType), \".\"));\n  }\n\n  var _proto3 = GraphQLInterfaceType.prototype;\n\n  _proto3.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto3.toConfig = function toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      fields: fieldsToFieldsConfig(this.getFields()),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto3.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInterfaceType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLInterfaceType);\ndefineToJSON(GraphQLInterfaceType);\n\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     const PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */\nexport var GraphQLUnionType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLUnionType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._types = defineTypes.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n    config.resolveType == null || typeof config.resolveType === 'function' || devAssert(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat(inspect(config.resolveType), \".\"));\n  }\n\n  var _proto4 = GraphQLUnionType.prototype;\n\n  _proto4.getTypes = function getTypes() {\n    if (typeof this._types === 'function') {\n      this._types = this._types();\n    }\n\n    return this._types;\n  };\n\n  _proto4.toConfig = function toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      types: this.getTypes(),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto4.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLUnionType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLUnionType);\ndefineToJSON(GraphQLUnionType);\n\nfunction defineTypes(config) {\n  var types = resolveThunk(config.types) || [];\n  Array.isArray(types) || devAssert(0, \"Must provide Array of types or a function which returns such an array for Union \".concat(config.name, \".\"));\n  return types;\n}\n\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     const RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\nexport var GraphQLEnumType\n/* <T> */\n=\n/*#__PURE__*/\nfunction () {\n  function GraphQLEnumType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._values = defineEnumValues(this.name, config.values);\n    this._valueLookup = new Map(this._values.map(function (enumValue) {\n      return [enumValue.value, enumValue];\n    }));\n    this._nameLookup = keyMap(this._values, function (value) {\n      return value.name;\n    });\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n  }\n\n  var _proto5 = GraphQLEnumType.prototype;\n\n  _proto5.getValues = function getValues() {\n    return this._values;\n  };\n\n  _proto5.getValue = function getValue(name) {\n    return this._nameLookup[name];\n  };\n\n  _proto5.serialize = function serialize(value) {\n    var enumValue = this._valueLookup.get(value);\n\n    if (enumValue) {\n      return enumValue.name;\n    }\n  };\n\n  _proto5.parseValue = function parseValue(value)\n  /* T */\n  {\n    if (typeof value === 'string') {\n      var enumValue = this.getValue(value);\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  _proto5.parseLiteral = function parseLiteral(valueNode, _variables)\n  /* T */\n  {\n    // Note: variables will be resolved to a value before calling this function.\n    if (valueNode.kind === Kind.ENUM) {\n      var enumValue = this.getValue(valueNode.value);\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  _proto5.toConfig = function toConfig() {\n    var values = keyValMap(this.getValues(), function (value) {\n      return value.name;\n    }, function (value) {\n      return {\n        description: value.description,\n        value: value.value,\n        deprecationReason: value.deprecationReason,\n        extensions: value.extensions,\n        astNode: value.astNode\n      };\n    });\n    return {\n      name: this.name,\n      description: this.description,\n      values: values,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto5.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLEnumType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLEnumType);\ndefineToJSON(GraphQLEnumType);\n\nfunction defineEnumValues(typeName, valueMap) {\n  isPlainObj(valueMap) || devAssert(0, \"\".concat(typeName, \" values must be an object with value names as keys.\"));\n  return objectEntries(valueMap).map(function (_ref2) {\n    var valueName = _ref2[0],\n        value = _ref2[1];\n    isPlainObj(value) || devAssert(0, \"\".concat(typeName, \".\").concat(valueName, \" must refer to an object with a \\\"value\\\" key \") + \"representing an internal value but got: \".concat(inspect(value), \".\"));\n    !('isDeprecated' in value) || devAssert(0, \"\".concat(typeName, \".\").concat(valueName, \" should provide \\\"deprecationReason\\\" instead of \\\"isDeprecated\\\".\"));\n    return {\n      name: valueName,\n      description: value.description,\n      value: 'value' in value ? value.value : valueName,\n      isDeprecated: Boolean(value.deprecationReason),\n      deprecationReason: value.deprecationReason,\n      extensions: value.extensions && toObjMap(value.extensions),\n      astNode: value.astNode\n    };\n  });\n}\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     const GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */\nexport var GraphQLInputObjectType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLInputObjectType(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);\n    this._fields = defineInputFieldMap.bind(undefined, config);\n    typeof config.name === 'string' || devAssert(0, 'Must provide name.');\n  }\n\n  var _proto6 = GraphQLInputObjectType.prototype;\n\n  _proto6.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto6.toConfig = function toConfig() {\n    var fields = mapValue(this.getFields(), function (field) {\n      return {\n        description: field.description,\n        type: field.type,\n        defaultValue: field.defaultValue,\n        extensions: field.extensions,\n        astNode: field.astNode\n      };\n    });\n    return {\n      name: this.name,\n      description: this.description,\n      fields: fields,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes || []\n    };\n  };\n\n  _proto6.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInputObjectType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLInputObjectType);\ndefineToJSON(GraphQLInputObjectType);\n\nfunction defineInputFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields) || {};\n  isPlainObj(fieldMap) || devAssert(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a function which returns such an object.\"));\n  return mapValue(fieldMap, function (fieldConfig, fieldName) {\n    !('resolve' in fieldConfig) || devAssert(0, \"\".concat(config.name, \".\").concat(fieldName, \" field has a resolve property, but Input Types cannot define resolvers.\"));\n    return _objectSpread({}, fieldConfig, {\n      name: fieldName,\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      defaultValue: fieldConfig.defaultValue,\n      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    });\n  });\n}\n\nexport function isRequiredInputField(field) {\n  return isNonNullType(field.type) && field.defaultValue === undefined;\n}\n","/**\n * The set of allowed directive location values.\n */\nexport var DirectiveLocation = Object.freeze({\n  // Request Definitions\n  QUERY: 'QUERY',\n  MUTATION: 'MUTATION',\n  SUBSCRIPTION: 'SUBSCRIPTION',\n  FIELD: 'FIELD',\n  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',\n  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',\n  INLINE_FRAGMENT: 'INLINE_FRAGMENT',\n  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',\n  // Type System Definitions\n  SCHEMA: 'SCHEMA',\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  FIELD_DEFINITION: 'FIELD_DEFINITION',\n  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  ENUM_VALUE: 'ENUM_VALUE',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'\n});\n/**\n * The enum type representing the directive location values.\n */\n","/* eslint-disable no-redeclare */\n// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/4441\nvar isFinitePolyfill = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value);\n};\n\nexport default isFinitePolyfill;\n","/* eslint-disable no-redeclare */\n// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/4441\nvar isInteger = Number.isInteger || function (value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n};\n\nexport default isInteger;\n","import isFinite from '../polyfills/isFinite';\nimport isInteger from '../polyfills/isInteger';\nimport inspect from '../jsutils/inspect';\nimport isObjectLike from '../jsutils/isObjectLike';\nimport { Kind } from '../language/kinds';\nimport { GraphQLScalarType, isScalarType } from './definition'; // As per the GraphQL Spec, Integers are only treated as valid when a valid\n// 32-bit signed integer, providing the broadest support across platforms.\n//\n// n.b. JavaScript's integers are safe between -(2^53 - 1) and 2^53 - 1 because\n// they are internally represented as IEEE 754 doubles.\n\nvar MAX_INT = 2147483647;\nvar MIN_INT = -2147483648;\n\nfunction serializeInt(value) {\n  if (typeof value === 'boolean') {\n    return value ? 1 : 0;\n  }\n\n  var num = value;\n\n  if (typeof value === 'string' && value !== '') {\n    num = Number(value);\n  }\n\n  if (!isInteger(num)) {\n    throw new TypeError(\"Int cannot represent non-integer value: \".concat(inspect(value)));\n  }\n\n  if (num > MAX_INT || num < MIN_INT) {\n    throw new TypeError(\"Int cannot represent non 32-bit signed integer value: \".concat(inspect(value)));\n  }\n\n  return num;\n}\n\nfunction coerceInt(value) {\n  if (!isInteger(value)) {\n    throw new TypeError(\"Int cannot represent non-integer value: \".concat(inspect(value)));\n  }\n\n  if (value > MAX_INT || value < MIN_INT) {\n    throw new TypeError(\"Int cannot represent non 32-bit signed integer value: \".concat(inspect(value)));\n  }\n\n  return value;\n}\n\nexport var GraphQLInt = new GraphQLScalarType({\n  name: 'Int',\n  description: 'The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.',\n  serialize: serializeInt,\n  parseValue: coerceInt,\n  parseLiteral: function parseLiteral(ast) {\n    if (ast.kind === Kind.INT) {\n      var num = parseInt(ast.value, 10);\n\n      if (num <= MAX_INT && num >= MIN_INT) {\n        return num;\n      }\n    }\n\n    return undefined;\n  }\n});\n\nfunction serializeFloat(value) {\n  if (typeof value === 'boolean') {\n    return value ? 1 : 0;\n  }\n\n  var num = value;\n\n  if (typeof value === 'string' && value !== '') {\n    num = Number(value);\n  }\n\n  if (!isFinite(num)) {\n    throw new TypeError(\"Float cannot represent non numeric value: \".concat(inspect(value)));\n  }\n\n  return num;\n}\n\nfunction coerceFloat(value) {\n  if (!isFinite(value)) {\n    throw new TypeError(\"Float cannot represent non numeric value: \".concat(inspect(value)));\n  }\n\n  return value;\n}\n\nexport var GraphQLFloat = new GraphQLScalarType({\n  name: 'Float',\n  description: 'The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).',\n  serialize: serializeFloat,\n  parseValue: coerceFloat,\n  parseLiteral: function parseLiteral(ast) {\n    return ast.kind === Kind.FLOAT || ast.kind === Kind.INT ? parseFloat(ast.value) : undefined;\n  }\n}); // Support serializing objects with custom valueOf() or toJSON() functions -\n// a common way to represent a complex value which can be represented as\n// a string (ex: MongoDB id objects).\n\nfunction serializeObject(value) {\n  if (isObjectLike(value)) {\n    if (typeof value.valueOf === 'function') {\n      var valueOfResult = value.valueOf();\n\n      if (!isObjectLike(valueOfResult)) {\n        return valueOfResult;\n      }\n    }\n\n    if (typeof value.toJSON === 'function') {\n      // $FlowFixMe(>=0.90.0)\n      return value.toJSON();\n    }\n  }\n\n  return value;\n}\n\nfunction serializeString(rawValue) {\n  var value = serializeObject(rawValue); // Serialize string, boolean and number values to a string, but do not\n  // attempt to coerce object, function, symbol, or other types as strings.\n\n  if (typeof value === 'string') {\n    return value;\n  }\n\n  if (typeof value === 'boolean') {\n    return value ? 'true' : 'false';\n  }\n\n  if (isFinite(value)) {\n    return value.toString();\n  }\n\n  throw new TypeError(\"String cannot represent value: \".concat(inspect(rawValue)));\n}\n\nfunction coerceString(value) {\n  if (typeof value !== 'string') {\n    throw new TypeError(\"String cannot represent a non string value: \".concat(inspect(value)));\n  }\n\n  return value;\n}\n\nexport var GraphQLString = new GraphQLScalarType({\n  name: 'String',\n  description: 'The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.',\n  serialize: serializeString,\n  parseValue: coerceString,\n  parseLiteral: function parseLiteral(ast) {\n    return ast.kind === Kind.STRING ? ast.value : undefined;\n  }\n});\n\nfunction serializeBoolean(value) {\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (isFinite(value)) {\n    return value !== 0;\n  }\n\n  throw new TypeError(\"Boolean cannot represent a non boolean value: \".concat(inspect(value)));\n}\n\nfunction coerceBoolean(value) {\n  if (typeof value !== 'boolean') {\n    throw new TypeError(\"Boolean cannot represent a non boolean value: \".concat(inspect(value)));\n  }\n\n  return value;\n}\n\nexport var GraphQLBoolean = new GraphQLScalarType({\n  name: 'Boolean',\n  description: 'The `Boolean` scalar type represents `true` or `false`.',\n  serialize: serializeBoolean,\n  parseValue: coerceBoolean,\n  parseLiteral: function parseLiteral(ast) {\n    return ast.kind === Kind.BOOLEAN ? ast.value : undefined;\n  }\n});\n\nfunction serializeID(rawValue) {\n  var value = serializeObject(rawValue);\n\n  if (typeof value === 'string') {\n    return value;\n  }\n\n  if (isInteger(value)) {\n    return String(value);\n  }\n\n  throw new TypeError(\"ID cannot represent value: \".concat(inspect(rawValue)));\n}\n\nfunction coerceID(value) {\n  if (typeof value === 'string') {\n    return value;\n  }\n\n  if (isInteger(value)) {\n    return value.toString();\n  }\n\n  throw new TypeError(\"ID cannot represent value: \".concat(inspect(value)));\n}\n\nexport var GraphQLID = new GraphQLScalarType({\n  name: 'ID',\n  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.',\n  serialize: serializeID,\n  parseValue: coerceID,\n  parseLiteral: function parseLiteral(ast) {\n    return ast.kind === Kind.STRING || ast.kind === Kind.INT ? ast.value : undefined;\n  }\n});\nexport var specifiedScalarTypes = Object.freeze([GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID]);\nexport function isSpecifiedScalarType(type) {\n  return isScalarType(type) && specifiedScalarTypes.some(function (_ref) {\n    var name = _ref.name;\n    return type.name === name;\n  });\n}\n","import objectEntries from '../polyfills/objectEntries';\nimport inspect from '../jsutils/inspect';\nimport toObjMap from '../jsutils/toObjMap';\nimport devAssert from '../jsutils/devAssert';\nimport instanceOf from '../jsutils/instanceOf';\nimport defineToJSON from '../jsutils/defineToJSON';\nimport isObjectLike from '../jsutils/isObjectLike';\nimport defineToStringTag from '../jsutils/defineToStringTag';\nimport { DirectiveLocation } from '../language/directiveLocation';\nimport { GraphQLString, GraphQLBoolean } from './scalars';\nimport { argsToArgsConfig, GraphQLNonNull } from './definition';\n/**\n * Test if the given value is a GraphQL directive.\n */\n\n// eslint-disable-next-line no-redeclare\nexport function isDirective(directive) {\n  return instanceOf(directive, GraphQLDirective);\n}\nexport function assertDirective(directive) {\n  if (!isDirective(directive)) {\n    throw new Error(\"Expected \".concat(inspect(directive), \" to be a GraphQL directive.\"));\n  }\n\n  return directive;\n}\n/**\n * Directives are used by the GraphQL runtime as a way of modifying execution\n * behavior. Type system creators will usually not create these directly.\n */\n\nexport var GraphQLDirective =\n/*#__PURE__*/\nfunction () {\n  function GraphQLDirective(config) {\n    this.name = config.name;\n    this.description = config.description;\n    this.locations = config.locations;\n    this.isRepeatable = config.isRepeatable != null && config.isRepeatable;\n    this.extensions = config.extensions && toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    config.name || devAssert(0, 'Directive must be named.');\n    Array.isArray(config.locations) || devAssert(0, \"@\".concat(config.name, \" locations must be an Array.\"));\n    var args = config.args || {};\n    isObjectLike(args) && !Array.isArray(args) || devAssert(0, \"@\".concat(config.name, \" args must be an object with argument names as keys.\"));\n    this.args = objectEntries(args).map(function (_ref) {\n      var argName = _ref[0],\n          arg = _ref[1];\n      return {\n        name: argName,\n        description: arg.description === undefined ? null : arg.description,\n        type: arg.type,\n        defaultValue: arg.defaultValue,\n        extensions: arg.extensions && toObjMap(arg.extensions),\n        astNode: arg.astNode\n      };\n    });\n  }\n\n  var _proto = GraphQLDirective.prototype;\n\n  _proto.toString = function toString() {\n    return '@' + this.name;\n  };\n\n  _proto.toConfig = function toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      locations: this.locations,\n      args: argsToArgsConfig(this.args),\n      isRepeatable: this.isRepeatable,\n      extensions: this.extensions,\n      astNode: this.astNode\n    };\n  };\n\n  return GraphQLDirective;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(GraphQLDirective);\ndefineToJSON(GraphQLDirective);\n\n/**\n * Used to conditionally include fields or fragments.\n */\nexport var GraphQLIncludeDirective = new GraphQLDirective({\n  name: 'include',\n  description: 'Directs the executor to include this field or fragment only when the `if` argument is true.',\n  locations: [DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],\n  args: {\n    if: {\n      type: GraphQLNonNull(GraphQLBoolean),\n      description: 'Included when true.'\n    }\n  }\n});\n/**\n * Used to conditionally skip (exclude) fields or fragments.\n */\n\nexport var GraphQLSkipDirective = new GraphQLDirective({\n  name: 'skip',\n  description: 'Directs the executor to skip this field or fragment when the `if` argument is true.',\n  locations: [DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],\n  args: {\n    if: {\n      type: GraphQLNonNull(GraphQLBoolean),\n      description: 'Skipped when true.'\n    }\n  }\n});\n/**\n * Constant string used for default reason for a deprecation.\n */\n\nexport var DEFAULT_DEPRECATION_REASON = 'No longer supported';\n/**\n * Used to declare element of a GraphQL schema as deprecated.\n */\n\nexport var GraphQLDeprecatedDirective = new GraphQLDirective({\n  name: 'deprecated',\n  description: 'Marks an element of a GraphQL schema as no longer supported.',\n  locations: [DirectiveLocation.FIELD_DEFINITION, DirectiveLocation.ENUM_VALUE],\n  args: {\n    reason: {\n      type: GraphQLString,\n      description: 'Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax (as specified by [CommonMark](https://commonmark.org/).',\n      defaultValue: DEFAULT_DEPRECATION_REASON\n    }\n  }\n});\n/**\n * The full list of specified directives.\n */\n\nexport var specifiedDirectives = Object.freeze([GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective]);\nexport function isSpecifiedDirective(directive) {\n  return isDirective(directive) && specifiedDirectives.some(function (_ref2) {\n    var name = _ref2.name;\n    return name === directive.name;\n  });\n}\n","import inspect from '../jsutils/inspect';\nexport var QueryDocumentKeys = {\n  Name: [],\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed\n  // or removed in the future.\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n  Directive: ['name', 'arguments'],\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n  SchemaDefinition: ['directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],\n  SchemaExtension: ['directives', 'operationTypes'],\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields']\n};\nexport var BREAK = Object.freeze({});\n/**\n * visit() will walk through an AST using a depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\n\nexport function visit(root, visitor) {\n  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n\n  /* eslint-disable no-undef-init */\n  var stack = undefined;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var node = undefined;\n  var key = undefined;\n  var parent = undefined;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n\n          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {\n            var k = _Object$keys2[_i2];\n            clone[k] = node[k];\n          }\n\n          node = clone;\n        }\n\n        var editOffset = 0;\n\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n\n          if (inArray) {\n            editKey -= editOffset;\n          }\n\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error('Invalid AST Node: ' + inspect(node));\n      }\n\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      stack = {\n        inArray: inArray,\n        index: index,\n        keys: keys,\n        edits: edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : visitorKeys[node.kind] || [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n\nfunction isNode(maybeNode) {\n  return Boolean(maybeNode && typeof maybeNode.kind === 'string');\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\n\nexport function visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          false);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          true);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      false);\n\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      true);\n      var result;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\n\nexport function getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n\n      var specificKindVisitor = specificVisitor[kind];\n\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}\n","/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n */\nexport function dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n} // @internal\n\nexport function getBlockStringIndentation(lines) {\n  var commonIndent = null;\n\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\n\n\nexport function printBlockString(value) {\n  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isSingleLine = value.indexOf('\\n') === -1;\n  var hasLeadingSpace = value[0] === ' ' || value[0] === '\\t';\n  var hasTrailingQuote = value[value.length - 1] === '\"';\n  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || preferMultipleLines;\n  var result = ''; // Format a multi-line block quote to account for leading space.\n\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\n    result += '\\n' + indentation;\n  }\n\n  result += indentation ? value.replace(/\\n/g, '\\n' + indentation) : value;\n\n  if (printAsMultipleLines) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n}\n","import { visit } from './visitor';\nimport { printBlockString } from './blockString';\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\nexport function print(ast) {\n  return visit(ast, {\n    leave: printDocASTReducer\n  });\n} // TODO: provide better type coverage in future\n\nvar printDocASTReducer = {\n  Name: function Name(node) {\n    return node.value;\n  },\n  Variable: function Variable(node) {\n    return '$' + node.name;\n  },\n  // Document\n  Document: function Document(node) {\n    return join(node.definitions, '\\n\\n') + '\\n';\n  },\n  OperationDefinition: function OperationDefinition(node) {\n    var op = node.operation;\n    var name = node.name;\n    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n    var directives = join(node.directives, ' ');\n    var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use\n    // the query short form.\n\n    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');\n  },\n  VariableDefinition: function VariableDefinition(_ref) {\n    var variable = _ref.variable,\n        type = _ref.type,\n        defaultValue = _ref.defaultValue,\n        directives = _ref.directives;\n    return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));\n  },\n  SelectionSet: function SelectionSet(_ref2) {\n    var selections = _ref2.selections;\n    return block(selections);\n  },\n  Field: function Field(_ref3) {\n    var alias = _ref3.alias,\n        name = _ref3.name,\n        args = _ref3.arguments,\n        directives = _ref3.directives,\n        selectionSet = _ref3.selectionSet;\n    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');\n  },\n  Argument: function Argument(_ref4) {\n    var name = _ref4.name,\n        value = _ref4.value;\n    return name + ': ' + value;\n  },\n  // Fragments\n  FragmentSpread: function FragmentSpread(_ref5) {\n    var name = _ref5.name,\n        directives = _ref5.directives;\n    return '...' + name + wrap(' ', join(directives, ' '));\n  },\n  InlineFragment: function InlineFragment(_ref6) {\n    var typeCondition = _ref6.typeCondition,\n        directives = _ref6.directives,\n        selectionSet = _ref6.selectionSet;\n    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n  },\n  FragmentDefinition: function FragmentDefinition(_ref7) {\n    var name = _ref7.name,\n        typeCondition = _ref7.typeCondition,\n        variableDefinitions = _ref7.variableDefinitions,\n        directives = _ref7.directives,\n        selectionSet = _ref7.selectionSet;\n    return (// Note: fragment variable definitions are experimental and may be changed\n      // or removed in the future.\n      \"fragment \".concat(name).concat(wrap('(', join(variableDefinitions, ', '), ')'), \" \") + \"on \".concat(typeCondition, \" \").concat(wrap('', join(directives, ' '), ' ')) + selectionSet\n    );\n  },\n  // Value\n  IntValue: function IntValue(_ref8) {\n    var value = _ref8.value;\n    return value;\n  },\n  FloatValue: function FloatValue(_ref9) {\n    var value = _ref9.value;\n    return value;\n  },\n  StringValue: function StringValue(_ref10, key) {\n    var value = _ref10.value,\n        isBlockString = _ref10.block;\n    return isBlockString ? printBlockString(value, key === 'description' ? '' : '  ') : JSON.stringify(value);\n  },\n  BooleanValue: function BooleanValue(_ref11) {\n    var value = _ref11.value;\n    return value ? 'true' : 'false';\n  },\n  NullValue: function NullValue() {\n    return 'null';\n  },\n  EnumValue: function EnumValue(_ref12) {\n    var value = _ref12.value;\n    return value;\n  },\n  ListValue: function ListValue(_ref13) {\n    var values = _ref13.values;\n    return '[' + join(values, ', ') + ']';\n  },\n  ObjectValue: function ObjectValue(_ref14) {\n    var fields = _ref14.fields;\n    return '{' + join(fields, ', ') + '}';\n  },\n  ObjectField: function ObjectField(_ref15) {\n    var name = _ref15.name,\n        value = _ref15.value;\n    return name + ': ' + value;\n  },\n  // Directive\n  Directive: function Directive(_ref16) {\n    var name = _ref16.name,\n        args = _ref16.arguments;\n    return '@' + name + wrap('(', join(args, ', '), ')');\n  },\n  // Type\n  NamedType: function NamedType(_ref17) {\n    var name = _ref17.name;\n    return name;\n  },\n  ListType: function ListType(_ref18) {\n    var type = _ref18.type;\n    return '[' + type + ']';\n  },\n  NonNullType: function NonNullType(_ref19) {\n    var type = _ref19.type;\n    return type + '!';\n  },\n  // Type System Definitions\n  SchemaDefinition: function SchemaDefinition(_ref20) {\n    var directives = _ref20.directives,\n        operationTypes = _ref20.operationTypes;\n    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {\n    var operation = _ref21.operation,\n        type = _ref21.type;\n    return operation + ': ' + type;\n  },\n  ScalarTypeDefinition: addDescription(function (_ref22) {\n    var name = _ref22.name,\n        directives = _ref22.directives;\n    return join(['scalar', name, join(directives, ' ')], ' ');\n  }),\n  ObjectTypeDefinition: addDescription(function (_ref23) {\n    var name = _ref23.name,\n        interfaces = _ref23.interfaces,\n        directives = _ref23.directives,\n        fields = _ref23.fields;\n    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  }),\n  FieldDefinition: addDescription(function (_ref24) {\n    var name = _ref24.name,\n        args = _ref24.arguments,\n        type = _ref24.type,\n        directives = _ref24.directives;\n    return name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));\n  }),\n  InputValueDefinition: addDescription(function (_ref25) {\n    var name = _ref25.name,\n        type = _ref25.type,\n        defaultValue = _ref25.defaultValue,\n        directives = _ref25.directives;\n    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n  }),\n  InterfaceTypeDefinition: addDescription(function (_ref26) {\n    var name = _ref26.name,\n        directives = _ref26.directives,\n        fields = _ref26.fields;\n    return join(['interface', name, join(directives, ' '), block(fields)], ' ');\n  }),\n  UnionTypeDefinition: addDescription(function (_ref27) {\n    var name = _ref27.name,\n        directives = _ref27.directives,\n        types = _ref27.types;\n    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  }),\n  EnumTypeDefinition: addDescription(function (_ref28) {\n    var name = _ref28.name,\n        directives = _ref28.directives,\n        values = _ref28.values;\n    return join(['enum', name, join(directives, ' '), block(values)], ' ');\n  }),\n  EnumValueDefinition: addDescription(function (_ref29) {\n    var name = _ref29.name,\n        directives = _ref29.directives;\n    return join([name, join(directives, ' ')], ' ');\n  }),\n  InputObjectTypeDefinition: addDescription(function (_ref30) {\n    var name = _ref30.name,\n        directives = _ref30.directives,\n        fields = _ref30.fields;\n    return join(['input', name, join(directives, ' '), block(fields)], ' ');\n  }),\n  DirectiveDefinition: addDescription(function (_ref31) {\n    var name = _ref31.name,\n        args = _ref31.arguments,\n        repeatable = _ref31.repeatable,\n        locations = _ref31.locations;\n    return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');\n  }),\n  SchemaExtension: function SchemaExtension(_ref32) {\n    var directives = _ref32.directives,\n        operationTypes = _ref32.operationTypes;\n    return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {\n    var name = _ref33.name,\n        directives = _ref33.directives;\n    return join(['extend scalar', name, join(directives, ' ')], ' ');\n  },\n  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {\n    var name = _ref34.name,\n        interfaces = _ref34.interfaces,\n        directives = _ref34.directives,\n        fields = _ref34.fields;\n    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  },\n  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {\n    var name = _ref35.name,\n        directives = _ref35.directives,\n        fields = _ref35.fields;\n    return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');\n  },\n  UnionTypeExtension: function UnionTypeExtension(_ref36) {\n    var name = _ref36.name,\n        directives = _ref36.directives,\n        types = _ref36.types;\n    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  },\n  EnumTypeExtension: function EnumTypeExtension(_ref37) {\n    var name = _ref37.name,\n        directives = _ref37.directives,\n        values = _ref37.values;\n    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n  },\n  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {\n    var name = _ref38.name,\n        directives = _ref38.directives,\n        fields = _ref38.fields;\n    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n  }\n};\n\nfunction addDescription(cb) {\n  return function (node) {\n    return join([node.description, cb(node)], '\\n');\n  };\n}\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\n\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(function (x) {\n    return x;\n  }).join(separator || '') : '';\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\n\n\nfunction block(array) {\n  return array && array.length !== 0 ? '{\\n' + indent(join(array, '\\n')) + '\\n}' : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\n\n\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n\nfunction indent(maybeString) {\n  return maybeString && '  ' + maybeString.replace(/\\n/g, '\\n  ');\n}\n\nfunction isMultiline(string) {\n  return string.indexOf('\\n') !== -1;\n}\n\nfunction hasMultilineItems(maybeArray) {\n  return maybeArray && maybeArray.some(isMultiline);\n}\n","import inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport { Kind } from '../language/kinds';\nimport { GraphQLList, GraphQLNonNull } from '../type/definition';\n/**\n * Given a Schema and an AST node describing a type, return a GraphQLType\n * definition which applies to that type. For example, if provided the parsed\n * AST node for `[User]`, a GraphQLList instance will be returned, containing\n * the type called \"User\" found in the schema. If a type called \"User\" is not\n * found in the schema, then undefined will be returned.\n */\n\n/* eslint-disable no-redeclare */\n\nexport function typeFromAST(schema, typeNode) {\n  /* eslint-enable no-redeclare */\n  var innerType;\n\n  if (typeNode.kind === Kind.LIST_TYPE) {\n    innerType = typeFromAST(schema, typeNode.type);\n    return innerType && GraphQLList(innerType);\n  }\n\n  if (typeNode.kind === Kind.NON_NULL_TYPE) {\n    innerType = typeFromAST(schema, typeNode.type);\n    return innerType && GraphQLNonNull(innerType);\n  }\n\n  /* istanbul ignore else */\n  if (typeNode.kind === Kind.NAMED_TYPE) {\n    return schema.getType(typeNode.name.value);\n  } // Not reachable. All possible type nodes have been considered.\n\n\n  /* istanbul ignore next */\n  invariant(false, 'Unexpected type node: ' + inspect(typeNode));\n}\n","import objectValues from '../polyfills/objectValues';\nimport keyMap from '../jsutils/keyMap';\nimport inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport isInvalid from '../jsutils/isInvalid';\nimport { Kind } from '../language/kinds';\nimport { isScalarType, isEnumType, isInputObjectType, isListType, isNonNullType } from '../type/definition';\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `undefined` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Number        |\n * | Enum Value           | Mixed         |\n * | NullValue            | null          |\n *\n */\n\nexport function valueFromAST(valueNode, type, variables) {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n\n  if (isNonNullType(type)) {\n    if (valueNode.kind === Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n\n  if (valueNode.kind === Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n\n  if (valueNode.kind === Kind.VARIABLE) {\n    var variableName = valueNode.name.value;\n\n    if (!variables || isInvalid(variables[variableName])) {\n      // No valid return value.\n      return;\n    }\n\n    var variableValue = variables[variableName];\n\n    if (variableValue === null && isNonNullType(type)) {\n      return; // Invalid: intentionally return no value.\n    } // Note: This does no further checking that this variable is correct.\n    // This assumes that this query has been validated and the variable\n    // usage here is of the correct type.\n\n\n    return variableValue;\n  }\n\n  if (isListType(type)) {\n    var itemType = type.ofType;\n\n    if (valueNode.kind === Kind.LIST) {\n      var coercedValues = [];\n\n      for (var _i2 = 0, _valueNode$values2 = valueNode.values; _i2 < _valueNode$values2.length; _i2++) {\n        var itemNode = _valueNode$values2[_i2];\n\n        if (isMissingVariable(itemNode, variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if (isNonNullType(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(null);\n        } else {\n          var itemValue = valueFromAST(itemNode, itemType, variables);\n\n          if (isInvalid(itemValue)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(itemValue);\n        }\n      }\n\n      return coercedValues;\n    }\n\n    var coercedValue = valueFromAST(valueNode, itemType, variables);\n\n    if (isInvalid(coercedValue)) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return [coercedValue];\n  }\n\n  if (isInputObjectType(type)) {\n    if (valueNode.kind !== Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    var coercedObj = Object.create(null);\n    var fieldNodes = keyMap(valueNode.fields, function (field) {\n      return field.name.value;\n    });\n\n    for (var _i4 = 0, _objectValues2 = objectValues(type.getFields()); _i4 < _objectValues2.length; _i4++) {\n      var field = _objectValues2[_i4];\n      var fieldNode = fieldNodes[field.name];\n\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (field.defaultValue !== undefined) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n\n        continue;\n      }\n\n      var fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n\n      if (isInvalid(fieldValue)) {\n        return; // Invalid: intentionally return no value.\n      }\n\n      coercedObj[field.name] = fieldValue;\n    }\n\n    return coercedObj;\n  }\n\n  if (isEnumType(type)) {\n    if (valueNode.kind !== Kind.ENUM) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    var enumValue = type.getValue(valueNode.value);\n\n    if (!enumValue) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return enumValue.value;\n  }\n\n  /* istanbul ignore else */\n  if (isScalarType(type)) {\n    // Scalars fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    var result;\n\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    if (isInvalid(result)) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return result;\n  } // Not reachable. All possible input types have been considered.\n\n\n  /* istanbul ignore next */\n  invariant(false, 'Unexpected input type: ' + inspect(type));\n} // Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\n\nfunction isMissingVariable(valueNode, variables) {\n  return valueNode.kind === Kind.VARIABLE && (!variables || isInvalid(variables[valueNode.name.value]));\n}\n","import find from '../polyfills/find';\nimport keyMap from '../jsutils/keyMap';\nimport inspect from '../jsutils/inspect';\nimport printPathArray from '../jsutils/printPathArray';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { Kind } from '../language/kinds';\nimport { print } from '../language/printer';\nimport { isInputType, isNonNullType } from '../type/definition';\nimport { typeFromAST } from '../utilities/typeFromAST';\nimport { valueFromAST } from '../utilities/valueFromAST';\nimport { coerceInputValue } from '../utilities/coerceInputValue';\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getVariableValues(schema, varDefNodes, inputs, options) {\n  var maxErrors = options && options.maxErrors;\n  var errors = [];\n\n  try {\n    var coerced = coerceVariableValues(schema, varDefNodes, inputs, function (error) {\n      if (maxErrors != null && errors.length >= maxErrors) {\n        throw new GraphQLError('Too many errors processing variables, error limit reached. Execution aborted.');\n      }\n\n      errors.push(error);\n    });\n\n    if (errors.length === 0) {\n      return {\n        coerced: coerced\n      };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n\n  return {\n    errors: errors\n  };\n}\n\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n  var coercedValues = {};\n\n  var _loop = function _loop(_i2) {\n    var varDefNode = varDefNodes[_i2];\n    var varName = varDefNode.variable.name.value;\n    var varType = typeFromAST(schema, varDefNode.type);\n\n    if (!isInputType(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      var varTypeStr = print(varDefNode.type);\n      onError(new GraphQLError(\"Variable \\\"$\".concat(varName, \"\\\" expected value of type \\\"\").concat(varTypeStr, \"\\\" which cannot be used as an input type.\"), varDefNode.type));\n      return \"continue\";\n    }\n\n    if (!hasOwnProperty(inputs, varName)) {\n      if (varDefNode.defaultValue) {\n        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n      } else if (isNonNullType(varType)) {\n        var _varTypeStr = inspect(varType);\n\n        onError(new GraphQLError(\"Variable \\\"$\".concat(varName, \"\\\" of required type \\\"\").concat(_varTypeStr, \"\\\" was not provided.\"), varDefNode));\n      }\n\n      return \"continue\";\n    }\n\n    var value = inputs[varName];\n\n    if (value === null && isNonNullType(varType)) {\n      var _varTypeStr2 = inspect(varType);\n\n      onError(new GraphQLError(\"Variable \\\"$\".concat(varName, \"\\\" of non-null type \\\"\").concat(_varTypeStr2, \"\\\" must not be null.\"), varDefNode));\n      return \"continue\";\n    }\n\n    coercedValues[varName] = coerceInputValue(value, varType, function (path, invalidValue, error) {\n      var prefix = \"Variable \\\"$\".concat(varName, \"\\\" got invalid value \") + inspect(invalidValue);\n\n      if (path.length > 0) {\n        prefix += \" at \\\"\".concat(varName).concat(printPathArray(path), \"\\\"\");\n      }\n\n      onError(new GraphQLError(prefix + '; ' + error.message, varDefNode, undefined, undefined, undefined, error.originalError));\n    });\n  };\n\n  for (var _i2 = 0; _i2 < varDefNodes.length; _i2++) {\n    var _ret = _loop(_i2);\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\n\nexport function getArgumentValues(def, node, variableValues) {\n  var coercedValues = {};\n  var argNodeMap = keyMap(node.arguments || [], function (arg) {\n    return arg.name.value;\n  });\n\n  for (var _i4 = 0, _def$args2 = def.args; _i4 < _def$args2.length; _i4++) {\n    var argDef = _def$args2[_i4];\n    var name = argDef.name;\n    var argType = argDef.type;\n    var argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of required type \\\"\").concat(inspect(argType), \"\\\" \") + 'was not provided.', node);\n      }\n\n      continue;\n    }\n\n    var valueNode = argumentNode.value;\n    var isNull = valueNode.kind === Kind.NULL;\n\n    if (valueNode.kind === Kind.VARIABLE) {\n      var variableName = valueNode.name.value;\n\n      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of required type \\\"\").concat(inspect(argType), \"\\\" \") + \"was provided the variable \\\"$\".concat(variableName, \"\\\" which was not provided a runtime value.\"), valueNode);\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && isNonNullType(argType)) {\n      throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of non-null type \\\"\").concat(inspect(argType), \"\\\" \") + 'must not be null.', valueNode);\n    }\n\n    var coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectType validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new GraphQLError(\"Argument \\\"\".concat(name, \"\\\" has invalid value \").concat(print(valueNode), \".\"), valueNode);\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getDirectiveValues(directiveDef, node, variableValues) {\n  var directiveNode = node.directives && find(node.directives, function (directive) {\n    return directive.name.value === directiveDef.name;\n  });\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","import { forEach, isCollection } from 'iterall';\nimport inspect from '../jsutils/inspect';\nimport memoize3 from '../jsutils/memoize3';\nimport invariant from '../jsutils/invariant';\nimport devAssert from '../jsutils/devAssert';\nimport isInvalid from '../jsutils/isInvalid';\nimport isNullish from '../jsutils/isNullish';\nimport isPromise from '../jsutils/isPromise';\nimport isObjectLike from '../jsutils/isObjectLike';\nimport promiseReduce from '../jsutils/promiseReduce';\nimport promiseForObject from '../jsutils/promiseForObject';\nimport { addPath, pathToArray } from '../jsutils/Path';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { locatedError } from '../error/locatedError';\nimport { Kind } from '../language/kinds';\nimport { assertValidSchema } from '../type/validate';\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from '../type/introspection';\nimport { GraphQLIncludeDirective, GraphQLSkipDirective } from '../type/directives';\nimport { isObjectType, isAbstractType, isLeafType, isListType, isNonNullType } from '../type/definition';\nimport { typeFromAST } from '../utilities/typeFromAST';\nimport { getOperationRootType } from '../utilities/getOperationRootType';\nimport { getVariableValues, getArgumentValues, getDirectiveValues } from './values';\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g \"a\"\n * 2) fragment \"spreads\" e.g. \"...c\"\n * 3) inline fragment \"spreads\" e.g. \"...on Type { a }\"\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\n\nexport function execute(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {\n  /* eslint-enable no-redeclare */\n  // Extract arguments from object args if provided.\n  return arguments.length === 1 ? executeImpl(argsOrSchema) : executeImpl({\n    schema: argsOrSchema,\n    document: document,\n    rootValue: rootValue,\n    contextValue: contextValue,\n    variableValues: variableValues,\n    operationName: operationName,\n    fieldResolver: fieldResolver,\n    typeResolver: typeResolver\n  });\n}\n\nfunction executeImpl(args) {\n  var schema = args.schema,\n      document = args.document,\n      rootValue = args.rootValue,\n      contextValue = args.contextValue,\n      variableValues = args.variableValues,\n      operationName = args.operationName,\n      fieldResolver = args.fieldResolver,\n      typeResolver = args.typeResolver; // If arguments are missing or incorrect, throw an error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  var exeContext = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver); // Return early errors if execution context failed.\n\n  if (Array.isArray(exeContext)) {\n    return {\n      errors: exeContext\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n\n\n  var data = executeOperation(exeContext, exeContext.operation, rootValue);\n  return buildResponse(exeContext, data);\n}\n/**\n * Given a completed execution context and data, build the { errors, data }\n * response defined by the \"Response\" section of the GraphQL specification.\n */\n\n\nfunction buildResponse(exeContext, data) {\n  if (isPromise(data)) {\n    return data.then(function (resolved) {\n      return buildResponse(exeContext, resolved);\n    });\n  }\n\n  return exeContext.errors.length === 0 ? {\n    data: data\n  } : {\n    errors: exeContext.errors,\n    data: data\n  };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n */\n\n\nexport function assertValidExecutionArguments(schema, document, rawVariableValues) {\n  document || devAssert(0, 'Must provide document'); // If the schema used for execution is invalid, throw an error.\n\n  assertValidSchema(schema); // Variables, if provided, must be an object.\n\n  rawVariableValues == null || isObjectLike(rawVariableValues) || devAssert(0, 'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.');\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n */\n\nexport function buildExecutionContext(schema, document, rootValue, contextValue, rawVariableValues, operationName, fieldResolver, typeResolver) {\n  var operation;\n  var hasMultipleAssumedOperations = false;\n  var fragments = Object.create(null);\n\n  for (var _i2 = 0, _document$definitions2 = document.definitions; _i2 < _document$definitions2.length; _i2++) {\n    var definition = _document$definitions2[_i2];\n\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        if (!operationName && operation) {\n          hasMultipleAssumedOperations = true;\n        } else if (!operationName || definition.name && definition.name.value === operationName) {\n          operation = definition;\n        }\n\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n    }\n  }\n\n  if (!operation) {\n    if (operationName) {\n      return [new GraphQLError(\"Unknown operation named \\\"\".concat(operationName, \"\\\".\"))];\n    }\n\n    return [new GraphQLError('Must provide an operation.')];\n  }\n\n  if (hasMultipleAssumedOperations) {\n    return [new GraphQLError('Must provide operation name if query contains multiple operations.')];\n  }\n\n  var coercedVariableValues = getVariableValues(schema, operation.variableDefinitions || [], rawVariableValues || {}, {\n    maxErrors: 50\n  });\n\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n\n  return {\n    schema: schema,\n    fragments: fragments,\n    rootValue: rootValue,\n    contextValue: contextValue,\n    operation: operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver: fieldResolver || defaultFieldResolver,\n    typeResolver: typeResolver || defaultTypeResolver,\n    errors: []\n  };\n}\n/**\n * Implements the \"Evaluating operations\" section of the spec.\n */\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  var type = getOperationRootType(exeContext.schema, operation);\n  var fields = collectFields(exeContext, type, operation.selectionSet, Object.create(null), Object.create(null));\n  var path = undefined; // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n  //\n  // Similar to completeValueCatchingError.\n\n  try {\n    var result = operation.operation === 'mutation' ? executeFieldsSerially(exeContext, type, rootValue, path, fields) : executeFields(exeContext, type, rootValue, path, fields);\n\n    if (isPromise(result)) {\n      return result.then(undefined, function (error) {\n        exeContext.errors.push(error);\n        return Promise.resolve(null);\n      });\n    }\n\n    return result;\n  } catch (error) {\n    exeContext.errors.push(error);\n    return null;\n  }\n}\n/**\n * Implements the \"Evaluating selection sets\" section of the spec\n * for \"write\" mode.\n */\n\n\nfunction executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {\n  return promiseReduce(Object.keys(fields), function (results, responseName) {\n    var fieldNodes = fields[responseName];\n    var fieldPath = addPath(path, responseName);\n    var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n\n    if (result === undefined) {\n      return results;\n    }\n\n    if (isPromise(result)) {\n      return result.then(function (resolvedResult) {\n        results[responseName] = resolvedResult;\n        return results;\n      });\n    }\n\n    results[responseName] = result;\n    return results;\n  }, Object.create(null));\n}\n/**\n * Implements the \"Evaluating selection sets\" section of the spec\n * for \"read\" mode.\n */\n\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  var results = Object.create(null);\n  var containsPromise = false;\n\n  for (var _i4 = 0, _Object$keys2 = Object.keys(fields); _i4 < _Object$keys2.length; _i4++) {\n    var responseName = _Object$keys2[_i4];\n    var fieldNodes = fields[responseName];\n    var fieldPath = addPath(path, responseName);\n    var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n\n    if (result !== undefined) {\n      results[responseName] = result;\n\n      if (!containsPromise && isPromise(result)) {\n        containsPromise = true;\n      }\n    }\n  } // If there are no promises, we can just return the object\n\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n\n  return promiseForObject(results);\n}\n/**\n * Given a selectionSet, adds all of the fields in that selection to\n * the passed in map of fields, and returns it at the end.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field which\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * Object type returned by that field.\n */\n\n\nexport function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  for (var _i6 = 0, _selectionSet$selecti2 = selectionSet.selections; _i6 < _selectionSet$selecti2.length; _i6++) {\n    var selection = _selectionSet$selecti2[_i6];\n\n    switch (selection.kind) {\n      case Kind.FIELD:\n        {\n          if (!shouldIncludeNode(exeContext, selection)) {\n            continue;\n          }\n\n          var name = getFieldEntryKey(selection);\n\n          if (!fields[name]) {\n            fields[name] = [];\n          }\n\n          fields[name].push(selection);\n          break;\n        }\n\n      case Kind.INLINE_FRAGMENT:\n        {\n          if (!shouldIncludeNode(exeContext, selection) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {\n            continue;\n          }\n\n          collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n\n      case Kind.FRAGMENT_SPREAD:\n        {\n          var fragName = selection.name.value;\n\n          if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection)) {\n            continue;\n          }\n\n          visitedFragmentNames[fragName] = true;\n          var fragment = exeContext.fragments[fragName];\n\n          if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {\n            continue;\n          }\n\n          collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n    }\n  }\n\n  return fields;\n}\n/**\n * Determines if a field should be included based on the @include and @skip\n * directives, where @skip has higher precedence than @include.\n */\n\nfunction shouldIncludeNode(exeContext, node) {\n  var skip = getDirectiveValues(GraphQLSkipDirective, node, exeContext.variableValues);\n\n  if (skip && skip.if === true) {\n    return false;\n  }\n\n  var include = getDirectiveValues(GraphQLIncludeDirective, node, exeContext.variableValues);\n\n  if (include && include.if === false) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\n\nfunction doesFragmentConditionMatch(exeContext, fragment, type) {\n  var typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  var conditionalType = typeFromAST(exeContext.schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    return exeContext.schema.isPossibleType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n/**\n * Resolves the field on the given source object. In particular, this\n * figures out the value that the field returns by calling its resolve function,\n * then calls completeValue to complete promises, serialize scalars, or execute\n * the sub-selection-set for objects.\n */\n\n\nfunction resolveField(exeContext, parentType, source, fieldNodes, path) {\n  var fieldNode = fieldNodes[0];\n  var fieldName = fieldNode.name.value;\n  var fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);\n\n  if (!fieldDef) {\n    return;\n  }\n\n  var resolveFn = fieldDef.resolve || exeContext.fieldResolver;\n  var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path); // Get the resolve function, regardless of if its result is normal\n  // or abrupt (error).\n\n  var result = resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, source, info);\n  return completeValueCatchingError(exeContext, fieldDef.type, fieldNodes, info, path, result);\n}\n\nexport function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes: fieldNodes,\n    returnType: fieldDef.type,\n    parentType: parentType,\n    path: path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues\n  };\n} // Isolates the \"ReturnOrAbrupt\" behavior to not de-opt the `resolveField`\n// function. Returns the result of resolveFn or the abrupt-return Error object.\n\nexport function resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, source, info) {\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    var args = getArgumentValues(fieldDef, fieldNodes[0], exeContext.variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    var _contextValue = exeContext.contextValue;\n    var result = resolveFn(source, args, _contextValue, info);\n    return isPromise(result) ? result.then(undefined, asErrorInstance) : result;\n  } catch (error) {\n    return asErrorInstance(error);\n  }\n} // Sometimes a non-error is thrown, wrap it as an Error instance to ensure a\n// consistent Error interface.\n\nfunction asErrorInstance(error) {\n  if (error instanceof Error) {\n    return error;\n  }\n\n  return new Error('Unexpected error value: ' + inspect(error));\n} // This is a small wrapper around completeValue which detects and logs errors\n// in the execution context.\n\n\nfunction completeValueCatchingError(exeContext, returnType, fieldNodes, info, path, result) {\n  try {\n    var completed;\n\n    if (isPromise(result)) {\n      completed = result.then(function (resolved) {\n        return completeValue(exeContext, returnType, fieldNodes, info, path, resolved);\n      });\n    } else {\n      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);\n    }\n\n    if (isPromise(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, function (error) {\n        return handleFieldError(error, fieldNodes, path, returnType, exeContext);\n      });\n    }\n\n    return completed;\n  } catch (error) {\n    return handleFieldError(error, fieldNodes, path, returnType, exeContext);\n  }\n}\n\nfunction handleFieldError(rawError, fieldNodes, path, returnType, exeContext) {\n  var error = locatedError(asErrorInstance(rawError), fieldNodes, pathToArray(path)); // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n\n  if (isNonNullType(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Field entries\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by evaluating all sub-selections.\n */\n\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n\n  if (isNonNullType(returnType)) {\n    var completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);\n\n    if (completed === null) {\n      throw new Error(\"Cannot return null for non-nullable field \".concat(info.parentType.name, \".\").concat(info.fieldName, \".\"));\n    }\n\n    return completed;\n  } // If result value is null-ish (null, undefined, or NaN) then return null.\n\n\n  if (isNullish(result)) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n\n  if (isListType(returnType)) {\n    return completeListValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n\n  if (isLeafType(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n\n  if (isAbstractType(returnType)) {\n    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // If field type is Object, execute and complete all sub-selections.\n\n\n  /* istanbul ignore else */\n  if (isObjectType(returnType)) {\n    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // Not reachable. All possible output types have been considered.\n\n\n  /* istanbul ignore next */\n  invariant(false, 'Cannot complete value of unexpected output type: ' + inspect(returnType));\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\n\n\nfunction completeListValue(exeContext, returnType, fieldNodes, info, path, result) {\n  if (!isCollection(result)) {\n    throw new GraphQLError(\"Expected Iterable, but did not find one for field \".concat(info.parentType.name, \".\").concat(info.fieldName, \".\"));\n  } // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n\n\n  var itemType = returnType.ofType;\n  var containsPromise = false;\n  var completedResults = [];\n  forEach(result, function (item, index) {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    var fieldPath = addPath(path, index);\n    var completedItem = completeValueCatchingError(exeContext, itemType, fieldNodes, info, fieldPath, item);\n\n    if (!containsPromise && isPromise(completedItem)) {\n      containsPromise = true;\n    }\n\n    completedResults.push(completedItem);\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\n\n\nfunction completeLeafValue(returnType, result) {\n  var serializedResult = returnType.serialize(result);\n\n  if (isInvalid(serializedResult)) {\n    throw new Error(\"Expected a value of type \\\"\".concat(inspect(returnType), \"\\\" but \") + \"received: \".concat(inspect(result)));\n  }\n\n  return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\n\n\nfunction completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {\n  var resolveTypeFn = returnType.resolveType || exeContext.typeResolver;\n  var contextValue = exeContext.contextValue;\n  var runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n\n  if (isPromise(runtimeType)) {\n    return runtimeType.then(function (resolvedRuntimeType) {\n      return completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);\n    });\n  }\n\n  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);\n}\n\nfunction ensureValidRuntimeType(runtimeTypeOrName, exeContext, returnType, fieldNodes, info, result) {\n  var runtimeType = typeof runtimeTypeOrName === 'string' ? exeContext.schema.getType(runtimeTypeOrName) : runtimeTypeOrName;\n\n  if (!isObjectType(runtimeType)) {\n    throw new GraphQLError(\"Abstract type \".concat(returnType.name, \" must resolve to an Object type at runtime for field \").concat(info.parentType.name, \".\").concat(info.fieldName, \" with \") + \"value \".concat(inspect(result), \", received \\\"\").concat(inspect(runtimeType), \"\\\". \") + \"Either the \".concat(returnType.name, \" type should provide a \\\"resolveType\\\" function or each possible type should provide an \\\"isTypeOf\\\" function.\"), fieldNodes);\n  }\n\n  if (!exeContext.schema.isPossibleType(returnType, runtimeType)) {\n    throw new GraphQLError(\"Runtime Object type \\\"\".concat(runtimeType.name, \"\\\" is not a possible type for \\\"\").concat(returnType.name, \"\\\".\"), fieldNodes);\n  }\n\n  return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\n\n\nfunction completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n  if (returnType.isTypeOf) {\n    var isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n\n    if (isPromise(isTypeOf)) {\n      return isTypeOf.then(function (resolvedIsTypeOf) {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n\n        return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n\n  return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);\n}\n\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new GraphQLError(\"Expected value of type \\\"\".concat(returnType.name, \"\\\" but got: \").concat(inspect(result), \".\"), fieldNodes);\n}\n\nfunction collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result) {\n  // Collect sub-fields to execute to complete this value.\n  var subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\n\n\nvar collectSubfields = memoize3(_collectSubfields);\n\nfunction _collectSubfields(exeContext, returnType, fieldNodes) {\n  var subFieldNodes = Object.create(null);\n  var visitedFragmentNames = Object.create(null);\n\n  for (var _i8 = 0; _i8 < fieldNodes.length; _i8++) {\n    var node = fieldNodes[_i8];\n\n    if (node.selectionSet) {\n      subFieldNodes = collectFields(exeContext, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);\n    }\n  }\n\n  return subFieldNodes;\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\n\n\nexport var defaultTypeResolver = function defaultTypeResolver(value, contextValue, info, abstractType) {\n  // First, look for `__typename`.\n  if (isObjectLike(value) && typeof value.__typename === 'string') {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n\n  var possibleTypes = info.schema.getPossibleTypes(abstractType);\n  var promisedIsTypeOfResults = [];\n\n  for (var i = 0; i < possibleTypes.length; i++) {\n    var type = possibleTypes[i];\n\n    if (type.isTypeOf) {\n      var isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if (isPromise(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        return type;\n      }\n    }\n  }\n\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then(function (isTypeOfResults) {\n      for (var _i9 = 0; _i9 < isTypeOfResults.length; _i9++) {\n        if (isTypeOfResults[_i9]) {\n          return possibleTypes[_i9];\n        }\n      }\n    });\n  }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\n\nexport var defaultFieldResolver = function defaultFieldResolver(source, args, contextValue, info) {\n  // ensure source is a value for which property access is acceptable.\n  if (isObjectLike(source) || typeof source === 'function') {\n    var property = source[info.fieldName];\n\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n\n    return property;\n  }\n};\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the two introspection fields, __schema\n * and __typename. __typename is special because it can always be\n * queried as a field, even in situations where no other fields\n * are allowed, like on a Union. __schema could get automatically\n * added to the query type, but that would require mutating type\n * definitions, which would cause issues.\n */\n\nexport function getFieldDef(schema, parentType, fieldName) {\n  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  } else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  } else if (fieldName === TypeNameMetaFieldDef.name) {\n    return TypeNameMetaFieldDef;\n  }\n\n  return parentType.getFields()[fieldName];\n}\n","import { GraphQLSchema } from 'graphql';\n\nimport { SubschemaConfig } from '../Interfaces';\n\nimport { FIELD_SUBSCHEMA_MAP_SYMBOL, OBJECT_SUBSCHEMA_SYMBOL } from './symbols';\n\nexport function getSubschema(\n  result: any,\n  responseKey: string,\n): GraphQLSchema | SubschemaConfig {\n  const subschema =\n    result[FIELD_SUBSCHEMA_MAP_SYMBOL] &&\n    result[FIELD_SUBSCHEMA_MAP_SYMBOL][responseKey];\n  return subschema ? subschema : result[OBJECT_SUBSCHEMA_SYMBOL];\n}\n\nexport function setObjectSubschema(\n  result: any,\n  subschema: GraphQLSchema | SubschemaConfig,\n) {\n  result[OBJECT_SUBSCHEMA_SYMBOL] = subschema;\n}\n","export default function resolveFromParentTypename(parent: any) {\n  const parentTypename: string = parent['__typename'];\n  if (!parentTypename) {\n    throw new Error(\n      'Did not fetch typename for object, unable to resolve interface.',\n    );\n  }\n\n  return parentTypename;\n}\n","import {\n  versionInfo,\n  getOperationRootType,\n  lexicographicSortSchema,\n  printError,\n} from 'graphql';\n\nlet version: number;\n\nif (versionInfo != null && versionInfo.major >= 15) {\n  version = 15;\n} else if (getOperationRootType != null) {\n  version = 14;\n} else if (lexicographicSortSchema != null) {\n  version = 13;\n} else if (printError != null) {\n  version = 12;\n} else {\n  version = 11;\n}\n\nexport function graphqlVersion() {\n  return version;\n}\n","// graphql <v14.2 does not support toConfig\n\nimport {\n  GraphQLSchema,\n  GraphQLFieldMap,\n  GraphQLArgument,\n  GraphQLFieldConfigArgumentMap,\n  GraphQLObjectType,\n  GraphQLObjectTypeConfig,\n  GraphQLFieldConfigMap,\n  GraphQLInputFieldConfigMap,\n  GraphQLInterfaceType,\n  GraphQLInterfaceTypeConfig,\n  GraphQLUnionType,\n  GraphQLUnionTypeConfig,\n  GraphQLEnumType,\n  GraphQLEnumTypeConfig,\n  GraphQLScalarType,\n  GraphQLScalarTypeConfig,\n  GraphQLInputObjectType,\n  GraphQLInputObjectTypeConfig,\n  GraphQLDirective,\n  GraphQLDirectiveConfig,\n  GraphQLSchemaConfig,\n  GraphQLNamedType,\n  GraphQLField,\n  GraphQLInputField,\n  GraphQLInputFieldConfig,\n  GraphQLInputFieldMap,\n  GraphQLArgumentConfig,\n  GraphQLFieldConfig,\n  isObjectType,\n  isInterfaceType,\n  isUnionType,\n  isEnumType,\n  isScalarType,\n  isInputObjectType,\n  isSchema,\n  isDirective,\n  isNamedType,\n} from 'graphql';\n\nimport { graphqlVersion } from '../utils/graphqlVersion';\n\nexport function schemaToConfig(schema: GraphQLSchema): GraphQLSchemaConfig {\n  if (schema.toConfig != null) {\n    return schema.toConfig();\n  }\n\n  const newTypes: Array<GraphQLNamedType> = [];\n\n  const types = schema.getTypeMap();\n  Object.keys(types).forEach((typeName) => {\n    newTypes.push(types[typeName]);\n  });\n\n  const schemaConfig = {\n    query: schema.getQueryType(),\n    mutation: schema.getMutationType(),\n    subscription: schema.getSubscriptionType(),\n    types: newTypes,\n    directives: schema.getDirectives().slice(),\n    extensions: schema.extensions,\n    astNode: schema.astNode,\n    extensionASTNodes:\n      schema.extensionASTNodes != null ? schema.extensionASTNodes : [],\n    assumeValid:\n      (schema as { __validationErrors?: boolean }).__validationErrors !==\n      undefined,\n  };\n\n  if (graphqlVersion() >= 15) {\n    (schemaConfig as {\n      description?: string;\n    }).description = (schema as {\n      description?: string;\n    }).description;\n  }\n\n  return schemaConfig;\n}\n\nexport function toConfig(graphqlObject: GraphQLSchema): GraphQLSchemaConfig;\nexport function toConfig(\n  graphqlObject: GraphQLObjectTypeConfig<any, any> & {\n    interfaces: Array<GraphQLInterfaceType>;\n    fields: GraphQLFieldConfigMap<any, any>;\n  },\n): GraphQLObjectTypeConfig<any, any>;\nexport function toConfig(\n  graphqlObject: GraphQLInterfaceType,\n): GraphQLInterfaceTypeConfig<any, any> & {\n  fields: GraphQLFieldConfigMap<any, any>;\n};\nexport function toConfig(\n  graphqlObject: GraphQLUnionType,\n): GraphQLUnionTypeConfig<any, any> & {\n  types: Array<GraphQLObjectType>;\n};\nexport function toConfig(graphqlObject: GraphQLEnumType): GraphQLEnumTypeConfig;\nexport function toConfig(\n  graphqlObject: GraphQLScalarType,\n): GraphQLScalarTypeConfig<any, any>;\nexport function toConfig(\n  graphqlObject: GraphQLInputObjectType,\n): GraphQLInputObjectTypeConfig & {\n  fields: GraphQLInputFieldConfigMap;\n};\nexport function toConfig(\n  graphqlObject: GraphQLDirective,\n): GraphQLDirectiveConfig;\nexport function toConfig(\n  graphqlObject: GraphQLInputField,\n): GraphQLInputFieldConfig;\nexport function toConfig(\n  graphqlObject: GraphQLField<any, any>,\n): GraphQLFieldConfig<any, any>;\nexport function toConfig(graphqlObject: any): any;\nexport function toConfig(graphqlObject: any) {\n  if (isSchema(graphqlObject)) {\n    return schemaToConfig(graphqlObject);\n  } else if (isDirective(graphqlObject)) {\n    return directiveToConfig(graphqlObject);\n  } else if (isNamedType(graphqlObject)) {\n    return typeToConfig(graphqlObject);\n  }\n\n  // Input and output fields do not have predicates defined, but using duck typing,\n  // type is defined for input and output fields\n  if (graphqlObject.type != null) {\n    if (\n      graphqlObject.args != null ||\n      graphqlObject.resolve != null ||\n      graphqlObject.subscribe != null\n    ) {\n      return fieldToConfig(graphqlObject);\n    } else if (graphqlObject.defaultValue !== undefined) {\n      return inputFieldToConfig(graphqlObject);\n    }\n\n    // Not all input and output fields can be checked by above in older versions\n    // of graphql, but almost all properties on the field and config are identical.\n    // In particular, just name and isDeprecated should be removed.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { name, isDeprecated, ...rest } = graphqlObject;\n    return {\n      ...rest,\n    };\n  }\n\n  throw new Error(`Unknown graphql object ${graphqlObject as string}`);\n}\n\nexport function typeToConfig(\n  type: GraphQLObjectType,\n): GraphQLObjectTypeConfig<any, any>;\nexport function typeToConfig(\n  type: GraphQLInterfaceType,\n): GraphQLInterfaceTypeConfig<any, any>;\nexport function typeToConfig(\n  type: GraphQLUnionType,\n): GraphQLUnionTypeConfig<any, any>;\nexport function typeToConfig(type: GraphQLEnumType): GraphQLEnumTypeConfig;\nexport function typeToConfig(\n  type: GraphQLScalarType,\n): GraphQLScalarTypeConfig<any, any>;\nexport function typeToConfig(\n  type: GraphQLInputObjectType,\n): GraphQLInputObjectTypeConfig;\nexport function typeToConfig(type: any): any;\nexport function typeToConfig(type: any) {\n  if (isObjectType(type)) {\n    return objectTypeToConfig(type);\n  } else if (isInterfaceType(type)) {\n    return interfaceTypeToConfig(type);\n  } else if (isUnionType(type)) {\n    return unionTypeToConfig(type);\n  } else if (isEnumType(type)) {\n    return enumTypeToConfig(type);\n  } else if (isScalarType(type)) {\n    return scalarTypeToConfig(type);\n  } else if (isInputObjectType(type)) {\n    return inputObjectTypeToConfig(type);\n  }\n\n  throw new Error(`Unknown type ${type as string}`);\n}\n\nexport function objectTypeToConfig(\n  type: GraphQLObjectType,\n): GraphQLObjectTypeConfig<any, any> {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  const typeConfig = {\n    name: type.name,\n    description: type.description,\n    interfaces: type.getInterfaces(),\n    fields: fieldMapToConfig(type.getFields()),\n    isTypeOf: type.isTypeOf,\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes:\n      type.extensionASTNodes != null ? type.extensionASTNodes : [],\n  };\n\n  return typeConfig;\n}\n\nexport function interfaceTypeToConfig(\n  type: GraphQLInterfaceType,\n): GraphQLInterfaceTypeConfig<any, any> {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  const typeConfig = {\n    name: type.name,\n    description: type.description,\n    fields: fieldMapToConfig(type.getFields()),\n    resolveType: type.resolveType,\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes:\n      type.extensionASTNodes != null ? type.extensionASTNodes : [],\n  };\n\n  if (graphqlVersion() >= 15) {\n    ((typeConfig as unknown) as GraphQLObjectTypeConfig<\n      any,\n      any\n    >).interfaces = ((type as unknown) as GraphQLObjectType).getInterfaces();\n  }\n\n  return typeConfig;\n}\n\nexport function unionTypeToConfig(\n  type: GraphQLUnionType,\n): GraphQLUnionTypeConfig<any, any> {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  const typeConfig = {\n    name: type.name,\n    description: type.description,\n    types: type.getTypes(),\n    resolveType: type.resolveType,\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes:\n      type.extensionASTNodes != null ? type.extensionASTNodes : [],\n  };\n\n  return typeConfig;\n}\n\nexport function enumTypeToConfig(type: GraphQLEnumType): GraphQLEnumTypeConfig {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  const newValues = {};\n\n  type.getValues().forEach((value) => {\n    newValues[value.name] = {\n      description: value.description,\n      value: value.value,\n      deprecationReason: value.deprecationReason,\n      extensions: value.extensions,\n      astNode: value.astNode,\n    };\n  });\n\n  const typeConfig = {\n    name: type.name,\n    description: type.description,\n    values: newValues,\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes:\n      type.extensionASTNodes != null ? type.extensionASTNodes : [],\n  };\n\n  return typeConfig;\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport function scalarTypeToConfig(\n  type: GraphQLScalarType,\n): GraphQLScalarTypeConfig<any, any> {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  const typeConfig = {\n    name: type.name,\n    description: type.description,\n    serialize:\n      graphqlVersion() >= 14 || hasOwn.call(type, 'serialize')\n        ? type.serialize\n        : ((type as unknown) as {\n            _scalarConfig: GraphQLScalarTypeConfig<any, any>;\n          })._scalarConfig.serialize,\n    parseValue:\n      graphqlVersion() >= 14 || hasOwn.call(type, 'parseValue')\n        ? type.parseValue\n        : ((type as unknown) as {\n            _scalarConfig: GraphQLScalarTypeConfig<any, any>;\n          })._scalarConfig.parseValue,\n    parseLiteral:\n      graphqlVersion() >= 14 || hasOwn.call(type, 'parseLiteral')\n        ? type.parseLiteral\n        : ((type as unknown) as {\n            _scalarConfig: GraphQLScalarTypeConfig<any, any>;\n          })._scalarConfig.parseLiteral,\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes:\n      type.extensionASTNodes != null ? type.extensionASTNodes : [],\n  };\n\n  return typeConfig;\n}\n\nexport function inputObjectTypeToConfig(\n  type: GraphQLInputObjectType,\n): GraphQLInputObjectTypeConfig {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  const typeConfig = {\n    name: type.name,\n    description: type.description,\n    fields: inputFieldMapToConfig(type.getFields()),\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes:\n      type.extensionASTNodes != null ? type.extensionASTNodes : [],\n  };\n\n  return typeConfig;\n}\n\nexport function inputFieldMapToConfig(\n  fields: GraphQLInputFieldMap,\n): GraphQLInputFieldConfigMap {\n  const newFields = {};\n  Object.keys(fields).forEach((fieldName) => {\n    const field = fields[fieldName];\n    newFields[fieldName] = toConfig(field);\n  });\n\n  return newFields;\n}\n\nexport function inputFieldToConfig(\n  field: GraphQLInputField,\n): GraphQLInputFieldConfig {\n  return {\n    description: field.description,\n    type: field.type,\n    defaultValue: field.defaultValue,\n    extensions: field.extensions,\n    astNode: field.astNode,\n  };\n}\n\nexport function directiveToConfig(\n  directive: GraphQLDirective,\n): GraphQLDirectiveConfig {\n  if (directive.toConfig != null) {\n    return directive.toConfig();\n  }\n\n  const directiveConfig = {\n    name: directive.name,\n    description: directive.description,\n    locations: directive.locations,\n    args: argumentMapToConfig(directive.args),\n    isRepeatable: ((directive as unknown) as { isRepeatable: boolean })\n      .isRepeatable,\n    extensions: directive.extensions,\n    astNode: directive.astNode,\n  };\n\n  return directiveConfig;\n}\n\nexport function fieldMapToConfig(\n  fields: GraphQLFieldMap<any, any>,\n): GraphQLFieldConfigMap<any, any> {\n  const newFields = {};\n\n  Object.keys(fields).forEach((fieldName) => {\n    const field = fields[fieldName];\n    newFields[fieldName] = toConfig(field);\n  });\n\n  return newFields;\n}\n\nexport function fieldToConfig(\n  field: GraphQLField<any, any>,\n): GraphQLFieldConfig<any, any> {\n  return {\n    description: field.description,\n    type: field.type,\n    args: argumentMapToConfig(field.args),\n    resolve: field.resolve,\n    subscribe: field.subscribe,\n    deprecationReason: field.deprecationReason,\n    extensions: field.extensions,\n    astNode: field.astNode,\n  };\n}\n\nexport function argumentMapToConfig(\n  args: ReadonlyArray<GraphQLArgument>,\n): GraphQLFieldConfigArgumentMap {\n  const newArguments = {};\n  args.forEach((arg) => {\n    newArguments[arg.name] = argumentToConfig(arg);\n  });\n\n  return newArguments;\n}\n\nexport function argumentToConfig(arg: GraphQLArgument): GraphQLArgumentConfig {\n  return {\n    description: arg.description,\n    type: arg.type,\n    defaultValue: arg.defaultValue,\n    extensions: arg.extensions,\n    astNode: arg.astNode,\n  };\n}\n","import {\n  GraphQLString,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID,\n  GraphQLScalarType,\n  isNamedType,\n} from 'graphql';\n\n// FIXME: Replace with https://github.com/graphql/graphql-js/blob/master/src/type/scalars.js#L139\n// Blocked by https://github.com/graphql/graphql-js/issues/2153\n\nexport const specifiedScalarTypes: Array<GraphQLScalarType> = [\n  GraphQLString,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID,\n];\n\nexport function isSpecifiedScalarType(type: any): boolean {\n  return (\n    isNamedType(type) &&\n    // Would prefer to use specifiedScalarTypes.some(), however %checks needs\n    // a simple expression.\n    (type.name === GraphQLString.name ||\n      type.name === GraphQLInt.name ||\n      type.name === GraphQLFloat.name ||\n      type.name === GraphQLBoolean.name ||\n      type.name === GraphQLID.name)\n  );\n}\n","import {\n  GraphQLDirective,\n  GraphQLEnumType,\n  GraphQLFieldConfigArgumentMap,\n  GraphQLFieldConfigMap,\n  GraphQLInputFieldConfigMap,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLObjectType,\n  GraphQLNamedType,\n  GraphQLNonNull,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLType,\n  GraphQLUnionType,\n  isDirective,\n  isInterfaceType,\n  isEnumType,\n  isInputType,\n  isInputObjectType,\n  isListType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n  GraphQLObjectTypeConfig,\n} from 'graphql';\n\nimport { toConfig } from '../polyfills/toConfig';\nimport { isSpecifiedScalarType } from '../polyfills/isSpecifiedScalarType';\nimport { graphqlVersion } from '../utils/graphqlVersion';\nimport {\n  SchemaMapper,\n  MapperKind,\n  NamedTypeMapper,\n  DirectiveMapper,\n} from '../Interfaces';\n\nexport function mapSchema(\n  schema: GraphQLSchema,\n  schemaMapper: SchemaMapper = {},\n): GraphQLSchema {\n  const originalTypeMap = schema.getTypeMap();\n  const newTypeMap = {};\n  Object.keys(originalTypeMap).forEach((typeName) => {\n    if (!typeName.startsWith('__')) {\n      const typeMapper = getMapper(\n        schema,\n        schemaMapper,\n        originalTypeMap[typeName],\n      );\n\n      if (typeMapper != null) {\n        const newType = typeMapper(originalTypeMap[typeName], schema);\n        newTypeMap[typeName] =\n          newType !== undefined ? newType : originalTypeMap[typeName];\n      } else {\n        newTypeMap[typeName] = originalTypeMap[typeName];\n      }\n    }\n  });\n\n  const queryType = schema.getQueryType();\n  const mutationType = schema.getMutationType();\n  const subscriptionType = schema.getSubscriptionType();\n\n  const newQueryTypeName =\n    queryType != null\n      ? newTypeMap[queryType.name] != null\n        ? newTypeMap[queryType.name].name\n        : undefined\n      : undefined;\n  const newMutationTypeName =\n    mutationType != null\n      ? newTypeMap[mutationType.name] != null\n        ? newTypeMap[mutationType.name].name\n        : undefined\n      : undefined;\n  const newSubscriptionTypeName =\n    subscriptionType != null\n      ? newTypeMap[subscriptionType.name] != null\n        ? newTypeMap[subscriptionType.name].name\n        : undefined\n      : undefined;\n\n  const originalDirectives = schema.getDirectives();\n  const newDirectives: Array<GraphQLDirective> = [];\n  originalDirectives.forEach((directive) => {\n    const directiveMapper = getMapper(schema, schemaMapper, directive);\n    if (directiveMapper != null) {\n      const newDirective = directiveMapper(directive, schema);\n      if (newDirective != null) {\n        newDirectives.push(newDirective);\n      }\n    } else {\n      newDirectives.push(directive);\n    }\n  });\n\n  const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);\n\n  return new GraphQLSchema({\n    ...toConfig(schema),\n    query: newQueryTypeName\n      ? (typeMap[newQueryTypeName] as GraphQLObjectType)\n      : undefined,\n    mutation: newMutationTypeName\n      ? (typeMap[newMutationTypeName] as GraphQLObjectType)\n      : undefined,\n    subscription:\n      newSubscriptionTypeName != null\n        ? (typeMap[newSubscriptionTypeName] as GraphQLObjectType)\n        : undefined,\n    types: Object.keys(typeMap).map((typeName) => typeMap[typeName]),\n    directives,\n  });\n}\n\nfunction getTypeSpecifiers(\n  type: GraphQLType,\n  schema: GraphQLSchema,\n): Array<MapperKind> {\n  const specifiers = [MapperKind.TYPE];\n  if (isObjectType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\n    const query = schema.getQueryType();\n    const mutation = schema.getMutationType();\n    const subscription = schema.getSubscriptionType();\n    if (type === query) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\n    } else if (type === mutation) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\n    } else if (type === subscription) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\n    }\n  } else if (isInputType(type)) {\n    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\n  } else if (isInterfaceType(type)) {\n    specifiers.push(\n      MapperKind.COMPOSITE_TYPE,\n      MapperKind.ABSTRACT_TYPE,\n      MapperKind.INTERFACE_TYPE,\n    );\n  } else if (isUnionType(type)) {\n    specifiers.push(\n      MapperKind.COMPOSITE_TYPE,\n      MapperKind.ABSTRACT_TYPE,\n      MapperKind.UNION_TYPE,\n    );\n  } else if (isEnumType(type)) {\n    specifiers.push(MapperKind.ENUM_TYPE);\n  } else if (isScalarType(type)) {\n    specifiers.push(MapperKind.SCALAR_TYPE);\n  }\n\n  return specifiers;\n}\n\nfunction getMapper(\n  schema: GraphQLSchema,\n  schemaMapper: SchemaMapper,\n  typeOrDirective: GraphQLNamedType,\n): NamedTypeMapper | null;\nfunction getMapper(\n  schema: GraphQLSchema,\n  schemaMapper: SchemaMapper,\n  typeOrDirective: GraphQLDirective,\n): DirectiveMapper | null;\nfunction getMapper(\n  schema: GraphQLSchema,\n  schemaMapper: SchemaMapper,\n  typeOrDirective: any,\n): any {\n  if (isNamedType(typeOrDirective)) {\n    const specifiers = getTypeSpecifiers(typeOrDirective, schema);\n    let typeMapper: NamedTypeMapper | undefined;\n    const stack = [...specifiers];\n    while (!typeMapper && stack.length > 0) {\n      const next = stack.pop();\n      typeMapper = schemaMapper[next] as NamedTypeMapper;\n    }\n\n    return typeMapper != null ? typeMapper : null;\n  } else if (isDirective(typeOrDirective)) {\n    const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\n    return directiveMapper != null ? directiveMapper : null;\n  }\n}\n\nexport function rewireTypes(\n  originalTypeMap: Record<string, GraphQLNamedType | null>,\n  directives: ReadonlyArray<GraphQLDirective>,\n): {\n  typeMap: Record<string, GraphQLNamedType>;\n  directives: Array<GraphQLDirective>;\n} {\n  const newTypeMap: Record<string, GraphQLNamedType> = Object.create(null);\n\n  Object.keys(originalTypeMap).forEach((typeName) => {\n    const namedType = originalTypeMap[typeName];\n\n    if (namedType == null || typeName.startsWith('__')) {\n      return;\n    }\n\n    const newName = namedType.name;\n    if (newName.startsWith('__')) {\n      return;\n    }\n\n    if (newTypeMap[newName] != null) {\n      throw new Error(`Duplicate schema type name ${newName}`);\n    }\n\n    newTypeMap[newName] = namedType;\n  });\n\n  Object.keys(newTypeMap).forEach((typeName) => {\n    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n  });\n\n  const newDirectives = directives.map((directive) =>\n    rewireDirective(directive),\n  );\n\n  return pruneTypes(newTypeMap, newDirectives);\n\n  function rewireDirective(directive: GraphQLDirective): GraphQLDirective {\n    const directiveConfig = toConfig(directive);\n    directiveConfig.args = rewireArgs(directiveConfig.args);\n    return new GraphQLDirective(directiveConfig);\n  }\n\n  function rewireArgs(\n    args: GraphQLFieldConfigArgumentMap,\n  ): GraphQLFieldConfigArgumentMap {\n    const rewiredArgs = {};\n    Object.keys(args).forEach((argName) => {\n      const arg = args[argName];\n      const rewiredArgType = rewireType(arg.type);\n      if (rewiredArgType != null) {\n        arg.type = rewiredArgType;\n        rewiredArgs[argName] = arg;\n      }\n    });\n    return rewiredArgs;\n  }\n\n  function rewireNamedType<T extends GraphQLNamedType>(type: T) {\n    if (isObjectType(type)) {\n      const config = toConfig(type);\n      const newConfig = {\n        ...config,\n        fields: () => rewireFields(config.fields),\n        interfaces: () => rewireNamedTypes(config.interfaces),\n      };\n      return new GraphQLObjectType(newConfig);\n    } else if (isInterfaceType(type)) {\n      const config = toConfig(type);\n      const newConfig = {\n        ...config,\n        fields: () => rewireFields(config.fields),\n      };\n      if (graphqlVersion() >= 15) {\n        ((newConfig as unknown) as GraphQLObjectTypeConfig<\n          any,\n          any\n        >).interfaces = () =>\n          rewireNamedTypes(\n            ((config as unknown) as { interfaces: Array<GraphQLInterfaceType> })\n              .interfaces,\n          );\n      }\n      return new GraphQLInterfaceType(newConfig);\n    } else if (isUnionType(type)) {\n      const config = toConfig(type);\n      const newConfig = {\n        ...config,\n        types: () => rewireNamedTypes(config.types),\n      };\n      return new GraphQLUnionType(newConfig);\n    } else if (isInputObjectType(type)) {\n      const config = toConfig(type);\n      const newConfig = {\n        ...config,\n        fields: () => rewireInputFields(config.fields),\n      };\n      return new GraphQLInputObjectType(newConfig);\n    } else if (isEnumType(type)) {\n      const enumConfig = toConfig(type);\n      return new GraphQLEnumType(enumConfig);\n    } else if (isScalarType(type)) {\n      if (isSpecifiedScalarType(type)) {\n        return type;\n      }\n      const scalarConfig = toConfig(type);\n      return new GraphQLScalarType(scalarConfig);\n    }\n\n    throw new Error(`Unexpected schema type: ${(type as unknown) as string}`);\n  }\n\n  function rewireFields(\n    fields: GraphQLFieldConfigMap<any, any>,\n  ): GraphQLFieldConfigMap<any, any> {\n    const rewiredFields = {};\n    Object.keys(fields).forEach((fieldName) => {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n      if (rewiredFieldType != null) {\n        field.type = rewiredFieldType;\n        field.args = rewireArgs(field.args);\n        rewiredFields[fieldName] = field;\n      }\n    });\n    return rewiredFields;\n  }\n\n  function rewireInputFields(\n    fields: GraphQLInputFieldConfigMap,\n  ): GraphQLInputFieldConfigMap {\n    const rewiredFields = {};\n    Object.keys(fields).forEach((fieldName) => {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n      if (rewiredFieldType != null) {\n        field.type = rewiredFieldType;\n        rewiredFields[fieldName] = field;\n      }\n    });\n    return rewiredFields;\n  }\n\n  function rewireNamedTypes<T extends GraphQLNamedType>(namedTypes: Array<T>) {\n    const rewiredTypes: Array<T> = [];\n    namedTypes.forEach((namedType) => {\n      const rewiredType = rewireType(namedType);\n      if (rewiredType != null) {\n        rewiredTypes.push(rewiredType);\n      }\n    });\n    return rewiredTypes;\n  }\n\n  function rewireType<T extends GraphQLType>(type: T): T | null {\n    if (isListType(type)) {\n      const rewiredType = rewireType(type.ofType);\n      return rewiredType != null ? (new GraphQLList(rewiredType) as T) : null;\n    } else if (isNonNullType(type)) {\n      const rewiredType = rewireType(type.ofType);\n      return rewiredType != null\n        ? (new GraphQLNonNull(rewiredType) as T)\n        : null;\n    } else if (isNamedType(type)) {\n      const originalType = originalTypeMap[type.name];\n      return originalType != null ? (newTypeMap[originalType.name] as T) : null;\n    }\n\n    return null;\n  }\n}\n\nfunction pruneTypes(\n  typeMap: Record<string, GraphQLNamedType>,\n  directives: Array<GraphQLDirective>,\n): {\n  typeMap: Record<string, GraphQLNamedType>;\n  directives: Array<GraphQLDirective>;\n} {\n  const newTypeMap = {};\n\n  const implementedInterfaces = {};\n  Object.keys(typeMap).forEach((typeName) => {\n    const namedType = typeMap[typeName];\n\n    if (\n      isObjectType(namedType) ||\n      (graphqlVersion() >= 15 && isInterfaceType(namedType))\n    ) {\n      (namedType as GraphQLObjectType).getInterfaces().forEach((iface) => {\n        implementedInterfaces[iface.name] = true;\n      });\n    }\n  });\n\n  let prunedTypeMap = false;\n  const typeNames = Object.keys(typeMap);\n  for (let i = 0; i < typeNames.length; i++) {\n    const typeName = typeNames[i];\n    const type = typeMap[typeName];\n    if (isObjectType(type) || isInputObjectType(type)) {\n      // prune types with no fields\n      if (Object.keys(type.getFields()).length) {\n        newTypeMap[typeName] = type;\n      } else {\n        prunedTypeMap = true;\n      }\n    } else if (isUnionType(type)) {\n      // prune unions without underlying types\n      if (type.getTypes().length) {\n        newTypeMap[typeName] = type;\n      } else {\n        prunedTypeMap = true;\n      }\n    } else if (isInterfaceType(type)) {\n      // prune interfaces without fields or without implementations\n      if (\n        Object.keys(type.getFields()).length &&\n        implementedInterfaces[type.name]\n      ) {\n        newTypeMap[typeName] = type;\n      } else {\n        prunedTypeMap = true;\n      }\n    } else {\n      newTypeMap[typeName] = type;\n    }\n  }\n\n  // every prune requires another round of healing\n  return prunedTypeMap\n    ? rewireTypes(newTypeMap, directives)\n    : { typeMap, directives };\n}\n","import {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  GraphQLType,\n} from 'graphql';\n\nimport {\n  GraphQLSchemaWithTransforms,\n  MapperKind,\n  FieldFilter,\n  RootFieldFilter,\n} from '../Interfaces';\nimport { toConfig } from '../polyfills/toConfig';\n\nimport { mapSchema } from './map';\n\nexport default function filterSchema({\n  schema,\n  rootFieldFilter = () => true,\n  typeFilter = () => true,\n  fieldFilter = () => true,\n}: {\n  schema: GraphQLSchemaWithTransforms;\n  rootFieldFilter?: RootFieldFilter;\n  typeFilter?: (typeName: string, type: GraphQLType) => boolean;\n  fieldFilter?: (typeName: string, fieldName: string) => boolean;\n}): GraphQLSchemaWithTransforms {\n  const filteredSchema: GraphQLSchemaWithTransforms = mapSchema(schema, {\n    [MapperKind.QUERY]: (type: GraphQLObjectType) =>\n      filterRootFields(type, 'Query', rootFieldFilter),\n    [MapperKind.MUTATION]: (type: GraphQLObjectType) =>\n      filterRootFields(type, 'Mutation', rootFieldFilter),\n    [MapperKind.SUBSCRIPTION]: (type: GraphQLObjectType) =>\n      filterRootFields(type, 'Subscription', rootFieldFilter),\n    [MapperKind.OBJECT_TYPE]: (type: GraphQLObjectType) =>\n      typeFilter(type.name, type)\n        ? filterObjectFields(type, fieldFilter)\n        : null,\n    [MapperKind.INTERFACE_TYPE]: (type: GraphQLInterfaceType) =>\n      typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.UNION_TYPE]: (type: GraphQLUnionType) =>\n      typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.INPUT_OBJECT_TYPE]: (type: GraphQLInputObjectType) =>\n      typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.ENUM_TYPE]: (type: GraphQLEnumType) =>\n      typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.SCALAR_TYPE]: (type: GraphQLScalarType) =>\n      typeFilter(type.name, type) ? undefined : null,\n  });\n\n  filteredSchema.transforms = schema.transforms;\n\n  return filteredSchema;\n}\n\nfunction filterRootFields(\n  type: GraphQLObjectType,\n  operation: 'Query' | 'Mutation' | 'Subscription',\n  rootFieldFilter: RootFieldFilter,\n): GraphQLObjectType {\n  const config = toConfig(type);\n  Object.keys(config.fields).forEach((fieldName) => {\n    if (!rootFieldFilter(operation, fieldName, config.fields[fieldName])) {\n      delete config.fields[fieldName];\n    }\n  });\n  return new GraphQLObjectType(config);\n}\n\nfunction filterObjectFields(\n  type: GraphQLObjectType,\n  fieldFilter: FieldFilter,\n): GraphQLObjectType {\n  const config = toConfig(type);\n  Object.keys(config.fields).forEach((fieldName) => {\n    if (!fieldFilter(type.name, fieldName, config.fields[fieldName])) {\n      delete config.fields[fieldName];\n    }\n  });\n  return new GraphQLObjectType(config);\n}\n","import {\n  GraphQLDirective,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLObjectTypeConfig,\n  GraphQLNamedType,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLUnionType,\n  isObjectType,\n  isInterfaceType,\n  isUnionType,\n  isInputObjectType,\n  isEnumType,\n  isScalarType,\n} from 'graphql';\n\nimport { isSpecifiedScalarType } from '../polyfills/isSpecifiedScalarType';\nimport { toConfig } from '../polyfills/toConfig';\n\nimport { graphqlVersion } from './graphqlVersion';\nimport { mapSchema } from './map';\n\nexport function cloneDirective(directive: GraphQLDirective): GraphQLDirective {\n  return new GraphQLDirective(toConfig(directive));\n}\n\nexport function cloneType(type: GraphQLNamedType): GraphQLNamedType {\n  if (isObjectType(type)) {\n    const config = toConfig(type);\n    return new GraphQLObjectType({\n      ...config,\n      interfaces:\n        typeof config.interfaces === 'function'\n          ? config.interfaces\n          : config.interfaces.slice(),\n    });\n  } else if (isInterfaceType(type)) {\n    const config = toConfig(type);\n    const newConfig = {\n      ...config,\n      interfaces:\n        graphqlVersion() >= 15\n          ? typeof ((config as unknown) as GraphQLObjectTypeConfig<any, any>)\n              .interfaces === 'function'\n            ? ((config as unknown) as GraphQLObjectTypeConfig<any, any>)\n                .interfaces\n            : ((config as unknown) as {\n                interfaces: Array<GraphQLInterfaceType>;\n              }).interfaces.slice()\n          : undefined,\n    };\n    return new GraphQLInterfaceType(newConfig);\n  } else if (isUnionType(type)) {\n    const config = toConfig(type);\n    return new GraphQLUnionType({\n      ...config,\n      types: config.types.slice(),\n    });\n  } else if (isInputObjectType(type)) {\n    return new GraphQLInputObjectType(toConfig(type));\n  } else if (isEnumType(type)) {\n    return new GraphQLEnumType(toConfig(type));\n  } else if (isScalarType(type)) {\n    return isSpecifiedScalarType(type)\n      ? type\n      : new GraphQLScalarType(toConfig(type));\n  }\n\n  throw new Error(`Invalid type ${type as string}`);\n}\n\nexport function cloneSchema(schema: GraphQLSchema): GraphQLSchema {\n  return mapSchema(schema);\n}\n","import { Source, buildASTSchema, parse, BuildSchemaOptions } from 'graphql';\n\n// polyfill for graphql prior to v13 which do not pass options to buildASTSchema\nexport function buildSchema(\n  ast: string | Source,\n  buildSchemaOptions: BuildSchemaOptions,\n) {\n  return buildASTSchema(parse(ast), buildSchemaOptions);\n}\n","import {\n  GraphQLSchema,\n  isScalarType,\n  isEnumType,\n  isInterfaceType,\n  isUnionType,\n  isObjectType,\n} from 'graphql';\n\nimport { IResolvers } from '../Interfaces';\nimport { isSpecifiedScalarType } from '../polyfills/isSpecifiedScalarType';\n\nimport { cloneType } from './clone';\n\nexport function getResolversFromSchema(schema: GraphQLSchema): IResolvers {\n  const resolvers = Object.create({});\n\n  const typeMap = schema.getTypeMap();\n\n  Object.keys(typeMap).forEach((typeName) => {\n    const type = typeMap[typeName];\n\n    if (isScalarType(type)) {\n      if (!isSpecifiedScalarType(type)) {\n        resolvers[typeName] = cloneType(type);\n      }\n    } else if (isEnumType(type)) {\n      resolvers[typeName] = {};\n\n      const values = type.getValues();\n      values.forEach((value) => {\n        resolvers[typeName][value.name] = value.value;\n      });\n    } else if (isInterfaceType(type)) {\n      if (type.resolveType != null) {\n        resolvers[typeName] = {\n          __resolveType: type.resolveType,\n        };\n      }\n    } else if (isUnionType(type)) {\n      if (type.resolveType != null) {\n        resolvers[typeName] = {\n          __resolveType: type.resolveType,\n        };\n      }\n    } else if (isObjectType(type)) {\n      resolvers[typeName] = {};\n\n      if (type.isTypeOf != null) {\n        resolvers[typeName].__isTypeOf = type.isTypeOf;\n      }\n\n      const fields = type.getFields();\n      Object.keys(fields).forEach((fieldName) => {\n        const field = fields[fieldName];\n\n        resolvers[typeName][fieldName] = {\n          resolve: field.resolve,\n          subscribe: field.subscribe,\n        };\n      });\n    }\n  });\n\n  return resolvers;\n}\n","import {\n  DocumentNode,\n  GraphQLSchema,\n  extendSchema as graphqlExtendSchema,\n} from 'graphql';\n\nimport { getResolversFromSchema } from '../utils/getResolversFromSchema';\nimport { IResolverOptions } from '../Interfaces';\n\n// polyfill for graphql < v14.2 which does not support subscriptions\nexport function extendSchema(\n  schema: GraphQLSchema,\n  extension: DocumentNode,\n  options: any,\n): GraphQLSchema {\n  const subscriptionType = schema.getSubscriptionType();\n  if (subscriptionType == null) {\n    return graphqlExtendSchema(schema, extension, options);\n  }\n\n  const resolvers = getResolversFromSchema(schema);\n\n  const subscriptionTypeName = subscriptionType.name;\n  const subscriptionResolvers = resolvers[\n    subscriptionTypeName\n  ] as IResolverOptions;\n\n  const extendedSchema = graphqlExtendSchema(schema, extension, options);\n\n  const fields = extendedSchema.getSubscriptionType().getFields();\n  Object.keys(subscriptionResolvers).forEach((fieldName) => {\n    fields[fieldName].subscribe = subscriptionResolvers[fieldName].subscribe;\n  });\n\n  return extendedSchema;\n}\n","import { IndexedObject } from '../Interfaces';\n\nexport default function each<V>(\n  arrayOrObject: IndexedObject<V>,\n  callback: (value: V, key: string) => void,\n) {\n  Object.keys(arrayOrObject).forEach((key) => {\n    callback(arrayOrObject[key], key);\n  });\n}\n","import { IndexedObject } from '../Interfaces';\n\n// A more powerful version of each that has the ability to replace or remove\n// array or object keys.\nexport default function updateEachKey<V>(\n  arrayOrObject: IndexedObject<V>,\n  // The callback can return nothing to leave the key untouched, null to remove\n  // the key from the array or object, or a non-null V to replace the value.\n  updater: (value: V, key: string) => void | null | V,\n) {\n  let deletedCount = 0;\n\n  Object.keys(arrayOrObject).forEach((key) => {\n    const result = updater(arrayOrObject[key], key);\n\n    if (typeof result === 'undefined') {\n      return;\n    }\n\n    if (result === null) {\n      delete arrayOrObject[key];\n      deletedCount++;\n      return;\n    }\n\n    arrayOrObject[key] = result;\n  });\n\n  if (deletedCount > 0 && Array.isArray(arrayOrObject)) {\n    // Remove any holes from the array due to deleted elements.\n    arrayOrObject.splice(0).forEach((elem) => {\n      arrayOrObject.push(elem);\n    });\n  }\n}\n","import {\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLInputObjectType,\n  GraphQLString,\n  GraphQLNamedType,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID,\n  isObjectType,\n  isInterfaceType,\n  isInputObjectType,\n} from 'graphql';\n\nexport function createNamedStub(\n  name: string,\n  type: 'object' | 'interface' | 'input',\n): GraphQLObjectType | GraphQLInputObjectType | GraphQLInterfaceType {\n  let constructor: any;\n  if (type === 'object') {\n    constructor = GraphQLObjectType;\n  } else if (type === 'interface') {\n    constructor = GraphQLInterfaceType;\n  } else {\n    constructor = GraphQLInputObjectType;\n  }\n\n  return new constructor({\n    name,\n    fields: {\n      __fake: {\n        type: GraphQLString,\n      },\n    },\n  });\n}\n\nexport function isStub(type: GraphQLNamedType): boolean {\n  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n    const fields = type.getFields();\n    const fieldNames = Object.keys(fields);\n    return fieldNames.length === 1 && fields[fieldNames[0]].name === '__fake';\n  }\n\n  return false;\n}\n\nexport function getBuiltInForStub(type: GraphQLNamedType): GraphQLNamedType {\n  switch (type.name) {\n    case GraphQLInt.name:\n      return GraphQLInt;\n    case GraphQLFloat.name:\n      return GraphQLFloat;\n    case GraphQLString.name:\n      return GraphQLString;\n    case GraphQLBoolean.name:\n      return GraphQLBoolean;\n    case GraphQLID.name:\n      return GraphQLID;\n    default:\n      return type;\n  }\n}\n","import {\n  GraphQLDirective,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLObjectType,\n  GraphQLNamedType,\n  GraphQLNonNull,\n  GraphQLType,\n  GraphQLUnionType,\n  isNamedType,\n  GraphQLSchema,\n  GraphQLInputType,\n  GraphQLOutputType,\n  isObjectType,\n  isInterfaceType,\n  isUnionType,\n  isInputObjectType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n} from 'graphql';\n\nimport { toConfig } from '../polyfills/index';\n\nimport each from './each';\nimport updateEachKey from './updateEachKey';\nimport { isStub, getBuiltInForStub } from './stub';\nimport { graphqlVersion } from './graphqlVersion';\n\ntype NamedTypeMap = {\n  [key: string]: GraphQLNamedType;\n};\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\nexport function healSchema(schema: GraphQLSchema): GraphQLSchema {\n  const typeMap = schema.getTypeMap();\n  const directives = schema.getDirectives();\n\n  const queryType = schema.getQueryType();\n  const mutationType = schema.getMutationType();\n  const subscriptionType = schema.getSubscriptionType();\n\n  const newQueryTypeName =\n    queryType != null\n      ? typeMap[queryType.name] != null\n        ? typeMap[queryType.name].name\n        : undefined\n      : undefined;\n  const newMutationTypeName =\n    mutationType != null\n      ? typeMap[mutationType.name] != null\n        ? typeMap[mutationType.name].name\n        : undefined\n      : undefined;\n  const newSubscriptionTypeName =\n    subscriptionType != null\n      ? typeMap[subscriptionType.name] != null\n        ? typeMap[subscriptionType.name].name\n        : undefined\n      : undefined;\n\n  healTypes(typeMap, directives);\n\n  const filteredTypeMap = {};\n\n  Object.keys(typeMap).forEach((typeName) => {\n    if (!typeName.startsWith('__')) {\n      filteredTypeMap[typeName] = typeMap[typeName];\n    }\n  });\n\n  const healedSchema = new GraphQLSchema({\n    ...toConfig(schema),\n    query: newQueryTypeName ? filteredTypeMap[newQueryTypeName] : undefined,\n    mutation: newMutationTypeName\n      ? filteredTypeMap[newMutationTypeName]\n      : undefined,\n    subscription: newSubscriptionTypeName\n      ? filteredTypeMap[newSubscriptionTypeName]\n      : undefined,\n    types: Object.keys(filteredTypeMap).map(\n      (typeName) => filteredTypeMap[typeName],\n    ),\n    directives: directives.slice(),\n  });\n\n  // Reconstruct the schema to reinitialize private variables\n  // e.g. the stored implementation map and the proper root types.\n  Object.assign(schema, healedSchema);\n\n  return schema;\n}\n\nexport function healTypes(\n  originalTypeMap: Record<string, GraphQLNamedType | null>,\n  directives: ReadonlyArray<GraphQLDirective>,\n  config: {\n    skipPruning: boolean;\n  } = {\n    skipPruning: false,\n  },\n) {\n  const actualNamedTypeMap: NamedTypeMap = Object.create(null);\n\n  // If any of the .name properties of the GraphQLNamedType objects in\n  // schema.getTypeMap() have changed, the keys of the type map need to\n  // be updated accordingly.\n\n  each(originalTypeMap, (namedType, typeName) => {\n    if (namedType == null || typeName.startsWith('__')) {\n      return;\n    }\n\n    const actualName = namedType.name;\n    if (actualName.startsWith('__')) {\n      return;\n    }\n\n    if (hasOwn.call(actualNamedTypeMap, actualName)) {\n      throw new Error(`Duplicate schema type name ${actualName}`);\n    }\n\n    actualNamedTypeMap[actualName] = namedType;\n\n    // Note: we are deliberately leaving namedType in the schema by its\n    // original name (which might be different from actualName), so that\n    // references by that name can be healed.\n  });\n\n  // Now add back every named type by its actual name.\n  each(actualNamedTypeMap, (namedType, typeName) => {\n    originalTypeMap[typeName] = namedType;\n  });\n\n  // Directive declaration argument types can refer to named types.\n  each(directives, (decl: GraphQLDirective) => {\n    updateEachKey(decl.args, (arg) => {\n      arg.type = healType(arg.type) as GraphQLInputType;\n      return arg.type === null ? null : arg;\n    });\n  });\n\n  each(originalTypeMap, (namedType, typeName) => {\n    // Heal all named types, except for dangling references, kept only to redirect.\n    if (\n      !typeName.startsWith('__') &&\n      hasOwn.call(actualNamedTypeMap, typeName)\n    ) {\n      if (namedType != null) {\n        healNamedType(namedType);\n      }\n    }\n  });\n\n  updateEachKey(originalTypeMap, (_namedType, typeName) => {\n    // Dangling references to renamed types should remain in the schema\n    // during healing, but must be removed now, so that the following\n    // invariant holds for all names: schema.getType(name).name === name\n    if (\n      !typeName.startsWith('__') &&\n      !hasOwn.call(actualNamedTypeMap, typeName)\n    ) {\n      return null;\n    }\n  });\n\n  if (!config.skipPruning) {\n    pruneTypes(originalTypeMap, directives);\n  }\n\n  function healNamedType(type: GraphQLNamedType) {\n    if (isObjectType(type)) {\n      healFields(type);\n      healInterfaces(type);\n      return;\n    } else if (isInterfaceType(type)) {\n      healFields(type);\n      if (graphqlVersion() >= 15) {\n        healInterfaces(type);\n      }\n      return;\n    } else if (isUnionType(type)) {\n      healUnderlyingTypes(type);\n      return;\n    } else if (isInputObjectType(type)) {\n      healInputFields(type);\n      return;\n    } else if (isLeafType(type)) {\n      return;\n    }\n\n    throw new Error(`Unexpected schema type: ${type as string}`);\n  }\n\n  function healFields(type: GraphQLObjectType | GraphQLInterfaceType) {\n    updateEachKey(type.getFields(), (field) => {\n      updateEachKey(field.args, (arg) => {\n        arg.type = healType(arg.type) as GraphQLInputType;\n        return arg.type === null ? null : arg;\n      });\n      field.type = healType(field.type) as GraphQLOutputType;\n      return field.type === null ? null : field;\n    });\n  }\n\n  function healInterfaces(type: GraphQLObjectType | GraphQLInterfaceType) {\n    updateEachKey((type as GraphQLObjectType).getInterfaces(), (iface) => {\n      const healedType = healType(iface) as GraphQLInterfaceType;\n      return healedType;\n    });\n  }\n\n  function healInputFields(type: GraphQLInputObjectType) {\n    updateEachKey(type.getFields(), (field) => {\n      field.type = healType(field.type) as GraphQLInputType;\n      return field.type === null ? null : field;\n    });\n  }\n\n  function healUnderlyingTypes(type: GraphQLUnionType) {\n    updateEachKey(type.getTypes(), (t: GraphQLOutputType) => {\n      const healedType = healType(t) as GraphQLOutputType;\n      return healedType;\n    });\n  }\n\n  function healType<T extends GraphQLType>(type: T): GraphQLType | null {\n    // Unwrap the two known wrapper types\n    if (isListType(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new GraphQLList(healedType) : null;\n    } else if (isNonNullType(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new GraphQLNonNull(healedType) : null;\n    } else if (isNamedType(type)) {\n      // If a type annotation on a field or an argument or a union member is\n      // any `GraphQLNamedType` with a `name`, then it must end up identical\n      // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n      // of truth for all named schema types.\n      // Note that new types can still be simply added by adding a field, as\n      // the official type will be undefined, not null.\n      let officialType = originalTypeMap[type.name];\n      if (officialType === undefined) {\n        if (isStub(type)) {\n          officialType = getBuiltInForStub(type);\n        } else {\n          officialType = type;\n        }\n        originalTypeMap[type.name] = officialType;\n      }\n      return officialType;\n    }\n\n    return null;\n  }\n}\n\nfunction pruneTypes(\n  typeMap: Record<string, GraphQLNamedType | null>,\n  directives: ReadonlyArray<GraphQLDirective>,\n) {\n  const implementedInterfaces = {};\n  each(typeMap, (namedType) => {\n    if (\n      isObjectType(namedType) ||\n      (graphqlVersion() >= 15 && isInterfaceType(namedType))\n    ) {\n      each((namedType as GraphQLObjectType).getInterfaces(), (iface) => {\n        implementedInterfaces[iface.name] = true;\n      });\n    }\n  });\n\n  let prunedTypeMap = false;\n  const typeNames = Object.keys(typeMap);\n  for (let i = 0; i < typeNames.length; i++) {\n    const typeName = typeNames[i];\n    const type = typeMap[typeName];\n    if (isObjectType(type) || isInputObjectType(type)) {\n      // prune types with no fields\n      if (!Object.keys(type.getFields()).length) {\n        typeMap[typeName] = null;\n        prunedTypeMap = true;\n      }\n    } else if (isUnionType(type)) {\n      // prune unions without underlying types\n      if (!type.getTypes().length) {\n        typeMap[typeName] = null;\n        prunedTypeMap = true;\n      }\n    } else if (isInterfaceType(type)) {\n      // prune interfaces without fields or without implementations\n      if (\n        !Object.keys(type.getFields()).length ||\n        !implementedInterfaces[type.name]\n      ) {\n        typeMap[typeName] = null;\n        prunedTypeMap = true;\n      }\n    }\n  }\n\n  // every prune requires another round of healing\n  if (prunedTypeMap) {\n    healTypes(typeMap, directives);\n  }\n}\n","import {\n  GraphQLArgument,\n  GraphQLEnumType,\n  GraphQLEnumValue,\n  GraphQLField,\n  GraphQLInputField,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLUnionType,\n} from 'graphql';\n\n// Abstract base class of any visitor implementation, defining the available\n// visitor methods along with their parameter types, and providing a static\n// helper function for determining whether a subclass implements a given\n// visitor method, as opposed to inheriting one of the stubs defined here.\nexport abstract class SchemaVisitor {\n  // All SchemaVisitor instances are created while visiting a specific\n  // GraphQLSchema object, so this property holds a reference to that object,\n  // in case a visitor method needs to refer to this.schema.\n  public schema!: GraphQLSchema;\n\n  // Determine if this SchemaVisitor (sub)class implements a particular\n  // visitor method.\n  public static implementsVisitorMethod(methodName: string) {\n    if (!methodName.startsWith('visit')) {\n      return false;\n    }\n\n    const method = this.prototype[methodName];\n    if (typeof method !== 'function') {\n      return false;\n    }\n\n    if (this === SchemaVisitor) {\n      // The SchemaVisitor class implements every visitor method.\n      return true;\n    }\n\n    const stub = SchemaVisitor.prototype[methodName];\n    if (method === stub) {\n      // If this.prototype[methodName] was just inherited from SchemaVisitor,\n      // then this class does not really implement the method.\n      return false;\n    }\n\n    return true;\n  }\n\n  // Concrete subclasses of SchemaVisitor should override one or more of these\n  // visitor methods, in order to express their interest in handling certain\n  // schema types/locations. Each method may return null to remove the given\n  // type from the schema, a non-null value of the same type to update the\n  // type in the schema, or nothing to leave the type as it was.\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  public visitSchema(_schema: GraphQLSchema): void {}\n\n  public visitScalar(\n    _scalar: GraphQLScalarType,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLScalarType | void | null {}\n\n  public visitObject(\n    _object: GraphQLObjectType,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLObjectType | void | null {}\n\n  public visitFieldDefinition(\n    _field: GraphQLField<any, any>,\n    _details: {\n      objectType: GraphQLObjectType | GraphQLInterfaceType;\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLField<any, any> | void | null {}\n\n  public visitArgumentDefinition(\n    _argument: GraphQLArgument,\n    _details: {\n      field: GraphQLField<any, any>;\n      objectType: GraphQLObjectType | GraphQLInterfaceType;\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLArgument | void | null {}\n\n  public visitInterface(\n    _iface: GraphQLInterfaceType,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLInterfaceType | void | null {}\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  public visitUnion(_union: GraphQLUnionType): GraphQLUnionType | void | null {}\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  public visitEnum(_type: GraphQLEnumType): GraphQLEnumType | void | null {}\n\n  public visitEnumValue(\n    _value: GraphQLEnumValue,\n    _details: {\n      enumType: GraphQLEnumType;\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLEnumValue | void | null {}\n\n  public visitInputObject(\n    _object: GraphQLInputObjectType,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLInputObjectType | void | null {}\n\n  public visitInputFieldDefinition(\n    _field: GraphQLInputField,\n    _details: {\n      objectType: GraphQLInputObjectType;\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLInputField | void | null {}\n}\n","import { ValueNode, Kind } from 'graphql';\n\n// Similar to the graphql-js function of the same name, slightly simplified:\n// https://github.com/graphql/graphql-js/blob/master/src/utilities/valueFromASTUntyped.js\nexport default function valueFromASTUntyped(valueNode: ValueNode): any {\n  switch (valueNode.kind) {\n    case Kind.NULL:\n      return null;\n    case Kind.INT:\n      return parseInt(valueNode.value, 10);\n    case Kind.FLOAT:\n      return parseFloat(valueNode.value);\n    case Kind.STRING:\n    case Kind.ENUM:\n    case Kind.BOOLEAN:\n      return valueNode.value;\n    case Kind.LIST:\n      return valueNode.values.map(valueFromASTUntyped);\n    case Kind.OBJECT: {\n      const obj = Object.create(null);\n      valueNode.fields.forEach((field) => {\n        obj[field.name.value] = valueFromASTUntyped(field.value);\n      });\n      return obj;\n    }\n    /* istanbul ignore next */\n    default:\n      throw new Error('Unexpected value kind: ' + valueNode.kind);\n  }\n}\n","import {\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLSchema,\n  isNamedType,\n  GraphQLType,\n  GraphQLNamedType,\n  GraphQLInputField,\n  isSchema,\n  isObjectType,\n  isInterfaceType,\n  isInputObjectType,\n  isScalarType,\n  isUnionType,\n  isEnumType,\n  isInputType,\n} from 'graphql';\n\nimport {\n  VisitableSchemaType,\n  VisitorSelector,\n  VisitSchemaKind,\n  NamedTypeVisitor,\n  SchemaVisitorMap,\n} from '../Interfaces';\n\nimport updateEachKey from './updateEachKey';\nimport { healSchema } from './heal';\nimport { SchemaVisitor } from './SchemaVisitor';\nimport each from './each';\n\n// Generic function for visiting GraphQLSchema objects.\nexport function visitSchema(\n  schema: GraphQLSchema,\n  // To accommodate as many different visitor patterns as possible, the\n  // visitSchema function does not simply accept a single instance of the\n  // SchemaVisitor class, but instead accepts a function that takes the\n  // current VisitableSchemaType object and the name of a visitor method and\n  // returns an array of SchemaVisitor instances that implement the visitor\n  // method and have an interest in handling the given VisitableSchemaType\n  // object. In the simplest case, this function can always return an array\n  // containing a single visitor object, without even looking at the type or\n  // methodName parameters. In other cases, this function might sometimes\n  // return an empty array to indicate there are no visitors that should be\n  // applied to the given VisitableSchemaType object. For an example of a\n  // visitor pattern that benefits from this abstraction, see the\n  // SchemaDirectiveVisitor class below.\n  visitorOrVisitorSelector:\n    | VisitorSelector\n    | Array<SchemaVisitor | SchemaVisitorMap>\n    | SchemaVisitor\n    | SchemaVisitorMap,\n): GraphQLSchema {\n  const visitorSelector =\n    typeof visitorOrVisitorSelector === 'function'\n      ? visitorOrVisitorSelector\n      : () => visitorOrVisitorSelector;\n\n  // Helper function that calls visitorSelector and applies the resulting\n  // visitors to the given type, with arguments [type, ...args].\n  function callMethod<T extends VisitableSchemaType>(\n    methodName: string,\n    type: T,\n    ...args: Array<any>\n  ): T | null {\n    let visitors = visitorSelector(type, methodName);\n    visitors = Array.isArray(visitors) ? visitors : [visitors];\n\n    let finalType: T | null = type;\n    visitors.every((visitorOrVisitorDef) => {\n      let newType;\n      if (visitorOrVisitorDef instanceof SchemaVisitor) {\n        newType = visitorOrVisitorDef[methodName](finalType, ...args);\n      } else if (\n        isNamedType(finalType) &&\n        (methodName === 'visitScalar' ||\n          methodName === 'visitEnum' ||\n          methodName === 'visitObject' ||\n          methodName === 'visitInputObject' ||\n          methodName === 'visitUnion' ||\n          methodName === 'visitInterface')\n      ) {\n        const specifiers = getTypeSpecifiers(finalType, schema);\n        const typeVisitor = getVisitor(visitorOrVisitorDef, specifiers);\n        newType =\n          typeVisitor != null ? typeVisitor(finalType, schema) : undefined;\n      }\n\n      if (typeof newType === 'undefined') {\n        // Keep going without modifying type.\n        return true;\n      }\n\n      if (methodName === 'visitSchema' || isSchema(finalType)) {\n        throw new Error(\n          `Method ${methodName} cannot replace schema with ${\n            newType as string\n          }`,\n        );\n      }\n\n      if (newType === null) {\n        // Stop the loop and return null form callMethod, which will cause\n        // the type to be removed from the schema.\n        finalType = null;\n        return false;\n      }\n\n      // Update type to the new type returned by the visitor method, so that\n      // later directives will see the new type, and callMethod will return\n      // the final type.\n      finalType = newType;\n      return true;\n    });\n\n    // If there were no directives for this type object, or if all visitor\n    // methods returned nothing, type will be returned unmodified.\n    return finalType;\n  }\n\n  // Recursive helper function that calls any appropriate visitor methods for\n  // each object in the schema, then traverses the object's children (if any).\n  function visit<T extends VisitableSchemaType>(type: T): T | null {\n    if (isSchema(type)) {\n      // Unlike the other types, the root GraphQLSchema object cannot be\n      // replaced by visitor methods, because that would make life very hard\n      // for SchemaVisitor subclasses that rely on the original schema object.\n      callMethod('visitSchema', type);\n\n      const typeMap: Record<\n        string,\n        GraphQLNamedType | null\n      > = type.getTypeMap();\n      each(typeMap, (namedType, typeName) => {\n        if (!typeName.startsWith('__') && namedType != null) {\n          // Call visit recursively to let it determine which concrete\n          // subclass of GraphQLNamedType we found in the type map.\n          // We do not use updateEachKey because we want to preserve\n          // deleted types in the typeMap so that other types that reference\n          // the deleted types can be healed.\n          typeMap[typeName] = visit(namedType);\n        }\n      });\n\n      return type;\n    }\n\n    if (isObjectType(type)) {\n      // Note that callMethod('visitObject', type) may not actually call any\n      // methods, if there are no @directive annotations associated with this\n      // type, or if this SchemaDirectiveVisitor subclass does not override\n      // the visitObject method.\n      const newObject = callMethod('visitObject', type);\n      if (newObject != null) {\n        visitFields(newObject);\n      }\n      return newObject;\n    }\n\n    if (isInterfaceType(type)) {\n      const newInterface = callMethod('visitInterface', type);\n      if (newInterface != null) {\n        visitFields(newInterface);\n      }\n      return newInterface;\n    }\n\n    if (isInputObjectType(type)) {\n      const newInputObject = callMethod('visitInputObject', type);\n\n      if (newInputObject != null) {\n        const fieldMap = newInputObject.getFields() as Record<\n          string,\n          GraphQLInputField\n        >;\n        updateEachKey(fieldMap, (field) =>\n          callMethod('visitInputFieldDefinition', field, {\n            // Since we call a different method for input object fields, we\n            // can't reuse the visitFields function here.\n            objectType: newInputObject,\n          }),\n        );\n      }\n\n      return newInputObject;\n    }\n\n    if (isScalarType(type)) {\n      return callMethod('visitScalar', type);\n    }\n\n    if (isUnionType(type)) {\n      return callMethod('visitUnion', type);\n    }\n\n    if (isEnumType(type)) {\n      const newEnum = callMethod('visitEnum', type);\n\n      if (newEnum != null) {\n        updateEachKey(newEnum.getValues(), (value) =>\n          callMethod('visitEnumValue', value, {\n            enumType: newEnum,\n          }),\n        );\n      }\n\n      return newEnum;\n    }\n\n    throw new Error(`Unexpected schema type: ${(type as unknown) as string}`);\n  }\n\n  function visitFields(type: GraphQLObjectType | GraphQLInterfaceType) {\n    updateEachKey(type.getFields(), (field) => {\n      // It would be nice if we could call visit(field) recursively here, but\n      // GraphQLField is merely a type, not a value that can be detected using\n      // an instanceof check, so we have to visit the fields in this lexical\n      // context, so that TypeScript can validate the call to\n      // visitFieldDefinition.\n      const newField = callMethod('visitFieldDefinition', field, {\n        // While any field visitor needs a reference to the field object, some\n        // field visitors may also need to know the enclosing (parent) type,\n        // perhaps to determine if the parent is a GraphQLObjectType or a\n        // GraphQLInterfaceType. To obtain a reference to the parent, a\n        // visitor method can have a second parameter, which will be an object\n        // with an .objectType property referring to the parent.\n        objectType: type,\n      });\n\n      if (newField.args != null) {\n        updateEachKey(newField.args, (arg) =>\n          callMethod('visitArgumentDefinition', arg, {\n            // Like visitFieldDefinition, visitArgumentDefinition takes a\n            // second parameter that provides additional context, namely the\n            // parent .field and grandparent .objectType. Remember that the\n            // current GraphQLSchema is always available via this.schema.\n            field: newField,\n            objectType: type,\n          }),\n        );\n      }\n\n      return newField;\n    });\n  }\n\n  visit(schema);\n\n  // Automatically update any references to named schema types replaced\n  // during the traversal, so implementors don't have to worry about that.\n  healSchema(schema);\n\n  // Return schema for convenience, even though schema parameter has all updated types.\n  return schema;\n}\n\nfunction getTypeSpecifiers(\n  type: GraphQLType,\n  schema: GraphQLSchema,\n): Array<VisitSchemaKind> {\n  const specifiers = [VisitSchemaKind.TYPE];\n  if (isObjectType(type)) {\n    specifiers.push(\n      VisitSchemaKind.COMPOSITE_TYPE,\n      VisitSchemaKind.OBJECT_TYPE,\n    );\n    const query = schema.getQueryType();\n    const mutation = schema.getMutationType();\n    const subscription = schema.getSubscriptionType();\n    if (type === query) {\n      specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.QUERY);\n    } else if (type === mutation) {\n      specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.MUTATION);\n    } else if (type === subscription) {\n      specifiers.push(\n        VisitSchemaKind.ROOT_OBJECT,\n        VisitSchemaKind.SUBSCRIPTION,\n      );\n    }\n  } else if (isInputType(type)) {\n    specifiers.push(VisitSchemaKind.INPUT_OBJECT_TYPE);\n  } else if (isInterfaceType(type)) {\n    specifiers.push(\n      VisitSchemaKind.COMPOSITE_TYPE,\n      VisitSchemaKind.ABSTRACT_TYPE,\n      VisitSchemaKind.INTERFACE_TYPE,\n    );\n  } else if (isUnionType(type)) {\n    specifiers.push(\n      VisitSchemaKind.COMPOSITE_TYPE,\n      VisitSchemaKind.ABSTRACT_TYPE,\n      VisitSchemaKind.UNION_TYPE,\n    );\n  } else if (isEnumType(type)) {\n    specifiers.push(VisitSchemaKind.ENUM_TYPE);\n  } else if (isScalarType(type)) {\n    specifiers.push(VisitSchemaKind.SCALAR_TYPE);\n  }\n\n  return specifiers;\n}\n\nfunction getVisitor(\n  visitorDef: SchemaVisitorMap,\n  specifiers: Array<VisitSchemaKind>,\n): NamedTypeVisitor | null {\n  let typeVisitor: NamedTypeVisitor | undefined;\n  const stack = [...specifiers];\n  while (!typeVisitor && stack.length > 0) {\n    const next = stack.pop();\n    typeVisitor = visitorDef[next] as NamedTypeVisitor;\n  }\n\n  return typeVisitor != null ? typeVisitor : null;\n}\n","import {\n  GraphQLDirective,\n  GraphQLSchema,\n  DirectiveLocationEnum,\n  TypeSystemExtensionNode,\n} from 'graphql';\nimport { getArgumentValues } from 'graphql/execution/values';\n\nimport { VisitableSchemaType } from '../Interfaces';\n\nimport each from './each';\nimport valueFromASTUntyped from './valueFromASTUntyped';\nimport { SchemaVisitor } from './SchemaVisitor';\nimport { visitSchema } from './visitSchema';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// This class represents a reusable implementation of a @directive that may\n// appear in a GraphQL schema written in Schema Definition Language.\n//\n// By overriding one or more visit{Object,Union,...} methods, a subclass\n// registers interest in certain schema types, such as GraphQLObjectType,\n// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is\n// called with a GraphQLSchema object and a map of visitor subclasses, the\n// overidden methods of those subclasses allow the visitors to obtain\n// references to any type objects that have @directives attached to them,\n// enabling visitors to inspect or modify the schema as appropriate.\n//\n// For example, if a directive called @rest(url: \"...\") appears after a field\n// definition, a SchemaDirectiveVisitor subclass could provide meaning to that\n// directive by overriding the visitFieldDefinition method (which receives a\n// GraphQLField parameter), and then the body of that visitor method could\n// manipulate the field's resolver function to fetch data from a REST endpoint\n// described by the url argument passed to the @rest directive:\n//\n//   const typeDefs = `\n//   type Query {\n//     people: [Person] @rest(url: \"/api/v1/people\")\n//   }`;\n//\n//   const schema = makeExecutableSchema({ typeDefs });\n//\n//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\n//     rest: class extends SchemaDirectiveVisitor {\n//       public visitFieldDefinition(field: GraphQLField<any, any>) {\n//         const { url } = this.args;\n//         field.resolve = () => fetch(url);\n//       }\n//     }\n//   });\n//\n// The subclass in this example is defined as an anonymous class expression,\n// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be\n// defined in a library using a named class declaration, and then exported for\n// consumption by other modules and packages.\n//\n// See below for a complete list of overridable visitor methods, their\n// parameter types, and more details about the properties exposed by instances\n// of the SchemaDirectiveVisitor class.\n\nexport class SchemaDirectiveVisitor<\n  TArgs = { [name: string]: any },\n  TContext = { [key: string]: any }\n> extends SchemaVisitor {\n  // The name of the directive this visitor is allowed to visit (that is, the\n  // identifier that appears after the @ character in the schema). Note that\n  // this property is per-instance rather than static because subclasses of\n  // SchemaDirectiveVisitor can be instantiated multiple times to visit\n  // directives of different names. In other words, SchemaDirectiveVisitor\n  // implementations are effectively anonymous, and it's up to the caller of\n  // SchemaDirectiveVisitor.visitSchemaDirectives to assign names to them.\n  public name: string;\n\n  // A map from parameter names to argument values, as obtained from a\n  // specific occurrence of a @directive(arg1: value1, arg2: value2, ...) in\n  // the schema. Visitor methods may refer to this object via this.args.\n  public args: TArgs;\n\n  // A reference to the type object that this visitor was created to visit.\n  public visitedType: VisitableSchemaType;\n\n  // A shared object that will be available to all visitor instances via\n  // this.context. Callers of visitSchemaDirectives can provide their own\n  // object, or just use the default empty object.\n  public context: TContext;\n\n  // Override this method to return a custom GraphQLDirective (or modify one\n  // already present in the schema) to enforce argument types, provide default\n  // argument values, or specify schema locations where this @directive may\n  // appear. By default, any declaration found in the schema will be returned.\n  public static getDirectiveDeclaration(\n    directiveName: string,\n    schema: GraphQLSchema,\n  ): GraphQLDirective | null | undefined {\n    return schema.getDirective(directiveName);\n  }\n\n  // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every\n  // @directive in the schema and create an appropriate SchemaDirectiveVisitor\n  // instance to visit the object decorated by the @directive.\n  public static visitSchemaDirectives(\n    schema: GraphQLSchema,\n    directiveVisitors: {\n      // The keys of this object correspond to directive names as they appear\n      // in the schema, and the values should be subclasses (not instances!)\n      // of the SchemaDirectiveVisitor class. This distinction is important\n      // because a new SchemaDirectiveVisitor instance will be created each\n      // time a matching directive is found in the schema AST, with arguments\n      // and other metadata specific to that occurrence. To help prevent the\n      // mistake of passing instances, the SchemaDirectiveVisitor constructor\n      // method is marked as protected.\n      [directiveName: string]: typeof SchemaDirectiveVisitor;\n    },\n    // Optional context object that will be available to all visitor instances\n    // via this.context. Defaults to an empty null-prototype object.\n    context: {\n      [key: string]: any;\n    } = Object.create(null),\n  ): {\n    // The visitSchemaDirectives method returns a map from directive names to\n    // lists of SchemaDirectiveVisitors created while visiting the schema.\n    [directiveName: string]: Array<SchemaDirectiveVisitor>;\n  } {\n    // If the schema declares any directives for public consumption, record\n    // them here so that we can properly coerce arguments when/if we encounter\n    // an occurrence of the directive while walking the schema below.\n    const declaredDirectives = this.getDeclaredDirectives(\n      schema,\n      directiveVisitors,\n    );\n\n    // Map from directive names to lists of SchemaDirectiveVisitor instances\n    // created while visiting the schema.\n    const createdVisitors: {\n      [directiveName: string]: Array<SchemaDirectiveVisitor>;\n    } = Object.create(null);\n    Object.keys(directiveVisitors).forEach((directiveName) => {\n      createdVisitors[directiveName] = [];\n    });\n\n    function visitorSelector(\n      type: VisitableSchemaType,\n      methodName: string,\n    ): Array<SchemaDirectiveVisitor> {\n      let directiveNodes = type.astNode != null ? type.astNode.directives : [];\n\n      const extensionASTNodes: ReadonlyArray<TypeSystemExtensionNode> = (type as {\n        extensionASTNodes?: Array<TypeSystemExtensionNode>;\n      }).extensionASTNodes;\n\n      if (extensionASTNodes != null) {\n        extensionASTNodes.forEach((extensionASTNode) => {\n          directiveNodes = directiveNodes.concat(extensionASTNode.directives);\n        });\n      }\n\n      const visitors: Array<SchemaDirectiveVisitor> = [];\n      directiveNodes.forEach((directiveNode) => {\n        const directiveName = directiveNode.name.value;\n        if (!hasOwn.call(directiveVisitors, directiveName)) {\n          return;\n        }\n\n        const visitorClass = directiveVisitors[directiveName];\n\n        // Avoid creating visitor objects if visitorClass does not override\n        // the visitor method named by methodName.\n        if (!visitorClass.implementsVisitorMethod(methodName)) {\n          return;\n        }\n\n        const decl = declaredDirectives[directiveName];\n        let args: { [key: string]: any };\n\n        if (decl != null) {\n          // If this directive was explicitly declared, use the declared\n          // argument types (and any default values) to check, coerce, and/or\n          // supply default values for the given arguments.\n          args = getArgumentValues(decl, directiveNode);\n        } else {\n          // If this directive was not explicitly declared, just convert the\n          // argument nodes to their corresponding JavaScript values.\n          args = Object.create(null);\n          if (directiveNode.arguments != null) {\n            directiveNode.arguments.forEach((arg) => {\n              args[arg.name.value] = valueFromASTUntyped(arg.value);\n            });\n          }\n        }\n\n        // As foretold in comments near the top of the visitSchemaDirectives\n        // method, this is where instances of the SchemaDirectiveVisitor class\n        // get created and assigned names. While subclasses could override the\n        // constructor method, the constructor is marked as protected, so\n        // these are the only arguments that will ever be passed.\n        visitors.push(\n          new visitorClass({\n            name: directiveName,\n            args,\n            visitedType: type,\n            schema,\n            context,\n          }),\n        );\n      });\n\n      if (visitors.length > 0) {\n        visitors.forEach((visitor) => {\n          createdVisitors[visitor.name].push(visitor);\n        });\n      }\n\n      return visitors;\n    }\n\n    visitSchema(schema, visitorSelector);\n\n    return createdVisitors;\n  }\n\n  protected static getDeclaredDirectives(\n    schema: GraphQLSchema,\n    directiveVisitors: {\n      [directiveName: string]: typeof SchemaDirectiveVisitor;\n    },\n  ) {\n    const declaredDirectives: {\n      [directiveName: string]: GraphQLDirective;\n    } = Object.create(null);\n\n    each(schema.getDirectives(), (decl: GraphQLDirective) => {\n      declaredDirectives[decl.name] = decl;\n    });\n\n    // If the visitor subclass overrides getDirectiveDeclaration, and it\n    // returns a non-null GraphQLDirective, use that instead of any directive\n    // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor\n    // goes to the trouble of implementing getDirectiveDeclaration, it should\n    // be able to rely on that implementation.\n    each(directiveVisitors, (visitorClass, directiveName) => {\n      const decl = visitorClass.getDirectiveDeclaration(directiveName, schema);\n      if (decl != null) {\n        declaredDirectives[directiveName] = decl;\n      }\n    });\n\n    each(declaredDirectives, (decl, name) => {\n      if (!hasOwn.call(directiveVisitors, name)) {\n        // SchemaDirectiveVisitors.visitSchemaDirectives might be called\n        // multiple times with partial directiveVisitors maps, so it's not\n        // necessarily an error for directiveVisitors to be missing an\n        // implementation of a directive that was declared in the schema.\n        return;\n      }\n      const visitorClass = directiveVisitors[name];\n\n      each(decl.locations, (loc) => {\n        const visitorMethodName = directiveLocationToVisitorMethodName(loc);\n        if (\n          SchemaVisitor.implementsVisitorMethod(visitorMethodName) &&\n          !visitorClass.implementsVisitorMethod(visitorMethodName)\n        ) {\n          // While visitor subclasses may implement extra visitor methods,\n          // it's definitely a mistake if the GraphQLDirective declares itself\n          // applicable to certain schema locations, and the visitor subclass\n          // does not implement all the corresponding methods.\n          throw new Error(\n            `SchemaDirectiveVisitor for @${name} must implement ${visitorMethodName} method`,\n          );\n        }\n      });\n    });\n\n    return declaredDirectives;\n  }\n\n  // Mark the constructor protected to enforce passing SchemaDirectiveVisitor\n  // subclasses (not instances) to visitSchemaDirectives.\n  protected constructor(config: {\n    name: string;\n    args: TArgs;\n    visitedType: VisitableSchemaType;\n    schema: GraphQLSchema;\n    context: TContext;\n  }) {\n    super();\n    this.name = config.name;\n    this.args = config.args;\n    this.visitedType = config.visitedType;\n    this.schema = config.schema;\n    this.context = config.context;\n  }\n}\n\n// Convert a string like \"FIELD_DEFINITION\" to \"visitFieldDefinition\".\nfunction directiveLocationToVisitorMethodName(loc: DirectiveLocationEnum) {\n  return (\n    'visit' +\n    loc.replace(\n      /([^_]*)_?/g,\n      (_wholeMatch, part: string) =>\n        part.charAt(0).toUpperCase() + part.slice(1).toLowerCase(),\n    )\n  );\n}\n","import { getNamedType, GraphQLSchema, isObjectType } from 'graphql';\n\nimport { IFieldIteratorFn } from '../Interfaces';\n\nexport function forEachField(\n  schema: GraphQLSchema,\n  fn: IFieldIteratorFn,\n): void {\n  const typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach((typeName) => {\n    const type = typeMap[typeName];\n\n    // TODO: maybe have an option to include these?\n    if (!getNamedType(type).name.startsWith('__') && isObjectType(type)) {\n      const fields = type.getFields();\n      Object.keys(fields).forEach((fieldName) => {\n        const field = fields[fieldName];\n        fn(field, typeName, fieldName);\n      });\n    }\n  });\n}\n","import {\n  getNamedType,\n  GraphQLSchema,\n  isObjectType,\n  isInputObjectType,\n} from 'graphql';\n\nimport { IDefaultValueIteratorFn } from '../Interfaces';\n\nexport function forEachDefaultValue(\n  schema: GraphQLSchema,\n  fn: IDefaultValueIteratorFn,\n): void {\n  const typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach((typeName) => {\n    const type = typeMap[typeName];\n\n    if (!getNamedType(type).name.startsWith('__')) {\n      if (isObjectType(type)) {\n        const fields = type.getFields();\n        Object.keys(fields).forEach((fieldName) => {\n          const field = fields[fieldName];\n\n          field.args.forEach((arg) => {\n            arg.defaultValue = fn(arg.type, arg.defaultValue);\n          });\n        });\n      } else if (isInputObjectType(type)) {\n        const fields = type.getFields();\n        Object.keys(fields).forEach((fieldName) => {\n          const field = fields[fieldName];\n          field.defaultValue = fn(field.type, field.defaultValue);\n        });\n      }\n    }\n  });\n}\n","import {\n  GraphQLEnumType,\n  GraphQLInputType,\n  GraphQLScalarType,\n  getNullableType,\n  isLeafType,\n  isListType,\n  isInputObjectType,\n} from 'graphql';\n\ntype InputValueTransformer = (\n  type: GraphQLEnumType | GraphQLScalarType,\n  originalValue: any,\n) => any;\n\nexport function transformInputValue(\n  type: GraphQLInputType,\n  value: any,\n  transformer: InputValueTransformer,\n) {\n  if (value == null) {\n    return value;\n  }\n\n  const nullableType = getNullableType(type);\n\n  if (isLeafType(nullableType)) {\n    return transformer(nullableType, value);\n  } else if (isListType(nullableType)) {\n    return value.map((listMember: any) =>\n      transformInputValue(nullableType.ofType, listMember, transformer),\n    );\n  } else if (isInputObjectType(nullableType)) {\n    const fields = nullableType.getFields();\n    const newValue = {};\n    Object.keys(value).forEach((key) => {\n      newValue[key] = transformInputValue(\n        fields[key].type,\n        value[key],\n        transformer,\n      );\n    });\n    return newValue;\n  }\n\n  // unreachable, no other possible return value\n}\n\nexport function serializeInputValue(type: GraphQLInputType, value: any) {\n  return transformInputValue(type, value, (t, v) => t.serialize(v));\n}\n\nexport function parseInputValue(type: GraphQLInputType, value: any) {\n  return transformInputValue(type, value, (t, v) => t.parseValue(v));\n}\n\nexport function parseInputValueLiteral(type: GraphQLInputType, value: any) {\n  return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));\n}\n","import {\n  InlineFragmentNode,\n  SelectionNode,\n  Kind,\n  parse,\n  OperationDefinitionNode,\n} from 'graphql';\n\nexport function concatInlineFragments(\n  type: string,\n  fragments: Array<InlineFragmentNode>,\n): InlineFragmentNode {\n  const fragmentSelections: Array<SelectionNode> = fragments.reduce(\n    (selections, fragment) =>\n      selections.concat(fragment.selectionSet.selections),\n    [],\n  );\n\n  const deduplicatedFragmentSelection: Array<SelectionNode> = deduplicateSelection(\n    fragmentSelections,\n  );\n\n  return {\n    kind: Kind.INLINE_FRAGMENT,\n    typeCondition: {\n      kind: Kind.NAMED_TYPE,\n      name: {\n        kind: Kind.NAME,\n        value: type,\n      },\n    },\n    selectionSet: {\n      kind: Kind.SELECTION_SET,\n      selections: deduplicatedFragmentSelection,\n    },\n  };\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nfunction deduplicateSelection(\n  nodes: Array<SelectionNode>,\n): Array<SelectionNode> {\n  const selectionMap = nodes.reduce<{ [key: string]: SelectionNode }>(\n    (map, node) => {\n      switch (node.kind) {\n        case 'Field': {\n          if (node.alias != null) {\n            if (hasOwn.call(map, node.alias.value)) {\n              return map;\n            }\n\n            return {\n              ...map,\n              [node.alias.value]: node,\n            };\n          }\n\n          if (hasOwn.call(map, node.name.value)) {\n            return map;\n          }\n\n          return {\n            ...map,\n            [node.name.value]: node,\n          };\n        }\n        case 'FragmentSpread': {\n          if (hasOwn.call(map, node.name.value)) {\n            return map;\n          }\n\n          return {\n            ...map,\n            [node.name.value]: node,\n          };\n        }\n        case 'InlineFragment': {\n          if (map.__fragment != null) {\n            const fragment = map.__fragment as InlineFragmentNode;\n\n            return {\n              ...map,\n              __fragment: concatInlineFragments(\n                fragment.typeCondition.name.value,\n                [fragment, node],\n              ),\n            };\n          }\n\n          return {\n            ...map,\n            __fragment: node,\n          };\n        }\n        default: {\n          return map;\n        }\n      }\n    },\n    {},\n  );\n\n  const selection = Object.keys(selectionMap).reduce(\n    (selectionList, node) => selectionList.concat(selectionMap[node]),\n    [],\n  );\n\n  return selection;\n}\n\nexport function parseFragmentToInlineFragment(\n  definitions: string,\n): InlineFragmentNode {\n  if (definitions.trim().startsWith('fragment')) {\n    const document = parse(definitions);\n    for (const definition of document.definitions) {\n      if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n        return {\n          kind: Kind.INLINE_FRAGMENT,\n          typeCondition: definition.typeCondition,\n          selectionSet: definition.selectionSet,\n        };\n      }\n    }\n  }\n\n  const query = parse(`{${definitions}}`)\n    .definitions[0] as OperationDefinitionNode;\n  for (const selection of query.selectionSet.selections) {\n    if (selection.kind === Kind.INLINE_FRAGMENT) {\n      return selection;\n    }\n  }\n\n  throw new Error('Could not parse fragment');\n}\n","import {\n  OperationDefinitionNode,\n  SelectionSetNode,\n  parse,\n  Kind,\n  GraphQLObjectType,\n  getNamedType,\n} from 'graphql';\n\nexport function parseSelectionSet(selectionSet: string): SelectionSetNode {\n  const query = parse(selectionSet).definitions[0] as OperationDefinitionNode;\n  return query.selectionSet;\n}\n\nexport function typeContainsSelectionSet(\n  type: GraphQLObjectType,\n  selectionSet: SelectionSetNode,\n): boolean {\n  const fields = type.getFields();\n\n  for (const selection of selectionSet.selections) {\n    if (selection.kind === Kind.FIELD) {\n      const field = fields[selection.name.value];\n\n      if (field == null) {\n        return false;\n      }\n\n      if (selection.selectionSet != null) {\n        return typeContainsSelectionSet(\n          getNamedType(field.type) as GraphQLObjectType,\n          selection.selectionSet,\n        );\n      }\n    } else if (selection.kind === Kind.INLINE_FRAGMENT) {\n      const containsSelectionSet = typeContainsSelectionSet(\n        type,\n        selection.selectionSet,\n      );\n      if (!containsSelectionSet) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n","export function mergeDeep(target: any, ...sources: any): any {\n  const output = {\n    ...target,\n  };\n  sources.forEach((source: any) => {\n    if (isObject(target) && isObject(source)) {\n      Object.keys(source).forEach((key) => {\n        if (isObject(source[key])) {\n          if (!(key in target)) {\n            Object.assign(output, { [key]: source[key] });\n          } else {\n            output[key] = mergeDeep(target[key], source[key]);\n          }\n        } else {\n          Object.assign(output, { [key]: source[key] });\n        }\n      });\n    }\n  });\n  return output;\n}\n\nfunction isObject(item: any): boolean {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n","import {\n  FieldNode,\n  Kind,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n} from 'graphql';\n\nexport function renameFieldNode(fieldNode: FieldNode, name: string): FieldNode {\n  return {\n    ...fieldNode,\n    alias: {\n      kind: Kind.NAME,\n      value:\n        fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value,\n    },\n    name: {\n      kind: Kind.NAME,\n      value: name,\n    },\n  };\n}\n\nexport function preAliasFieldNode(\n  fieldNode: FieldNode,\n  str: string,\n): FieldNode {\n  return {\n    ...fieldNode,\n    alias: {\n      kind: Kind.NAME,\n      value: `${str}${\n        fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value\n      }`,\n    },\n  };\n}\n\nexport function wrapFieldNode(\n  fieldNode: FieldNode,\n  path: Array<string>,\n): FieldNode {\n  let newFieldNode = fieldNode;\n  path.forEach((fieldName) => {\n    newFieldNode = {\n      kind: Kind.FIELD,\n      name: {\n        kind: Kind.NAME,\n        value: fieldName,\n      },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [fieldNode],\n      },\n    };\n  });\n\n  return newFieldNode;\n}\n\nexport function collectFields(\n  selectionSet: SelectionSetNode | undefined,\n  fragments: Record<string, FragmentDefinitionNode>,\n  fields: Array<FieldNode> = [],\n  visitedFragmentNames = {},\n): Array<FieldNode> {\n  if (selectionSet != null) {\n    selectionSet.selections.forEach((selection) => {\n      switch (selection.kind) {\n        case Kind.FIELD:\n          fields.push(selection);\n          break;\n        case Kind.INLINE_FRAGMENT:\n          collectFields(\n            selection.selectionSet,\n            fragments,\n            fields,\n            visitedFragmentNames,\n          );\n          break;\n        case Kind.FRAGMENT_SPREAD: {\n          const fragmentName = selection.name.value;\n          if (!visitedFragmentNames[fragmentName]) {\n            visitedFragmentNames[fragmentName] = true;\n            collectFields(\n              fragments[fragmentName].selectionSet,\n              fragments,\n              fields,\n              visitedFragmentNames,\n            );\n          }\n          break;\n        }\n        default:\n          // unreachable\n          break;\n      }\n    });\n  }\n\n  return fields;\n}\n\nexport function hoistFieldNodes({\n  fieldNode,\n  fieldNames,\n  path = [],\n  delimeter = '__gqltf__',\n  fragments,\n}: {\n  fieldNode: FieldNode;\n  fieldNames?: Array<string>;\n  path?: Array<string>;\n  delimeter?: string;\n  fragments: Record<string, FragmentDefinitionNode>;\n}): Array<FieldNode> {\n  const alias =\n    fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value;\n\n  let newFieldNodes: Array<FieldNode> = [];\n\n  if (path.length) {\n    const remainingPathSegments = path.slice();\n    const initialPathSegment = remainingPathSegments.shift();\n\n    collectFields(fieldNode.selectionSet, fragments).forEach(\n      (possibleFieldNode: FieldNode) => {\n        if (possibleFieldNode.name.value === initialPathSegment) {\n          newFieldNodes = newFieldNodes.concat(\n            hoistFieldNodes({\n              fieldNode: preAliasFieldNode(\n                possibleFieldNode,\n                `${alias}${delimeter}`,\n              ),\n              fieldNames,\n              path: remainingPathSegments,\n              delimeter,\n              fragments,\n            }),\n          );\n        }\n      },\n    );\n  } else {\n    collectFields(fieldNode.selectionSet, fragments).forEach(\n      (possibleFieldNode: FieldNode) => {\n        if (!fieldNames || fieldNames.includes(possibleFieldNode.name.value)) {\n          newFieldNodes.push(\n            preAliasFieldNode(possibleFieldNode, `${alias}${delimeter}`),\n          );\n        }\n      },\n    );\n  }\n\n  return newFieldNodes;\n}\n","import {\n  GraphQLFieldConfigMap,\n  GraphQLObjectType,\n  GraphQLFieldConfig,\n} from 'graphql';\nimport { TypeMap } from 'graphql/type/schema';\n\nimport { toConfig } from '../polyfills/index';\n\nexport function appendFields(\n  typeMap: TypeMap,\n  typeName: string,\n  fields: GraphQLFieldConfigMap<any, any>,\n): void {\n  let type = typeMap[typeName];\n  if (type != null) {\n    const typeConfig = toConfig(type);\n    const originalFields = typeConfig.fields;\n    const newFields = {};\n    Object.keys(originalFields).forEach((fieldName) => {\n      newFields[fieldName] = originalFields[fieldName];\n    });\n    Object.keys(fields).forEach((fieldName) => {\n      newFields[fieldName] = fields[fieldName];\n    });\n    type = new GraphQLObjectType({\n      ...typeConfig,\n      fields: newFields,\n    });\n  } else {\n    type = new GraphQLObjectType({\n      name: typeName,\n      fields,\n    });\n  }\n  typeMap[typeName] = type;\n}\n\nexport function removeFields(\n  typeMap: TypeMap,\n  typeName: string,\n  testFn: (fieldName: string, field: GraphQLFieldConfig<any, any>) => boolean,\n): GraphQLFieldConfigMap<any, any> {\n  let type = typeMap[typeName];\n  const typeConfig = toConfig(type);\n  const originalFields = typeConfig.fields;\n  const newFields = {};\n  const removedFields = {};\n  Object.keys(originalFields).forEach((fieldName) => {\n    if (testFn(fieldName, originalFields[fieldName])) {\n      removedFields[fieldName] = originalFields[fieldName];\n    } else {\n      newFields[fieldName] = originalFields[fieldName];\n    }\n  });\n  type = new GraphQLObjectType({\n    ...typeConfig,\n    fields: newFields,\n  });\n  typeMap[typeName] = type;\n\n  return removedFields;\n}\n","import { GraphQLError, responsePathAsArray } from 'graphql';\n\nimport { SubschemaConfig, IGraphQLToolsResolveInfo } from '../Interfaces';\nimport { mergeDeep } from '../utils/index';\nimport { handleNull } from '../delegate/results/handleNull';\n\nimport { relocatedError, setErrors, getErrors } from './errors';\nimport {\n  ERROR_SYMBOL,\n  FIELD_SUBSCHEMA_MAP_SYMBOL,\n  OBJECT_SUBSCHEMA_SYMBOL,\n} from './symbols';\nimport { getSubschema, setObjectSubschema } from './subSchema';\n\nexport function isProxiedResult(result: any) {\n  return result != null ? result[ERROR_SYMBOL] : result;\n}\n\nexport function unwrapResult(\n  parent: any,\n  info: IGraphQLToolsResolveInfo,\n  path: Array<string>,\n): any {\n  let newParent: any = parent;\n  const pathLength = path.length;\n  for (let i = 0; i < pathLength; i++) {\n    const responseKey = path[i];\n    const errors = getErrors(newParent, responseKey);\n    const subschema = getSubschema(newParent, responseKey);\n\n    const object = newParent[responseKey];\n    if (object == null) {\n      return handleNull(\n        info.fieldNodes,\n        responsePathAsArray(info.path),\n        errors,\n      );\n    }\n\n    setErrors(\n      object,\n      errors.map((error) =>\n        relocatedError(\n          error,\n          error.nodes,\n          error.path != null ? error.path.slice(1) : undefined,\n        ),\n      ),\n    );\n    setObjectSubschema(object, subschema);\n\n    newParent = object;\n  }\n\n  return newParent;\n}\n\nexport function dehoistResult(\n  parent: any,\n  delimeter: string = '__gqltf__',\n): any {\n  const result = Object.create(null);\n\n  Object.keys(parent).forEach((alias) => {\n    let obj = result;\n\n    const fieldNames = alias.split(delimeter);\n    const fieldName = fieldNames.pop();\n    fieldNames.forEach((key) => {\n      obj = obj[key] = obj[key] || Object.create(null);\n    });\n    obj[fieldName] = parent[alias];\n  });\n\n  result[ERROR_SYMBOL] = parent[ERROR_SYMBOL].map((error: GraphQLError) => {\n    if (error.path != null) {\n      const path = error.path.slice();\n      const pathSegment = path.shift();\n      const expandedPathSegment: Array<\n        string | number\n      > = (pathSegment as string).split(delimeter);\n      return relocatedError(\n        error,\n        error.nodes,\n        expandedPathSegment.concat(path),\n      );\n    }\n\n    return error;\n  });\n\n  result[OBJECT_SUBSCHEMA_SYMBOL] = parent[OBJECT_SUBSCHEMA_SYMBOL];\n\n  return result;\n}\n\nexport function mergeProxiedResults(target: any, ...sources: any): any {\n  const errors = target[ERROR_SYMBOL].concat(\n    sources.map((source: any) => source[ERROR_SYMBOL]),\n  );\n  const fieldSubschemaMap = sources.reduce(\n    (acc: Record<any, SubschemaConfig>, source: any) => {\n      const subschema = source[OBJECT_SUBSCHEMA_SYMBOL];\n      Object.keys(source).forEach((key) => {\n        acc[key] = subschema;\n      });\n      return acc;\n    },\n    {},\n  );\n  const result = mergeDeep(target, ...sources);\n  result[ERROR_SYMBOL] = errors;\n  result[FIELD_SUBSCHEMA_MAP_SYMBOL] = target[FIELD_SUBSCHEMA_MAP_SYMBOL]\n    ? mergeDeep(target[FIELD_SUBSCHEMA_MAP_SYMBOL], fieldSubschemaMap)\n    : fieldSubschemaMap;\n  return result;\n}\n","import { FieldNode, SelectionNode, Kind } from 'graphql';\n\nimport {\n  SubschemaConfig,\n  IGraphQLToolsResolveInfo,\n  MergedTypeInfo,\n} from '../Interfaces';\n\nimport { mergeProxiedResults } from './proxiedResult';\n\nfunction buildDelegationPlan(\n  mergedTypeInfo: MergedTypeInfo,\n  originalSelections: Array<FieldNode>,\n  sourceSubschemas: Array<SubschemaConfig>,\n  targetSubschemas: Array<SubschemaConfig>,\n): {\n  delegationMap: Map<SubschemaConfig, Array<SelectionNode>>;\n  unproxiableSelections: Array<FieldNode>;\n  proxiableSubschemas: Array<SubschemaConfig>;\n  nonProxiableSubschemas: Array<SubschemaConfig>;\n} {\n  // 1.  calculate if possible to delegate to given subschema\n  //    TODO: change logic so that required selection set can be spread across multiple subschemas?\n\n  const proxiableSubschemas: Array<SubschemaConfig> = [];\n  const nonProxiableSubschemas: Array<SubschemaConfig> = [];\n\n  targetSubschemas.forEach((t) => {\n    if (\n      sourceSubschemas.some((s) => {\n        const selectionSet = mergedTypeInfo.selectionSets.get(t);\n        return mergedTypeInfo.containsSelectionSet.get(s).get(selectionSet);\n      })\n    ) {\n      proxiableSubschemas.push(t);\n    } else {\n      nonProxiableSubschemas.push(t);\n    }\n  });\n\n  const { uniqueFields, nonUniqueFields } = mergedTypeInfo;\n  const unproxiableSelections: Array<FieldNode> = [];\n\n  // 2. for each selection:\n\n  const delegationMap: Map<SubschemaConfig, Array<SelectionNode>> = new Map();\n  originalSelections.forEach((selection) => {\n    // 2a. use uniqueFields map to assign fields to subschema if one of possible subschemas\n\n    const uniqueSubschema: SubschemaConfig = uniqueFields[selection.name.value];\n    if (uniqueSubschema != null) {\n      if (proxiableSubschemas.includes(uniqueSubschema)) {\n        const existingSubschema = delegationMap.get(uniqueSubschema);\n        if (existingSubschema != null) {\n          existingSubschema.push(selection);\n        } else {\n          delegationMap.set(uniqueSubschema, [selection]);\n        }\n      } else {\n        unproxiableSelections.push(selection);\n      }\n    } else {\n      // 2b. use nonUniqueFields to assign to a possible subschema,\n      //     preferring one of the subschemas already targets of delegation\n\n      let nonUniqueSubschemas: Array<SubschemaConfig> =\n        nonUniqueFields[selection.name.value];\n      nonUniqueSubschemas = nonUniqueSubschemas.filter((s) =>\n        proxiableSubschemas.includes(s),\n      );\n      if (nonUniqueSubschemas != null) {\n        const subschemas: Array<SubschemaConfig> = Array.from(\n          delegationMap.keys(),\n        );\n        const existingSubschema = nonUniqueSubschemas.find((s) =>\n          subschemas.includes(s),\n        );\n        if (existingSubschema != null) {\n          delegationMap.get(existingSubschema).push(selection);\n        } else {\n          delegationMap.set(nonUniqueSubschemas[0], [selection]);\n        }\n      } else {\n        unproxiableSelections.push(selection);\n      }\n    }\n  });\n\n  return {\n    delegationMap,\n    unproxiableSelections,\n    proxiableSubschemas,\n    nonProxiableSubschemas,\n  };\n}\n\nexport function mergeFields(\n  mergedTypeInfo: MergedTypeInfo,\n  typeName: string,\n  object: any,\n  originalSelections: Array<FieldNode>,\n  sourceSubschemas: Array<SubschemaConfig>,\n  targetSubschemas: Array<SubschemaConfig>,\n  context: Record<string, any>,\n  info: IGraphQLToolsResolveInfo,\n): any {\n  if (!originalSelections.length) {\n    return object;\n  }\n\n  const {\n    delegationMap,\n    unproxiableSelections,\n    proxiableSubschemas,\n    nonProxiableSubschemas,\n  } = buildDelegationPlan(\n    mergedTypeInfo,\n    originalSelections,\n    sourceSubschemas,\n    targetSubschemas,\n  );\n\n  if (!delegationMap.size) {\n    return object;\n  }\n\n  const maybePromises: Promise<any> | any = [];\n  delegationMap.forEach(\n    (selections: Array<SelectionNode>, s: SubschemaConfig) => {\n      const maybePromise = s.merge[typeName].resolve(object, context, info, s, {\n        kind: Kind.SELECTION_SET,\n        selections,\n      });\n      maybePromises.push(maybePromise);\n    },\n  );\n\n  let containsPromises = false;\n  for (const maybePromise of maybePromises) {\n    if (maybePromise instanceof Promise) {\n      containsPromises = true;\n      break;\n    }\n  }\n\n  return containsPromises\n    ? Promise.all(maybePromises).then((results) =>\n        mergeFields(\n          mergedTypeInfo,\n          typeName,\n          mergeProxiedResults(object, ...results),\n          unproxiableSelections,\n          sourceSubschemas.concat(proxiableSubschemas),\n          nonProxiableSubschemas,\n          context,\n          info,\n        ),\n      )\n    : mergeFields(\n        mergedTypeInfo,\n        typeName,\n        mergeProxiedResults(object, ...maybePromises),\n        unproxiableSelections,\n        sourceSubschemas.concat(proxiableSubschemas),\n        nonProxiableSubschemas,\n        context,\n        info,\n      );\n}\n","import {\n  GraphQLCompositeType,\n  GraphQLError,\n  GraphQLSchema,\n  isAbstractType,\n  FieldNode,\n  GraphQLObjectType,\n} from 'graphql';\nimport { collectFields, ExecutionContext } from 'graphql/execution/execute';\n\nimport {\n  SubschemaConfig,\n  IGraphQLToolsResolveInfo,\n  MergedTypeInfo,\n  isSubschemaConfig,\n} from '../../Interfaces';\nimport { setErrors, relocatedError } from '../../stitch/errors';\nimport { setObjectSubschema } from '../../stitch/subSchema';\nimport resolveFromParentTypename from '../../stitch/resolveFromParentTypename';\nimport { mergeFields } from '../../stitch/mergeFields';\n\nexport function handleObject(\n  type: GraphQLCompositeType,\n  object: any,\n  errors: ReadonlyArray<GraphQLError>,\n  subschema: GraphQLSchema | SubschemaConfig,\n  context: Record<string, any>,\n  info: IGraphQLToolsResolveInfo,\n  skipTypeMerging?: boolean,\n) {\n  setErrors(\n    object,\n    errors.map((error) =>\n      relocatedError(\n        error,\n        error.nodes,\n        error.path != null ? error.path.slice(1) : undefined,\n      ),\n    ),\n  );\n\n  setObjectSubschema(object, subschema);\n\n  if (skipTypeMerging || !info.mergeInfo) {\n    return object;\n  }\n\n  const typeName = isAbstractType(type)\n    ? info.schema.getTypeMap()[resolveFromParentTypename(object)].name\n    : type.name;\n  const mergedTypeInfo = info.mergeInfo.mergedTypes[typeName];\n  let targetSubschemas: Array<SubschemaConfig>;\n\n  if (mergedTypeInfo != null) {\n    targetSubschemas = mergedTypeInfo.subschemas;\n  }\n\n  if (!targetSubschemas) {\n    return object;\n  }\n\n  targetSubschemas = targetSubschemas.filter((s) => s !== subschema);\n  if (!targetSubschemas.length) {\n    return object;\n  }\n\n  const subFields = collectSubFields(info, object.__typename);\n\n  const selections = getFieldsNotInSubschema(\n    subFields,\n    subschema,\n    mergedTypeInfo,\n    object.__typename,\n  );\n\n  return mergeFields(\n    mergedTypeInfo,\n    typeName,\n    object,\n    selections,\n    [subschema as SubschemaConfig],\n    targetSubschemas,\n    context,\n    info,\n  );\n}\n\nfunction collectSubFields(info: IGraphQLToolsResolveInfo, typeName: string) {\n  let subFieldNodes: Record<string, Array<FieldNode>> = Object.create(null);\n  const visitedFragmentNames = Object.create(null);\n  info.fieldNodes.forEach((fieldNode) => {\n    subFieldNodes = collectFields(\n      ({\n        schema: info.schema,\n        variableValues: info.variableValues,\n        fragments: info.fragments,\n      } as unknown) as ExecutionContext,\n      info.schema.getType(typeName) as GraphQLObjectType,\n      fieldNode.selectionSet,\n      subFieldNodes,\n      visitedFragmentNames,\n    );\n  });\n  return subFieldNodes;\n}\n\nfunction getFieldsNotInSubschema(\n  subFieldNodes: Record<string, Array<FieldNode>>,\n  subschema: GraphQLSchema | SubschemaConfig,\n  mergedTypeInfo: MergedTypeInfo,\n  typeName: string,\n): Array<FieldNode> {\n  const typeMap = isSubschemaConfig(subschema)\n    ? mergedTypeInfo.typeMaps.get(subschema)\n    : subschema.getTypeMap();\n  const fields = (typeMap[typeName] as GraphQLObjectType).getFields();\n\n  const fieldsNotInSchema: Array<FieldNode> = [];\n  Object.keys(subFieldNodes).forEach((responseName) => {\n    subFieldNodes[responseName].forEach((subFieldNode) => {\n      if (!fields[subFieldNode.name.value]) {\n        fieldsNotInSchema.push(subFieldNode);\n      }\n    });\n  });\n\n  return fieldsNotInSchema;\n}\n","import {\n  GraphQLList,\n  GraphQLSchema,\n  GraphQLError,\n  getNullableType,\n  GraphQLType,\n  responsePathAsArray,\n  isLeafType,\n  isCompositeType,\n  isListType,\n} from 'graphql';\n\nimport { SubschemaConfig, IGraphQLToolsResolveInfo } from '../../Interfaces';\nimport { getErrorsByPathSegment } from '../../stitch/errors';\n\nimport { handleNull } from './handleNull';\nimport { handleObject } from './handleObject';\n\nexport function handleList(\n  type: GraphQLList<any>,\n  list: Array<any>,\n  errors: ReadonlyArray<GraphQLError>,\n  subschema: GraphQLSchema | SubschemaConfig,\n  context: Record<string, any>,\n  info: IGraphQLToolsResolveInfo,\n  skipTypeMerging?: boolean,\n) {\n  const childErrors = getErrorsByPathSegment(errors);\n\n  return list.map((listMember, index) =>\n    handleListMember(\n      getNullableType(type.ofType),\n      listMember,\n      index,\n      childErrors[index] != null ? childErrors[index] : [],\n      subschema,\n      context,\n      info,\n      skipTypeMerging,\n    ),\n  );\n}\n\nfunction handleListMember(\n  type: GraphQLType,\n  listMember: any,\n  index: number,\n  errors: ReadonlyArray<GraphQLError>,\n  subschema: GraphQLSchema | SubschemaConfig,\n  context: Record<string, any>,\n  info: IGraphQLToolsResolveInfo,\n  skipTypeMerging?: boolean,\n): any {\n  if (listMember == null) {\n    return handleNull(\n      info.fieldNodes,\n      [...responsePathAsArray(info.path), index],\n      errors,\n    );\n  }\n\n  if (isLeafType(type)) {\n    return type.parseValue(listMember);\n  } else if (isCompositeType(type)) {\n    return handleObject(\n      type,\n      listMember,\n      errors,\n      subschema,\n      context,\n      info,\n      skipTypeMerging,\n    );\n  } else if (isListType(type)) {\n    return handleList(\n      type,\n      listMember,\n      errors,\n      subschema,\n      context,\n      info,\n      skipTypeMerging,\n    );\n  }\n}\n","import {\n  GraphQLResolveInfo,\n  responsePathAsArray,\n  getNullableType,\n  isCompositeType,\n  isLeafType,\n  isListType,\n  ExecutionResult,\n  GraphQLError,\n  GraphQLOutputType,\n  GraphQLSchema,\n} from 'graphql';\n\nimport { SubschemaConfig, IGraphQLToolsResolveInfo } from '../Interfaces';\nimport { getResponseKeyFromInfo } from '../stitch/getResponseKeyFromInfo';\n\nimport { handleNull } from './results/handleNull';\nimport { handleObject } from './results/handleObject';\nimport { handleList } from './results/handleList';\n\nexport function checkResultAndHandleErrors(\n  result: ExecutionResult,\n  context: Record<string, any>,\n  info: GraphQLResolveInfo,\n  responseKey: string = getResponseKeyFromInfo(info),\n  subschema?: GraphQLSchema | SubschemaConfig,\n  returnType: GraphQLOutputType = info.returnType,\n  skipTypeMerging?: boolean,\n): any {\n  const errors = result.errors != null ? result.errors : [];\n  const data = result.data != null ? result.data[responseKey] : undefined;\n\n  return handleResult(\n    data,\n    errors,\n    subschema,\n    context,\n    info,\n    returnType,\n    skipTypeMerging,\n  );\n}\n\nexport function handleResult(\n  result: any,\n  errors: ReadonlyArray<GraphQLError>,\n  subschema: GraphQLSchema | SubschemaConfig,\n  context: Record<string, any>,\n  info: IGraphQLToolsResolveInfo,\n  returnType = info.returnType,\n  skipTypeMerging?: boolean,\n): any {\n  const type = getNullableType(returnType);\n\n  if (result == null) {\n    return handleNull(info.fieldNodes, responsePathAsArray(info.path), errors);\n  }\n\n  if (isLeafType(type)) {\n    return type.parseValue(result);\n  } else if (isCompositeType(type)) {\n    return handleObject(\n      type,\n      result,\n      errors,\n      subschema,\n      context,\n      info,\n      skipTypeMerging,\n    );\n  } else if (isListType(type)) {\n    return handleList(\n      type,\n      result,\n      errors,\n      subschema,\n      context,\n      info,\n      skipTypeMerging,\n    );\n  }\n}\n","import { GraphQLSchema, GraphQLOutputType } from 'graphql';\n\nimport { checkResultAndHandleErrors } from '../../delegate/checkResultAndHandleErrors';\nimport {\n  Transform,\n  SubschemaConfig,\n  IGraphQLToolsResolveInfo,\n} from '../../Interfaces';\n\nexport default class CheckResultAndHandleErrors implements Transform {\n  private readonly context?: Record<string, any>;\n  private readonly info: IGraphQLToolsResolveInfo;\n  private readonly fieldName?: string;\n  private readonly subschema?: GraphQLSchema | SubschemaConfig;\n  private readonly returnType?: GraphQLOutputType;\n  private readonly typeMerge?: boolean;\n\n  constructor(\n    info: IGraphQLToolsResolveInfo,\n    fieldName?: string,\n    subschema?: GraphQLSchema | SubschemaConfig,\n    context?: Record<string, any>,\n    returnType: GraphQLOutputType = info.returnType,\n    typeMerge?: boolean,\n  ) {\n    this.context = context;\n    this.info = info;\n    this.fieldName = fieldName;\n    this.subschema = subschema;\n    this.returnType = returnType;\n    this.typeMerge = typeMerge;\n  }\n\n  public transformResult(result: any): any {\n    return checkResultAndHandleErrors(\n      result,\n      this.context != null ? this.context : {},\n      this.info,\n      this.fieldName,\n      this.subschema,\n      this.returnType,\n      this.typeMerge,\n    );\n  }\n}\n","import {\n  isNonNullType,\n  Kind,\n  GraphQLType,\n  TypeNode,\n  isListType,\n} from 'graphql';\n\nexport function astFromType(type: GraphQLType): TypeNode {\n  if (isNonNullType(type)) {\n    const innerType = astFromType(type.ofType);\n    if (innerType.kind === Kind.NON_NULL_TYPE) {\n      throw new Error(\n        `Invalid type node ${JSON.stringify(\n          type,\n        )}. Inner type of non-null type cannot be a non-null type.`,\n      );\n    }\n    return {\n      kind: Kind.NON_NULL_TYPE,\n      type: innerType,\n    };\n  } else if (isListType(type)) {\n    return {\n      kind: Kind.LIST_TYPE,\n      type: astFromType(type.ofType),\n    };\n  }\n\n  return {\n    kind: Kind.NAMED_TYPE,\n    name: {\n      kind: Kind.NAME,\n      value: type.name,\n    },\n  };\n}\n","import {\n  GraphQLInputType,\n  ArgumentNode,\n  VariableDefinitionNode,\n  Kind,\n} from 'graphql';\n\nimport { astFromType } from './astFromType';\n\nexport function updateArgument(\n  argName: string,\n  argType: GraphQLInputType,\n  argumentNodes: Record<string, ArgumentNode>,\n  variableDefinitionsMap: Record<string, VariableDefinitionNode>,\n  variableValues: Record<string, any>,\n  newArg: any,\n): void {\n  let varName;\n  let numGeneratedVariables = 0;\n  do {\n    varName = `_v${(numGeneratedVariables++).toString()}_${argName}`;\n  } while (variableDefinitionsMap[varName] != null);\n\n  argumentNodes[argName] = {\n    kind: Kind.ARGUMENT,\n    name: {\n      kind: Kind.NAME,\n      value: argName,\n    },\n    value: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: varName,\n      },\n    },\n  };\n  variableDefinitionsMap[varName] = {\n    kind: Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: varName,\n      },\n    },\n    type: astFromType(argType),\n  };\n\n  variableValues[varName] = newArg;\n}\n","import {\n  ArgumentNode,\n  DocumentNode,\n  FragmentDefinitionNode,\n  GraphQLArgument,\n  GraphQLField,\n  GraphQLObjectType,\n  GraphQLSchema,\n  Kind,\n  OperationDefinitionNode,\n  SelectionNode,\n  VariableDefinitionNode,\n} from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\nimport { serializeInputValue } from '../../utils/index';\nimport { updateArgument } from '../../utils/updateArgument';\n\nexport default class AddArgumentsAsVariables implements Transform {\n  private readonly targetSchema: GraphQLSchema;\n  private readonly args: { [key: string]: any };\n\n  constructor(targetSchema: GraphQLSchema, args: { [key: string]: any }) {\n    this.targetSchema = targetSchema;\n    this.args = args;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const { document, newVariables } = addVariablesToRootField(\n      this.targetSchema,\n      originalRequest,\n      this.args,\n    );\n\n    return {\n      document,\n      variables: newVariables,\n    };\n  }\n}\n\nfunction addVariablesToRootField(\n  targetSchema: GraphQLSchema,\n  originalRequest: Request,\n  args: { [key: string]: any },\n): {\n  document: DocumentNode;\n  newVariables: { [key: string]: any };\n} {\n  const document = originalRequest.document;\n  const variableValues = originalRequest.variables;\n\n  const operations: Array<OperationDefinitionNode> = document.definitions.filter(\n    (def) => def.kind === Kind.OPERATION_DEFINITION,\n  ) as Array<OperationDefinitionNode>;\n  const fragments: Array<FragmentDefinitionNode> = document.definitions.filter(\n    (def) => def.kind === Kind.FRAGMENT_DEFINITION,\n  ) as Array<FragmentDefinitionNode>;\n\n  const newOperations = operations.map((operation: OperationDefinitionNode) => {\n    const variableDefinitionMap = {};\n    operation.variableDefinitions.forEach((def) => {\n      const varName = def.variable.name.value;\n      variableDefinitionMap[varName] = def;\n    });\n\n    let type: GraphQLObjectType | null | undefined;\n    if (operation.operation === 'subscription') {\n      type = targetSchema.getSubscriptionType();\n    } else if (operation.operation === 'mutation') {\n      type = targetSchema.getMutationType();\n    } else {\n      type = targetSchema.getQueryType();\n    }\n    const newSelectionSet: Array<SelectionNode> = [];\n\n    operation.selectionSet.selections.forEach((selection: SelectionNode) => {\n      if (selection.kind === Kind.FIELD) {\n        const argumentNodes = selection.arguments;\n        const argumentNodeMap: Record<string, ArgumentNode> = {};\n        argumentNodes.forEach((argument: ArgumentNode) => {\n          argumentNodeMap[argument.name.value] = argument;\n        });\n\n        const targetField = type.getFields()[selection.name.value];\n\n        // excludes __typename\n        if (targetField != null) {\n          updateArguments(\n            targetField,\n            argumentNodeMap,\n            variableDefinitionMap,\n            variableValues,\n            args,\n          );\n        }\n\n        newSelectionSet.push({\n          ...selection,\n          arguments: Object.keys(argumentNodeMap).map(\n            (argName) => argumentNodeMap[argName],\n          ),\n        });\n      } else {\n        newSelectionSet.push(selection);\n      }\n    });\n\n    return {\n      ...operation,\n      variableDefinitions: Object.keys(variableDefinitionMap).map(\n        (varName) => variableDefinitionMap[varName],\n      ),\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: newSelectionSet,\n      },\n    };\n  });\n\n  return {\n    document: {\n      ...document,\n      definitions: [...newOperations, ...fragments],\n    },\n    newVariables: variableValues,\n  };\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nfunction updateArguments(\n  targetField: GraphQLField<any, any>,\n  argumentNodeMap: Record<string, ArgumentNode>,\n  variableDefinitionMap: Record<string, VariableDefinitionNode>,\n  variableValues: Record<string, any>,\n  newArgs: Record<string, any>,\n): void {\n  targetField.args.forEach((argument: GraphQLArgument) => {\n    const argName = argument.name;\n    const argType = argument.type;\n\n    if (hasOwn.call(newArgs, argName)) {\n      updateArgument(\n        argName,\n        argType,\n        argumentNodeMap,\n        variableDefinitionMap,\n        variableValues,\n        serializeInputValue(argType, newArgs[argName]),\n      );\n    }\n  });\n}\n","import { GraphQLSchema } from 'graphql';\n\nimport { Request, Transform } from '../Interfaces';\nimport { cloneSchema } from '../utils/index';\n\nexport function applySchemaTransforms(\n  originalSchema: GraphQLSchema,\n  transforms: Array<Transform>,\n): GraphQLSchema {\n  return transforms.reduce(\n    (schema: GraphQLSchema, transform: Transform) =>\n      transform.transformSchema != null\n        ? transform.transformSchema(cloneSchema(schema))\n        : schema,\n    originalSchema,\n  );\n}\n\nexport function applyRequestTransforms(\n  originalRequest: Request,\n  transforms: Array<Transform>,\n): Request {\n  return transforms.reduce(\n    (request: Request, transform: Transform) =>\n      transform.transformRequest != null\n        ? transform.transformRequest(request)\n        : request,\n\n    originalRequest,\n  );\n}\n\nexport function applyResultTransforms(\n  originalResult: any,\n  transforms: Array<Transform>,\n): any {\n  return transforms.reduceRight(\n    (result: any, transform: Transform) =>\n      transform.transformResult != null\n        ? transform.transformResult(result)\n        : result,\n    originalResult,\n  );\n}\n","import { ApolloLink, toPromise, execute, ExecutionResult } from 'apollo-link';\n\nimport { Fetcher, IFetcherOperation } from '../Interfaces';\n\nexport { execute } from 'apollo-link';\n\nexport default function linkToFetcher(link: ApolloLink): Fetcher {\n  return (fetcherOperation: IFetcherOperation): Promise<ExecutionResult> =>\n    toPromise(execute(link, fetcherOperation));\n}\n","import { Observable } from 'apollo-link';\nimport { $$asyncIterator } from 'iterall';\n\ntype Callback = (value?: any) => any;\n\nexport function observableToAsyncIterable<T>(\n  observable: Observable<T>,\n): AsyncIterator<T> & {\n  [$$asyncIterator]: () => AsyncIterator<T>;\n} {\n  const pullQueue: Array<Callback> = [];\n  const pushQueue: Array<any> = [];\n\n  let listening = true;\n\n  const pushValue = (value: any) => {\n    if (pullQueue.length !== 0) {\n      pullQueue.shift()({ value, done: false });\n    } else {\n      pushQueue.push({ value });\n    }\n  };\n\n  const pushError = (error: any) => {\n    if (pullQueue.length !== 0) {\n      pullQueue.shift()({ value: { errors: [error] }, done: false });\n    } else {\n      pushQueue.push({ value: { errors: [error] } });\n    }\n  };\n\n  const pullValue = () =>\n    new Promise((resolve) => {\n      if (pushQueue.length !== 0) {\n        const element = pushQueue.shift();\n        // either {value: {errors: [...]}} or {value: ...}\n        resolve({\n          ...element,\n          done: false,\n        });\n      } else {\n        pullQueue.push(resolve);\n      }\n    });\n\n  const subscription = observable.subscribe({\n    next(value: any) {\n      pushValue(value);\n    },\n    error(err: Error) {\n      pushError(err);\n    },\n  });\n\n  const emptyQueue = () => {\n    if (listening) {\n      listening = false;\n      subscription.unsubscribe();\n      pullQueue.forEach((resolve) => resolve({ value: undefined, done: true }));\n      pullQueue.length = 0;\n      pushQueue.length = 0;\n    }\n  };\n\n  return {\n    next() {\n      return listening ? pullValue() : this.return();\n    },\n    return() {\n      emptyQueue();\n      return Promise.resolve({ value: undefined, done: true });\n    },\n    throw(error) {\n      emptyQueue();\n      return Promise.reject(error);\n    },\n    [$$asyncIterator]() {\n      return this;\n    },\n  };\n}\n","import { $$asyncIterator } from 'iterall';\n\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nexport default function mapAsyncIterator<T, U>(\n  iterator: AsyncIterator<T>,\n  callback: (value: T) => Promise<U> | U,\n  rejectCallback?: any,\n): AsyncIterator<U> {\n  let $return: any;\n  let abruptClose: any;\n\n  if (typeof iterator.return === 'function') {\n    $return = iterator.return;\n    abruptClose = (error: any) => {\n      const rethrow = () => Promise.reject(error);\n      return $return.call(iterator).then(rethrow, rethrow);\n    };\n  }\n\n  function mapResult(result: any) {\n    return result.done\n      ? result\n      : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n  }\n\n  let mapReject: any;\n  if (rejectCallback) {\n    // Capture rejectCallback to ensure it cannot be null.\n    const reject = rejectCallback;\n    mapReject = (error: any) =>\n      asyncMapValue(error, reject).then(iteratorResult, abruptClose);\n  }\n\n  return {\n    next() {\n      return iterator.next().then(mapResult, mapReject);\n    },\n    return() {\n      return $return\n        ? $return.call(iterator).then(mapResult, mapReject)\n        : Promise.resolve({ value: undefined, done: true });\n    },\n    throw(error: any) {\n      if (typeof iterator.throw === 'function') {\n        return iterator.throw(error).then(mapResult, mapReject);\n      }\n      return Promise.reject(error).catch(abruptClose);\n    },\n    [$$asyncIterator]() {\n      return this;\n    },\n  } as any;\n}\n\nfunction asyncMapValue<T, U>(\n  value: T,\n  callback: (value: T) => Promise<U> | U,\n): Promise<U> {\n  return new Promise((resolve) => resolve(callback(value)));\n}\n\nfunction iteratorResult<T>(value: T): IteratorResult<T> {\n  return { value, done: false };\n}\n","import {\n  ArgumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  Kind,\n  OperationDefinitionNode,\n  SelectionNode,\n  GraphQLSchema,\n  GraphQLObjectType,\n  OperationTypeNode,\n  typeFromAST,\n  NamedTypeNode,\n  GraphQLInputType,\n  GraphQLArgument,\n  VariableDefinitionNode,\n  SelectionSetNode,\n} from 'graphql';\n\nimport { ICreateRequestFromInfo, Request, ICreateRequest } from '../Interfaces';\nimport { serializeInputValue } from '../utils/index';\nimport { updateArgument } from '../utils/updateArgument';\n\nexport function getDelegatingOperation(\n  parentType: GraphQLObjectType,\n  schema: GraphQLSchema,\n): OperationTypeNode {\n  if (parentType === schema.getMutationType()) {\n    return 'mutation';\n  } else if (parentType === schema.getSubscriptionType()) {\n    return 'subscription';\n  }\n\n  return 'query';\n}\n\nexport function createRequestFromInfo({\n  info,\n  operation = getDelegatingOperation(info.parentType, info.schema),\n  fieldName = info.fieldName,\n  selectionSet,\n  fieldNodes,\n}: ICreateRequestFromInfo): Request {\n  return createRequest({\n    sourceSchema: info.schema,\n    sourceParentType: info.parentType,\n    sourceFieldName: info.fieldName,\n    fragments: info.fragments,\n    variableDefinitions: info.operation.variableDefinitions,\n    variableValues: info.variableValues,\n    targetOperation: operation,\n    targetFieldName: fieldName,\n    selectionSet,\n    fieldNodes:\n      selectionSet != null\n        ? undefined\n        : fieldNodes != null\n        ? fieldNodes\n        : info.fieldNodes,\n  });\n}\n\nexport function createRequest({\n  sourceSchema,\n  sourceParentType,\n  sourceFieldName,\n  fragments,\n  variableDefinitions,\n  variableValues,\n  targetOperation,\n  targetFieldName,\n  selectionSet,\n  fieldNodes,\n}: ICreateRequest): Request {\n  let argumentNodes: ReadonlyArray<ArgumentNode>;\n  let newSelectionSet: SelectionSetNode = selectionSet;\n  if (!selectionSet && fieldNodes != null) {\n    const selections: Array<SelectionNode> = fieldNodes.reduce(\n      (acc, fieldNode) =>\n        fieldNode.selectionSet != null\n          ? acc.concat(fieldNode.selectionSet.selections)\n          : acc,\n      [],\n    );\n\n    newSelectionSet = selections.length\n      ? {\n          kind: Kind.SELECTION_SET,\n          selections,\n        }\n      : undefined;\n\n    argumentNodes = fieldNodes[0].arguments;\n  } else {\n    argumentNodes = [];\n  }\n\n  const newVariables = {};\n  const variableDefinitionMap = {};\n  variableDefinitions.forEach((def) => {\n    const varName = def.variable.name.value;\n    variableDefinitionMap[varName] = def;\n    const varType = typeFromAST(\n      sourceSchema,\n      def.type as NamedTypeNode,\n    ) as GraphQLInputType;\n    newVariables[varName] = serializeInputValue(\n      varType,\n      variableValues[varName],\n    );\n  });\n\n  const argumentNodeMap: Record<string, ArgumentNode> = {};\n  argumentNodes.forEach((argument: ArgumentNode) => {\n    argumentNodeMap[argument.name.value] = argument;\n  });\n\n  updateArgumentsWithDefaults(\n    sourceParentType,\n    sourceFieldName,\n    argumentNodeMap,\n    variableDefinitionMap,\n    newVariables,\n  );\n\n  const rootfieldNode: FieldNode = {\n    kind: Kind.FIELD,\n    alias: null,\n    arguments: Object.keys(argumentNodeMap).map(\n      (argName) => argumentNodeMap[argName],\n    ),\n    selectionSet: newSelectionSet,\n    name: {\n      kind: Kind.NAME,\n      value: targetFieldName || fieldNodes[0].name.value,\n    },\n  };\n\n  const operationDefinition: OperationDefinitionNode = {\n    kind: Kind.OPERATION_DEFINITION,\n    operation: targetOperation,\n    variableDefinitions: Object.keys(variableDefinitionMap).map(\n      (varName) => variableDefinitionMap[varName],\n    ),\n    selectionSet: {\n      kind: Kind.SELECTION_SET,\n      selections: [rootfieldNode],\n    },\n  };\n\n  const fragmentDefinitions: Array<FragmentDefinitionNode> = Object.keys(\n    fragments,\n  ).map((fragmentName) => fragments[fragmentName]);\n\n  const document = {\n    kind: Kind.DOCUMENT,\n    definitions: [operationDefinition, ...fragmentDefinitions],\n  };\n\n  return {\n    document,\n    variables: newVariables,\n  };\n}\n\nfunction updateArgumentsWithDefaults(\n  sourceParentType: GraphQLObjectType,\n  sourceFieldName: string,\n  argumentNodeMap: Record<string, ArgumentNode>,\n  variableDefinitionMap: Record<string, VariableDefinitionNode>,\n  variableValues: Record<string, any>,\n): void {\n  const sourceField = sourceParentType.getFields()[sourceFieldName];\n  sourceField.args.forEach((argument: GraphQLArgument) => {\n    const argName = argument.name;\n    const sourceArgType = argument.type;\n\n    if (argumentNodeMap[argName] === undefined) {\n      const defaultValue = argument.defaultValue;\n\n      if (defaultValue !== undefined) {\n        updateArgument(\n          argName,\n          sourceArgType,\n          argumentNodeMap,\n          variableDefinitionMap,\n          variableValues,\n          serializeInputValue(sourceArgType, defaultValue),\n        );\n      }\n    }\n  });\n}\n","import { isAsyncIterable } from 'iterall';\nimport { ApolloLink, execute as executeLink } from 'apollo-link';\nimport {\n  subscribe,\n  execute,\n  validate,\n  GraphQLSchema,\n  ExecutionResult,\n  GraphQLOutputType,\n  isSchema,\n} from 'graphql';\n\nimport {\n  IDelegateToSchemaOptions,\n  IDelegateRequestOptions,\n  Fetcher,\n  Delegator,\n  SubschemaConfig,\n  isSubschemaConfig,\n  IGraphQLToolsResolveInfo,\n  Transform,\n} from '../Interfaces';\nimport ExpandAbstractTypes from '../wrap/transforms/ExpandAbstractTypes';\nimport FilterToSchema from '../wrap/transforms/FilterToSchema';\nimport AddReplacementSelectionSets from '../wrap/transforms/AddReplacementSelectionSets';\nimport AddReplacementFragments from '../wrap/transforms/AddReplacementFragments';\nimport AddMergedTypeSelectionSets from '../wrap/transforms/AddMergedTypeSelectionSets';\nimport AddTypenameToAbstract from '../wrap/transforms/AddTypenameToAbstract';\nimport CheckResultAndHandleErrors from '../wrap/transforms/CheckResultAndHandleErrors';\nimport AddArgumentsAsVariables from '../wrap/transforms/AddArgumentsAsVariables';\nimport {\n  applyRequestTransforms,\n  applyResultTransforms,\n} from '../wrap/transforms';\n\nimport linkToFetcher from '../stitch/linkToFetcher';\nimport { observableToAsyncIterable } from '../stitch/observableToAsyncIterable';\nimport mapAsyncIterator from '../stitch/mapAsyncIterator';\nimport { combineErrors } from '../stitch/errors';\n\nimport { createRequestFromInfo, getDelegatingOperation } from './createRequest';\n\nexport default function delegateToSchema(\n  options: IDelegateToSchemaOptions | GraphQLSchema,\n): any {\n  if (isSchema(options)) {\n    throw new Error(\n      'Passing positional arguments to delegateToSchema is deprecated. ' +\n        'Please pass named parameters instead.',\n    );\n  }\n\n  const {\n    info,\n    operation = getDelegatingOperation(info.parentType, info.schema),\n    fieldName = info.fieldName,\n    returnType = info.returnType,\n    selectionSet,\n    fieldNodes,\n  } = options;\n\n  const request = createRequestFromInfo({\n    info,\n    operation,\n    fieldName,\n    selectionSet,\n    fieldNodes,\n  });\n\n  return delegateRequest({\n    ...options,\n    request,\n    operation,\n    fieldName,\n    returnType,\n  });\n}\n\nfunction buildDelegationTransforms(\n  subschemaOrSubschemaConfig: GraphQLSchema | SubschemaConfig,\n  info: IGraphQLToolsResolveInfo,\n  context: Record<string, any>,\n  targetSchema: GraphQLSchema,\n  fieldName: string,\n  args: Record<string, any>,\n  returnType: GraphQLOutputType,\n  transforms: Array<Transform>,\n  skipTypeMerging: boolean,\n): Array<Transform> {\n  let delegationTransforms: Array<Transform> = [\n    new CheckResultAndHandleErrors(\n      info,\n      fieldName,\n      subschemaOrSubschemaConfig,\n      context,\n      returnType,\n      skipTypeMerging,\n    ),\n  ];\n\n  if (info.mergeInfo != null) {\n    delegationTransforms.push(\n      new AddReplacementSelectionSets(\n        info.schema,\n        info.mergeInfo.replacementSelectionSets,\n      ),\n      new AddMergedTypeSelectionSets(info.schema, info.mergeInfo.mergedTypes),\n    );\n  }\n\n  delegationTransforms = delegationTransforms.concat(transforms);\n\n  delegationTransforms.push(new ExpandAbstractTypes(info.schema, targetSchema));\n\n  if (info.mergeInfo != null) {\n    delegationTransforms.push(\n      new AddReplacementFragments(\n        targetSchema,\n        info.mergeInfo.replacementFragments,\n      ),\n    );\n  }\n\n  if (args != null) {\n    delegationTransforms.push(new AddArgumentsAsVariables(targetSchema, args));\n  }\n\n  delegationTransforms.push(\n    new FilterToSchema(targetSchema),\n    new AddTypenameToAbstract(targetSchema),\n  );\n\n  return delegationTransforms;\n}\n\nexport function delegateRequest({\n  request,\n  schema: subschemaOrSubschemaConfig,\n  rootValue,\n  info,\n  operation = getDelegatingOperation(info.parentType, info.schema),\n  fieldName = info.fieldName,\n  args,\n  returnType = info.returnType,\n  context,\n  transforms = [],\n  skipValidation,\n  skipTypeMerging,\n}: IDelegateRequestOptions): any {\n  let targetSchema: GraphQLSchema;\n  let targetRootValue: Record<string, any>;\n  let requestTransforms: Array<Transform> = transforms.slice();\n  let subschemaConfig: SubschemaConfig;\n\n  if (isSubschemaConfig(subschemaOrSubschemaConfig)) {\n    subschemaConfig = subschemaOrSubschemaConfig;\n    targetSchema = subschemaConfig.schema;\n    targetRootValue =\n      rootValue != null\n        ? rootValue\n        : subschemaConfig.rootValue != null\n        ? subschemaConfig.rootValue\n        : info.rootValue;\n    if (subschemaConfig.transforms != null) {\n      requestTransforms = requestTransforms.concat(subschemaConfig.transforms);\n    }\n  } else {\n    targetSchema = subschemaOrSubschemaConfig;\n    targetRootValue = rootValue != null ? rootValue : info.rootValue;\n  }\n\n  const delegationTransforms = buildDelegationTransforms(\n    subschemaOrSubschemaConfig,\n    info,\n    context,\n    targetSchema,\n    fieldName,\n    args,\n    returnType,\n    requestTransforms.reverse(),\n    skipTypeMerging,\n  );\n\n  const processedRequest = applyRequestTransforms(\n    request,\n    delegationTransforms,\n  );\n\n  if (!skipValidation) {\n    const errors = validate(targetSchema, processedRequest.document);\n    if (errors.length > 0) {\n      const combinedError: Error = combineErrors(errors);\n      throw combinedError;\n    }\n  }\n\n  if (operation === 'query' || operation === 'mutation') {\n    const executor = createExecutor(\n      targetSchema,\n      targetRootValue,\n      context,\n      subschemaConfig,\n    );\n\n    const executionResult:\n      | ExecutionResult\n      | Promise<ExecutionResult> = executor({\n      document: processedRequest.document,\n      context,\n      variables: processedRequest.variables,\n    });\n\n    if (executionResult instanceof Promise) {\n      return executionResult.then((originalResult: any) =>\n        applyResultTransforms(originalResult, delegationTransforms),\n      );\n    }\n    return applyResultTransforms(executionResult, delegationTransforms);\n  }\n\n  const subscriber = createSubscriber(\n    targetSchema,\n    targetRootValue,\n    context,\n    subschemaConfig,\n  );\n\n  return subscriber({\n    document: processedRequest.document,\n    context,\n    variables: processedRequest.variables,\n  }).then(\n    (\n      subscriptionResult:\n        | AsyncIterableIterator<ExecutionResult>\n        | ExecutionResult,\n    ) => {\n      if (isAsyncIterable(subscriptionResult)) {\n        // \"subscribe\" to the subscription result and map the result through the transforms\n        return mapAsyncIterator<ExecutionResult, any>(\n          subscriptionResult,\n          (result) => {\n            const transformedResult = applyResultTransforms(\n              result,\n              delegationTransforms,\n            );\n            // wrap with fieldName to return for an additional round of resolutioon\n            // with payload as rootValue\n            return {\n              [info.fieldName]: transformedResult,\n            };\n          },\n        );\n      }\n\n      return applyResultTransforms(subscriptionResult, delegationTransforms);\n    },\n  );\n}\n\nfunction createExecutor(\n  schema: GraphQLSchema,\n  rootValue: Record<string, any>,\n  context: Record<string, any>,\n  subschemaConfig?: SubschemaConfig,\n): Delegator {\n  let fetcher: Fetcher;\n  let targetRootValue: Record<string, any> = rootValue;\n  if (subschemaConfig != null) {\n    if (subschemaConfig.dispatcher != null) {\n      const dynamicLinkOrFetcher = subschemaConfig.dispatcher(context);\n      fetcher =\n        typeof dynamicLinkOrFetcher === 'function'\n          ? dynamicLinkOrFetcher\n          : linkToFetcher(dynamicLinkOrFetcher);\n    } else if (subschemaConfig.link != null) {\n      fetcher = linkToFetcher(subschemaConfig.link);\n    } else if (subschemaConfig.fetcher != null) {\n      fetcher = subschemaConfig.fetcher;\n    }\n\n    if (!fetcher && !rootValue && subschemaConfig.rootValue != null) {\n      targetRootValue = subschemaConfig.rootValue;\n    }\n  }\n\n  if (fetcher != null) {\n    return ({ document, context: graphqlContext, variables }) =>\n      fetcher({\n        query: document,\n        variables,\n        context: { graphqlContext },\n      });\n  }\n\n  return ({ document, context: graphqlContext, variables }) =>\n    execute({\n      schema,\n      document,\n      rootValue: targetRootValue,\n      contextValue: graphqlContext,\n      variableValues: variables,\n    });\n}\n\nfunction createSubscriber(\n  schema: GraphQLSchema,\n  rootValue: Record<string, any>,\n  context: Record<string, any>,\n  subschemaConfig?: SubschemaConfig,\n): Delegator {\n  let link: ApolloLink;\n  let targetRootValue: Record<string, any> = rootValue;\n\n  if (subschemaConfig != null) {\n    if (subschemaConfig.dispatcher != null) {\n      link = subschemaConfig.dispatcher(context) as ApolloLink;\n    } else if (subschemaConfig.link != null) {\n      link = subschemaConfig.link;\n    }\n\n    if (!link && !rootValue && subschemaConfig.rootValue != null) {\n      targetRootValue = subschemaConfig.rootValue;\n    }\n  }\n\n  if (link != null) {\n    return ({ document, context: graphqlContext, variables }) => {\n      const operation = {\n        query: document,\n        variables,\n        context: { graphqlContext },\n      };\n      const observable = executeLink(link, operation);\n      return observableToAsyncIterable(observable);\n    };\n  }\n\n  return ({ document, context: graphqlContext, variables }) =>\n    subscribe({\n      schema,\n      document,\n      rootValue: targetRootValue,\n      contextValue: graphqlContext,\n      variableValues: variables,\n    });\n}\n","// @schemaDefinition: A GraphQL type schema in shorthand\n// @resolvers: Definitions for resolvers to be merged with schema\nexport default class SchemaError extends Error {\n  public message: string;\n\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n","import {\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLSchema,\n  isAbstractType,\n} from 'graphql';\n\nimport SchemaError from './SchemaError';\n\n// If we have any union or interface types throw if no there is no resolveType or isTypeOf resolvers\nfunction checkForResolveTypeResolver(\n  schema: GraphQLSchema,\n  requireResolversForResolveType?: boolean,\n) {\n  Object.keys(schema.getTypeMap())\n    .map((typeName) => schema.getType(typeName))\n    .forEach((type: GraphQLUnionType | GraphQLInterfaceType) => {\n      if (!isAbstractType(type)) {\n        return;\n      }\n      if (!type.resolveType) {\n        if (!requireResolversForResolveType) {\n          return;\n        }\n        throw new SchemaError(\n          `Type \"${type.name}\" is missing a \"__resolveType\" resolver. Pass false into ` +\n            '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.',\n        );\n      }\n    });\n}\nexport default checkForResolveTypeResolver;\n","import {\n  GraphQLObjectType,\n  GraphQLSchema,\n  isObjectType,\n  isInterfaceType,\n} from 'graphql';\n\nimport { IResolvers } from '../Interfaces';\nimport { graphqlVersion } from '../utils/index';\n\nfunction extendResolversFromInterfaces(\n  schema: GraphQLSchema,\n  resolvers: IResolvers,\n) {\n  const typeNames = Object.keys({\n    ...schema.getTypeMap(),\n    ...resolvers,\n  });\n\n  const extendedResolvers: IResolvers = {};\n  typeNames.forEach((typeName) => {\n    const typeResolvers = resolvers[typeName];\n    const type = schema.getType(typeName);\n    if (\n      isObjectType(type) ||\n      (graphqlVersion() >= 15 && isInterfaceType(type))\n    ) {\n      const interfaceResolvers = (type as GraphQLObjectType)\n        .getInterfaces()\n        .map((iFace) => resolvers[iFace.name]);\n      extendedResolvers[typeName] = Object.assign(\n        {},\n        ...interfaceResolvers,\n        typeResolvers,\n      );\n    } else if (typeResolvers != null) {\n      extendedResolvers[typeName] = typeResolvers;\n    }\n  });\n\n  return extendedResolvers;\n}\n\nexport default extendResolversFromInterfaces;\n","import {\n  GraphQLField,\n  GraphQLEnumType,\n  GraphQLSchema,\n  isSchema,\n  isScalarType,\n  isEnumType,\n  isUnionType,\n  isInterfaceType,\n  isObjectType,\n} from 'graphql';\n\nimport {\n  IResolvers,\n  IResolverValidationOptions,\n  IAddResolversToSchemaOptions,\n} from '../Interfaces';\nimport {\n  parseInputValue,\n  serializeInputValue,\n  healSchema,\n  forEachField,\n  forEachDefaultValue,\n} from '../utils/index';\nimport { toConfig } from '../polyfills/index';\n\nimport SchemaError from './SchemaError';\nimport checkForResolveTypeResolver from './checkForResolveTypeResolver';\nimport extendResolversFromInterfaces from './extendResolversFromInterfaces';\n\nfunction addResolversToSchema(\n  schemaOrOptions: GraphQLSchema | IAddResolversToSchemaOptions,\n  legacyInputResolvers?: IResolvers,\n  legacyInputValidationOptions?: IResolverValidationOptions,\n): GraphQLSchema {\n  const options: IAddResolversToSchemaOptions = isSchema(schemaOrOptions)\n    ? {\n        schema: schemaOrOptions,\n        resolvers: legacyInputResolvers,\n        resolverValidationOptions: legacyInputValidationOptions,\n      }\n    : schemaOrOptions;\n\n  const {\n    schema,\n    resolvers: inputResolvers,\n    defaultFieldResolver,\n    resolverValidationOptions = {},\n    inheritResolversFromInterfaces = false,\n  } = options;\n\n  const {\n    allowResolversNotInSchema = false,\n    requireResolversForResolveType,\n  } = resolverValidationOptions;\n\n  const resolvers = inheritResolversFromInterfaces\n    ? extendResolversFromInterfaces(schema, inputResolvers)\n    : inputResolvers;\n\n  const typeMap = schema.getTypeMap();\n\n  Object.keys(resolvers).forEach((typeName) => {\n    const resolverValue = resolvers[typeName];\n    const resolverType = typeof resolverValue;\n\n    if (resolverType !== 'object' && resolverType !== 'function') {\n      throw new SchemaError(\n        `\"${typeName}\" defined in resolvers, but has invalid value \"${\n          resolverValue as string\n        }\". A resolver's value must be of type object or function.`,\n      );\n    }\n\n    const type = schema.getType(typeName);\n\n    if (!type && typeName !== '__schema') {\n      if (allowResolversNotInSchema) {\n        return;\n      }\n\n      throw new SchemaError(\n        `\"${typeName}\" defined in resolvers, but not in schema`,\n      );\n    }\n\n    if (isScalarType(type)) {\n      // Support -- without recommending -- overriding default scalar types\n      Object.keys(resolverValue).forEach((fieldName) => {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        } else {\n          type[fieldName] = resolverValue[fieldName];\n        }\n      });\n    } else if (isEnumType(type)) {\n      // We've encountered an enum resolver that is being used to provide an\n      // internal enum value.\n      // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values\n      Object.keys(resolverValue).forEach((fieldName) => {\n        if (!type.getValue(fieldName)) {\n          if (allowResolversNotInSchema) {\n            return;\n          }\n          throw new SchemaError(\n            `${typeName}.${fieldName} was defined in resolvers, but enum is not in schema`,\n          );\n        }\n      });\n\n      const config = toConfig(type);\n\n      const values = type.getValues();\n      const newValues = {};\n      values.forEach((value) => {\n        const newValue = Object.keys(resolverValue).includes(value.name)\n          ? resolverValue[value.name]\n          : value.name;\n        newValues[value.name] = {\n          value: newValue,\n          deprecationReason: value.deprecationReason,\n          description: value.description,\n          astNode: value.astNode,\n        };\n      });\n\n      // healSchema called later to update all fields to new type\n      typeMap[typeName] = new GraphQLEnumType({\n        ...config,\n        values: newValues,\n      });\n    } else if (isUnionType(type)) {\n      Object.keys(resolverValue).forEach((fieldName) => {\n        if (fieldName.startsWith('__')) {\n          // this is for isTypeOf and resolveType and all the other stuff.\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n          return;\n        }\n        if (allowResolversNotInSchema) {\n          return;\n        }\n\n        throw new SchemaError(\n          `${typeName} was defined in resolvers, but it's not an object`,\n        );\n      });\n    } else if (isObjectType(type) || isInterfaceType(type)) {\n      Object.keys(resolverValue).forEach((fieldName) => {\n        if (fieldName.startsWith('__')) {\n          // this is for isTypeOf and resolveType and all the other stuff.\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n          return;\n        }\n\n        const fields = type.getFields();\n        const field = fields[fieldName];\n\n        if (field == null) {\n          if (allowResolversNotInSchema) {\n            return;\n          }\n\n          throw new SchemaError(\n            `${typeName}.${fieldName} defined in resolvers, but not in schema`,\n          );\n        }\n\n        const fieldResolve = resolverValue[fieldName];\n        if (typeof fieldResolve === 'function') {\n          // for convenience. Allows shorter syntax in resolver definition file\n          field.resolve = fieldResolve;\n        } else {\n          if (typeof fieldResolve !== 'object') {\n            throw new SchemaError(\n              `Resolver ${typeName}.${fieldName} must be object or function`,\n            );\n          }\n          setFieldProperties(field, fieldResolve);\n        }\n      });\n    }\n  });\n\n  checkForResolveTypeResolver(schema, requireResolversForResolveType);\n\n  // serialize all default values prior to healing fields with new scalar/enum types.\n  forEachDefaultValue(schema, serializeInputValue);\n  // schema may have new scalar/enum types that require healing\n  healSchema(schema);\n  // reparse all default values with new parsing functions.\n  forEachDefaultValue(schema, parseInputValue);\n\n  if (defaultFieldResolver != null) {\n    forEachField(schema, (field) => {\n      if (!field.resolve) {\n        field.resolve = defaultFieldResolver;\n      }\n    });\n  }\n\n  return schema;\n}\n\nfunction setFieldProperties(\n  field: GraphQLField<any, any>,\n  propertiesObj: Record<string, any>,\n) {\n  Object.keys(propertiesObj).forEach((propertyName) => {\n    field[propertyName] = propertiesObj[propertyName];\n  });\n}\n\nexport default addResolversToSchema;\n","import {\n  defaultFieldResolver,\n  GraphQLSchema,\n  GraphQLFieldResolver,\n} from 'graphql';\n\n// wraps all resolvers of query, mutation or subscription fields\n// with the provided function to simulate a root schema level resolver\nfunction addSchemaLevelResolver(\n  schema: GraphQLSchema,\n  fn: GraphQLFieldResolver<any, any>,\n): void {\n  // TODO test that schema is a schema, fn is a function\n  const rootTypes = [\n    schema.getQueryType(),\n    schema.getMutationType(),\n    schema.getSubscriptionType(),\n  ].filter((x) => Boolean(x));\n  rootTypes.forEach((type) => {\n    if (type != null) {\n      // XXX this should run at most once per request to simulate a true root resolver\n      // for graphql-js this is an approximation that works with queries but not mutations\n      const rootResolveFn = runAtMostOncePerRequest(fn);\n      const fields = type.getFields();\n      Object.keys(fields).forEach((fieldName) => {\n        // XXX if the type is a subscription, a same query AST will be ran multiple times so we\n        // deactivate here the runOnce if it's a subscription. This may not be optimal though...\n        if (type === schema.getSubscriptionType()) {\n          fields[fieldName].resolve = wrapResolver(\n            fields[fieldName].resolve,\n            fn,\n          );\n        } else {\n          fields[fieldName].resolve = wrapResolver(\n            fields[fieldName].resolve,\n            rootResolveFn,\n          );\n        }\n      });\n    }\n  });\n}\n\n// XXX badly named function. this doesn't really wrap, it just chains resolvers...\nfunction wrapResolver(\n  innerResolver: GraphQLFieldResolver<any, any> | undefined,\n  outerResolver: GraphQLFieldResolver<any, any>,\n): GraphQLFieldResolver<any, any> {\n  return (obj, args, ctx, info) =>\n    Promise.resolve(outerResolver(obj, args, ctx, info)).then((root) => {\n      if (innerResolver != null) {\n        return innerResolver(root, args, ctx, info);\n      }\n      return defaultFieldResolver(root, args, ctx, info);\n    });\n}\n\n// XXX this function only works for resolvers\n// XXX very hacky way to remember if the function\n// already ran for this request. This will only work\n// if people don't actually cache the operation.\n// if they do cache the operation, they will have to\n// manually remove the __runAtMostOnce before every request.\nfunction runAtMostOncePerRequest(\n  fn: GraphQLFieldResolver<any, any>,\n): GraphQLFieldResolver<any, any> {\n  let value: any;\n  const randomNumber = Math.random();\n  return (root, args, ctx, info) => {\n    if (!info.operation['__runAtMostOnce']) {\n      info.operation['__runAtMostOnce'] = {};\n    }\n    if (!info.operation['__runAtMostOnce'][randomNumber]) {\n      info.operation['__runAtMostOnce'][randomNumber] = true;\n      value = fn(root, args, ctx, info);\n    }\n    return value;\n  };\n}\n\nexport default addSchemaLevelResolver;\n","import {\n  GraphQLSchema,\n  GraphQLField,\n  getNamedType,\n  isScalarType,\n} from 'graphql';\n\nimport { IResolverValidationOptions } from '../Interfaces';\nimport { forEachField } from '../utils/index';\n\nimport SchemaError from './SchemaError';\n\nfunction assertResolversPresent(\n  schema: GraphQLSchema,\n  resolverValidationOptions: IResolverValidationOptions = {},\n): void {\n  const {\n    requireResolversForArgs = false,\n    requireResolversForNonScalar = false,\n    requireResolversForAllFields = false,\n  } = resolverValidationOptions;\n\n  if (\n    requireResolversForAllFields &&\n    (requireResolversForArgs || requireResolversForNonScalar)\n  ) {\n    throw new TypeError(\n      'requireResolversForAllFields takes precedence over the more specific assertions. ' +\n        'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +\n        'requireResolversForNonScalar, but not a combination of them.',\n    );\n  }\n\n  forEachField(schema, (field, typeName, fieldName) => {\n    // requires a resolver for *every* field.\n    if (requireResolversForAllFields) {\n      expectResolver(field, typeName, fieldName);\n    }\n\n    // requires a resolver on every field that has arguments\n    if (requireResolversForArgs && field.args.length > 0) {\n      expectResolver(field, typeName, fieldName);\n    }\n\n    // requires a resolver on every field that returns a non-scalar type\n    if (\n      requireResolversForNonScalar &&\n      !isScalarType(getNamedType(field.type))\n    ) {\n      expectResolver(field, typeName, fieldName);\n    }\n  });\n}\n\nfunction expectResolver(\n  field: GraphQLField<any, any>,\n  typeName: string,\n  fieldName: string,\n) {\n  if (!field.resolve) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `Resolver missing for \"${typeName}.${fieldName}\". To disable this warning check https://github.com/apollostack/graphql-tools/issues/131`,\n    );\n    return;\n  }\n  if (typeof field.resolve !== 'function') {\n    throw new SchemaError(\n      `Resolver \"${typeName}.${fieldName}\" must be a function`,\n    );\n  }\n}\n\nexport default assertResolversPresent;\n","import { GraphQLSchema, GraphQLField, defaultFieldResolver } from 'graphql';\n\nimport { IDirectiveResolvers } from '../Interfaces';\nimport { SchemaDirectiveVisitor } from '../utils/SchemaDirectiveVisitor';\n\nfunction attachDirectiveResolvers(\n  schema: GraphQLSchema,\n  directiveResolvers: IDirectiveResolvers,\n) {\n  if (typeof directiveResolvers !== 'object') {\n    throw new Error(\n      `Expected directiveResolvers to be of type object, got ${typeof directiveResolvers}`,\n    );\n  }\n\n  if (Array.isArray(directiveResolvers)) {\n    throw new Error(\n      'Expected directiveResolvers to be of type object, got Array',\n    );\n  }\n\n  const schemaDirectives = Object.create(null);\n\n  Object.keys(directiveResolvers).forEach((directiveName) => {\n    schemaDirectives[directiveName] = class extends SchemaDirectiveVisitor {\n      public visitFieldDefinition(field: GraphQLField<any, any>) {\n        const resolver = directiveResolvers[directiveName];\n        const originalResolver =\n          field.resolve != null ? field.resolve : defaultFieldResolver;\n        const directiveArgs = this.args;\n        field.resolve = (...args) => {\n          const [source /* original args */, , context, info] = args;\n          return resolver(\n            () =>\n              new Promise((resolve, reject) => {\n                const result = originalResolver.apply(field, args);\n                if (result instanceof Error) {\n                  reject(result);\n                }\n                resolve(result);\n              }),\n            source,\n            directiveArgs,\n            context,\n            info,\n          );\n        };\n      }\n    };\n  });\n\n  SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n}\n\nexport default attachDirectiveResolvers;\n","import { deprecated } from 'deprecated-decorator';\nimport { GraphQLSchema, GraphQLFieldResolver, isSchema } from 'graphql';\n\nimport { IConnectors, IConnector, IConnectorCls } from '../Interfaces';\n\nimport addSchemaLevelResolver from './addSchemaLevelResolver';\n\n// takes a GraphQL-JS schema and an object of connectors, then attaches\n// the connectors to the context by wrapping each query or mutation resolve\n// function with a function that attaches connectors if they don't exist.\n// attaches connectors only once to make sure they are singletons\nconst attachConnectorsToContext = deprecated<Function>(\n  {\n    version: '0.7.0',\n    url: 'https://github.com/apollostack/graphql-tools/issues/140',\n  },\n  (schema: GraphQLSchema, connectors: IConnectors): void => {\n    if (!schema || !isSchema(schema)) {\n      throw new Error(\n        'schema must be an instance of GraphQLSchema. ' +\n          'This error could be caused by installing more than one version of GraphQL-JS',\n      );\n    }\n\n    if (typeof connectors !== 'object') {\n      const connectorType = typeof connectors;\n      throw new Error(\n        `Expected connectors to be of type object, got ${connectorType}`,\n      );\n    }\n    if (Object.keys(connectors).length === 0) {\n      throw new Error('Expected connectors to not be an empty object');\n    }\n    if (Array.isArray(connectors)) {\n      throw new Error('Expected connectors to be of type object, got Array');\n    }\n    if (schema['_apolloConnectorsAttached']) {\n      throw new Error(\n        'Connectors already attached to context, cannot attach more than once',\n      );\n    }\n    schema['_apolloConnectorsAttached'] = true;\n    const attachconnectorFn: GraphQLFieldResolver<any, any> = (\n      root,\n      _args,\n      ctx,\n    ) => {\n      if (typeof ctx !== 'object') {\n        // if in any way possible, we should throw an error when the attachconnectors\n        // function is called, not when a query is executed.\n        const contextType = typeof ctx;\n        throw new Error(\n          `Cannot attach connector because context is not an object: ${contextType}`,\n        );\n      }\n      if (typeof ctx.connectors === 'undefined') {\n        ctx.connectors = {};\n      }\n      Object.keys(connectors).forEach((connectorName) => {\n        const connector: IConnector = connectors[connectorName];\n        if (connector.prototype != null) {\n          ctx.connectors[connectorName] = new (connector as IConnectorCls)(ctx);\n        } else {\n          throw new Error('Connector must be a function or an class');\n        }\n      });\n      return root;\n    };\n    addSchemaLevelResolver(schema, attachconnectorFn);\n  },\n);\n\nexport default attachConnectorsToContext;\n","import { DocumentNode, DefinitionNode, Kind } from 'graphql';\n\nimport { graphqlVersion } from '../utils/index';\n\nexport function extractExtensionDefinitions(ast: DocumentNode) {\n  const extensionDefs = ast.definitions.filter(\n    (def: DefinitionNode) =>\n      def.kind === Kind.OBJECT_TYPE_EXTENSION ||\n      (graphqlVersion() >= 13 && def.kind === Kind.INTERFACE_TYPE_EXTENSION) ||\n      def.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION ||\n      def.kind === Kind.UNION_TYPE_EXTENSION ||\n      def.kind === Kind.ENUM_TYPE_EXTENSION ||\n      def.kind === Kind.SCALAR_TYPE_EXTENSION ||\n      def.kind === Kind.SCHEMA_EXTENSION,\n  );\n\n  return {\n    ...ast,\n    definitions: extensionDefs,\n  };\n}\n\nexport function filterExtensionDefinitions(ast: DocumentNode) {\n  const extensionDefs = ast.definitions.filter(\n    (def: DefinitionNode) =>\n      def.kind !== Kind.OBJECT_TYPE_EXTENSION &&\n      def.kind !== Kind.INTERFACE_TYPE_EXTENSION &&\n      def.kind !== Kind.INPUT_OBJECT_TYPE_EXTENSION &&\n      def.kind !== Kind.UNION_TYPE_EXTENSION &&\n      def.kind !== Kind.ENUM_TYPE_EXTENSION &&\n      def.kind !== Kind.SCALAR_TYPE_EXTENSION &&\n      def.kind !== Kind.SCHEMA_EXTENSION,\n  );\n\n  return {\n    ...ast,\n    definitions: extensionDefs,\n  };\n}\n","import { print, ASTNode } from 'graphql';\n\nimport { ITypedef } from '../Interfaces';\n\nimport SchemaError from './SchemaError';\n\nfunction concatenateTypeDefs(\n  typeDefinitionsAry: Array<ITypedef>,\n  calledFunctionRefs = [] as any,\n): string {\n  let resolvedTypeDefinitions: Array<string> = [];\n  typeDefinitionsAry.forEach((typeDef: ITypedef) => {\n    if (typeof typeDef === 'function') {\n      if (calledFunctionRefs.indexOf(typeDef) === -1) {\n        calledFunctionRefs.push(typeDef);\n        resolvedTypeDefinitions = resolvedTypeDefinitions.concat(\n          concatenateTypeDefs(typeDef(), calledFunctionRefs),\n        );\n      }\n    } else if (typeof typeDef === 'string') {\n      resolvedTypeDefinitions.push(typeDef.trim());\n    } else if ((typeDef as ASTNode).kind !== undefined) {\n      resolvedTypeDefinitions.push(print(typeDef).trim());\n    } else {\n      const type = typeof typeDef;\n      throw new SchemaError(\n        `typeDef array must contain only strings and functions, got ${type}`,\n      );\n    }\n  });\n  return uniq(resolvedTypeDefinitions.map((x) => x.trim())).join('\\n');\n}\n\nfunction uniq(array: Array<any>): Array<any> {\n  return array.reduce(\n    (accumulator, currentValue) =>\n      accumulator.indexOf(currentValue) === -1\n        ? [...accumulator, currentValue]\n        : accumulator,\n    [],\n  );\n}\n\nexport default concatenateTypeDefs;\n","import {\n  parse,\n  extendSchema,\n  buildASTSchema,\n  GraphQLSchema,\n  DocumentNode,\n  ASTNode,\n} from 'graphql';\n\nimport { ITypeDefinitions, GraphQLParseOptions } from '../Interfaces';\n\nimport {\n  extractExtensionDefinitions,\n  filterExtensionDefinitions,\n} from './extensionDefinitions';\nimport concatenateTypeDefs from './concatenateTypeDefs';\nimport SchemaError from './SchemaError';\n\nfunction buildSchemaFromTypeDefinitions(\n  typeDefinitions: ITypeDefinitions,\n  parseOptions?: GraphQLParseOptions,\n): GraphQLSchema {\n  // TODO: accept only array here, otherwise interfaces get confusing.\n  let myDefinitions = typeDefinitions;\n  let astDocument: DocumentNode;\n\n  if (isDocumentNode(typeDefinitions)) {\n    astDocument = typeDefinitions;\n  } else if (typeof myDefinitions !== 'string') {\n    if (!Array.isArray(myDefinitions)) {\n      const type = typeof myDefinitions;\n      throw new SchemaError(\n        `typeDefs must be a string, array or schema AST, got ${type}`,\n      );\n    }\n    myDefinitions = concatenateTypeDefs(myDefinitions);\n  }\n\n  if (typeof myDefinitions === 'string') {\n    astDocument = parse(myDefinitions, parseOptions);\n  }\n\n  const typesAst = filterExtensionDefinitions(astDocument);\n\n  const backcompatOptions = { commentDescriptions: true };\n  let schema: GraphQLSchema = buildASTSchema(typesAst, backcompatOptions);\n\n  const extensionsAst = extractExtensionDefinitions(astDocument);\n  if (extensionsAst.definitions.length > 0) {\n    schema = extendSchema(schema, extensionsAst, backcompatOptions);\n  }\n\n  return schema;\n}\n\nfunction isDocumentNode(\n  typeDefinitions: ITypeDefinitions,\n): typeDefinitions is DocumentNode {\n  return (typeDefinitions as ASTNode).kind !== undefined;\n}\n\nexport default buildSchemaFromTypeDefinitions;\n","import {\n  defaultFieldResolver,\n  GraphQLResolveInfo,\n  GraphQLFieldResolver,\n} from 'graphql';\n\nexport function chainResolvers(\n  resolvers: Array<GraphQLFieldResolver<any, any>>,\n) {\n  return (\n    root: any,\n    args: { [argName: string]: any },\n    ctx: any,\n    info: GraphQLResolveInfo,\n  ) =>\n    resolvers.reduce((prev, curResolver) => {\n      if (curResolver != null) {\n        return curResolver(prev, args, ctx, info);\n      }\n\n      return defaultFieldResolver(prev, args, ctx, info);\n    }, root);\n}\n","import { defaultFieldResolver, GraphQLFieldResolver } from 'graphql';\n\nimport { ILogger } from '../Interfaces';\n\n/*\n * fn: The function to decorate with the logger\n * logger: an object instance of type Logger\n * hint: an optional hint to add to the error's message\n */\nfunction decorateWithLogger(\n  fn: GraphQLFieldResolver<any, any>,\n  logger: ILogger,\n  hint: string,\n): GraphQLFieldResolver<any, any> {\n  const resolver = fn != null ? fn : defaultFieldResolver;\n\n  const logError = (e: Error) => {\n    // TODO: clone the error properly\n    const newE = new Error();\n    newE.stack = e.stack;\n    /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */\n    if (hint) {\n      newE['originalMessage'] = e.message;\n      newE['message'] = `Error in resolver ${hint}\\n${e.message}`;\n    }\n    logger.log(newE);\n  };\n\n  return (root, args, ctx, info) => {\n    try {\n      const result = resolver(root, args, ctx, info);\n      // If the resolver returns a Promise log any Promise rejects.\n      if (\n        result &&\n        typeof result.then === 'function' &&\n        typeof result.catch === 'function'\n      ) {\n        result.catch((reason: Error | string) => {\n          // make sure that it's an error we're logging.\n          const error = reason instanceof Error ? reason : new Error(reason);\n          logError(error);\n\n          // We don't want to leave an unhandled exception so pass on error.\n          return reason;\n        });\n      }\n      return result;\n    } catch (e) {\n      logError(e);\n      // we want to pass on the error, just in case.\n      throw e;\n    }\n  };\n}\n\nexport default decorateWithLogger;\n","import {\n  defaultFieldResolver,\n  GraphQLSchema,\n  GraphQLFieldResolver,\n} from 'graphql';\n\nimport { IExecutableSchemaDefinition, ILogger } from '../Interfaces';\nimport {\n  SchemaDirectiveVisitor,\n  forEachField,\n  mergeDeep,\n} from '../utils/index';\n\nimport attachDirectiveResolvers from './attachDirectiveResolvers';\nimport assertResolversPresent from './assertResolversPresent';\nimport addResolversToSchema from './addResolversToSchema';\nimport attachConnectorsToContext from './attachConnectorsToContext';\nimport addSchemaLevelResolver from './addSchemaLevelResolver';\nimport buildSchemaFromTypeDefinitions from './buildSchemaFromTypeDefinitions';\nimport decorateWithLogger from './decorateWithLogger';\nimport SchemaError from './SchemaError';\n\nexport function makeExecutableSchema<TContext = any>({\n  typeDefs,\n  resolvers = {},\n  connectors,\n  logger,\n  allowUndefinedInResolve = true,\n  resolverValidationOptions = {},\n  directiveResolvers,\n  schemaDirectives,\n  parseOptions = {},\n  inheritResolversFromInterfaces = false,\n}: IExecutableSchemaDefinition<TContext>) {\n  // Validate and clean up arguments\n  if (typeof resolverValidationOptions !== 'object') {\n    throw new SchemaError(\n      'Expected `resolverValidationOptions` to be an object',\n    );\n  }\n\n  if (!typeDefs) {\n    throw new SchemaError('Must provide typeDefs');\n  }\n\n  // We allow passing in an array of resolver maps, in which case we merge them\n  const resolverMap = Array.isArray(resolvers)\n    ? resolvers\n        .filter((resolverObj) => typeof resolverObj === 'object')\n        .reduce(mergeDeep, {})\n    : resolvers;\n\n  // Arguments are now validated and cleaned up\n\n  const schema = buildSchemaFromTypeDefinitions(typeDefs, parseOptions);\n\n  addResolversToSchema({\n    schema,\n    resolvers: resolverMap,\n    resolverValidationOptions,\n    inheritResolversFromInterfaces,\n  });\n\n  assertResolversPresent(schema, resolverValidationOptions);\n\n  if (!allowUndefinedInResolve) {\n    addCatchUndefinedToSchema(schema);\n  }\n\n  if (logger != null) {\n    addErrorLoggingToSchema(schema, logger);\n  }\n\n  if (typeof resolvers['__schema'] === 'function') {\n    // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\n    // not doing that now, because I'd have to rewrite a lot of tests.\n    addSchemaLevelResolver(\n      schema,\n      resolvers['__schema'] as GraphQLFieldResolver<any, any>,\n    );\n  }\n\n  if (connectors != null) {\n    // connectors are optional, at least for now. That means you can just import them in the resolve\n    // function if you want.\n    attachConnectorsToContext(schema, connectors);\n  }\n\n  if (directiveResolvers != null) {\n    attachDirectiveResolvers(schema, directiveResolvers);\n  }\n\n  if (schemaDirectives != null) {\n    SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n  }\n\n  return schema;\n}\n\nfunction decorateToCatchUndefined(\n  fn: GraphQLFieldResolver<any, any>,\n  hint: string,\n): GraphQLFieldResolver<any, any> {\n  const resolve = fn == null ? defaultFieldResolver : fn;\n  return (root, args, ctx, info) => {\n    const result = resolve(root, args, ctx, info);\n    if (typeof result === 'undefined') {\n      throw new Error(`Resolver for \"${hint}\" returned undefined`);\n    }\n    return result;\n  };\n}\n\nexport function addCatchUndefinedToSchema(schema: GraphQLSchema): void {\n  forEachField(schema, (field, typeName, fieldName) => {\n    const errorHint = `${typeName}.${fieldName}`;\n    field.resolve = decorateToCatchUndefined(field.resolve, errorHint);\n  });\n}\n\nexport function addErrorLoggingToSchema(\n  schema: GraphQLSchema,\n  logger?: ILogger,\n): void {\n  if (!logger) {\n    throw new Error('Must provide a logger');\n  }\n  if (typeof logger.log !== 'function') {\n    throw new Error('Logger.log must be a function');\n  }\n  forEachField(schema, (field, typeName, fieldName) => {\n    const errorHint = `${typeName}.${fieldName}`;\n    field.resolve = decorateWithLogger(field.resolve, logger, errorHint);\n  });\n}\n","import { GraphQLSchema, GraphQLFieldResolver } from 'graphql';\n\nimport {\n  IAddResolversToSchemaOptions,\n  IResolvers,\n  IResolverValidationOptions,\n} from '../Interfaces';\n\nimport addResolversToSchema from './addResolversToSchema';\nimport addSchemaLevelResolver from './addSchemaLevelResolver';\nimport assertResolversPresent from './assertResolversPresent';\n\nexport { addResolversToSchema, addSchemaLevelResolver, assertResolversPresent };\nexport { default as attachDirectiveResolvers } from './attachDirectiveResolvers';\nexport { default as attachConnectorsToContext } from './attachConnectorsToContext';\nexport { default as buildSchemaFromTypeDefinitions } from './buildSchemaFromTypeDefinitions';\nexport { chainResolvers } from './chainResolvers';\nexport { default as checkForResolveTypeResolver } from './checkForResolveTypeResolver';\nexport { default as concatenateTypeDefs } from './concatenateTypeDefs';\nexport { default as decorateWithLogger } from './decorateWithLogger';\nexport { default as extendResolversFromInterfaces } from './extendResolversFromInterfaces';\nexport {\n  extractExtensionDefinitions,\n  filterExtensionDefinitions,\n} from './extensionDefinitions';\nexport { default as SchemaError } from './SchemaError';\nexport * from './makeExecutableSchema';\n\n// These functions are preserved for backwards compatibility.\n// They are not simply rexported with new (old) names so as to allow\n// typedoc to annotate them.\nexport function addResolveFunctionsToSchema(\n  schemaOrOptions: GraphQLSchema | IAddResolversToSchemaOptions,\n  legacyInputResolvers?: IResolvers,\n  legacyInputValidationOptions?: IResolverValidationOptions,\n): GraphQLSchema {\n  return addResolversToSchema(\n    schemaOrOptions,\n    legacyInputResolvers,\n    legacyInputValidationOptions,\n  );\n}\n\nexport function addSchemaLevelResolveFunction(\n  schema: GraphQLSchema,\n  fn: GraphQLFieldResolver<any, any>,\n): void {\n  addSchemaLevelResolver(schema, fn);\n}\n\nexport function assertResolveFunctionsPresent(\n  schema: GraphQLSchema,\n  resolverValidationOptions: IResolverValidationOptions = {},\n): void {\n  assertResolversPresent(schema, resolverValidationOptions);\n}\n","/* eslint-disable import/no-nodejs-modules */\n\nimport { Readable } from 'stream';\n\nimport { ApolloLink, Observable, RequestHandler, fromError } from 'apollo-link';\nimport {\n  serializeFetchParameter,\n  selectURI,\n  parseAndCheckHttpResponse,\n  selectHttpOptionsAndBody,\n  createSignalIfSupported,\n  fallbackHttpConfig,\n  Body,\n  HttpOptions,\n  UriFunction,\n} from 'apollo-link-http-common';\nimport { DefinitionNode } from 'graphql';\nimport {\n  extractFiles,\n  isExtractableFile as defaultIsExtractableFile,\n} from 'extract-files';\nimport KnownLengthFormData, { AppendOptions } from 'form-data';\nimport fetch from 'node-fetch';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nclass FormData extends KnownLengthFormData {\n  private hasUnknowableLength: boolean;\n\n  constructor(options?: any) {\n    super(options);\n    this.hasUnknowableLength = false;\n  }\n\n  public append(\n    key: string,\n    value: any,\n    optionsOrFilename: AppendOptions | string = {},\n  ): void {\n    // allow filename as single option\n    const options: AppendOptions =\n      typeof optionsOrFilename === 'string'\n        ? { filename: optionsOrFilename }\n        : optionsOrFilename;\n\n    // empty or either doesn't have path or not an http response\n    if (\n      !options.knownLength &&\n      !Buffer.isBuffer(value) &&\n      typeof value !== 'string' &&\n      !value.path &&\n      !(value.readable && hasOwn.call(value, 'httpVersion'))\n    ) {\n      this.hasUnknowableLength = true;\n    }\n\n    super.append(key, value, options);\n  }\n\n  public getLength(\n    callback: (err: Error | null, length: number) => void,\n  ): void {\n    if (this.hasUnknowableLength) {\n      return null;\n    }\n\n    return super.getLength(callback);\n  }\n\n  public getLengthSync(): number {\n    if (this.hasUnknowableLength) {\n      return null;\n    }\n\n    // eslint-disable-next-line no-sync\n    return super.getLengthSync();\n  }\n}\n\nexport type Function = UriFunction;\nexport type Options = HttpOptions & {\n  /**\n   * If set to true, use the HTTP GET method for query operations. Mutations\n   * will still use the method specified in fetchOptions.method (which defaults\n   * to POST).\n   */\n  useGETForQueries?: boolean;\n  serializer?: (method: string) => any;\n  appendFile?: (form: FormData, index: string, file: File) => void;\n};\n// For backwards compatibility.\nexport { HttpOptions as FetchOptions };\n\ninterface File {\n  createReadStream?: () => Readable;\n  filename?: string;\n  mimetype?: string;\n  name?: string;\n}\n\nexport const createServerHttpLink = (linkOptions: Options = {}) => {\n  const {\n    uri = '/graphql',\n    fetch: customFetch = (fetch as unknown) as WindowOrWorkerGlobalScope['fetch'],\n    serializer: customSerializer = defaultSerializer,\n    appendFile: customAppendFile = defaultAppendFile,\n    includeExtensions,\n    useGETForQueries,\n    ...requestOptions\n  } = linkOptions;\n\n  const linkConfig = {\n    http: { includeExtensions },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers,\n  };\n\n  return new ApolloLink((operation) => {\n    let chosenURI = selectURI(operation, uri);\n\n    const context = operation.getContext();\n\n    // `apollographql-client-*` headers are automatically set if a\n    // `clientAwareness` object is found in the context. These headers are\n    // set first, followed by the rest of the headers pulled from\n    // `context.headers`. If desired, `apollographql-client-*` headers set by\n    // the `clientAwareness` object can be overridden by\n    // `apollographql-client-*` headers set in `context.headers`.\n    const clientAwarenessHeaders = {};\n    if (context.clientAwareness) {\n      const { name, version } = context.clientAwareness;\n      if (name) {\n        clientAwarenessHeaders['apollographql-client-name'] = name;\n      }\n      if (version) {\n        clientAwarenessHeaders['apollographql-client-version'] = version;\n      }\n    }\n\n    const contextHeaders = { ...clientAwarenessHeaders, ...context.headers };\n\n    const contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: contextHeaders,\n    };\n\n    // uses fallback, link, and then context to build options\n    const { options, body } = selectHttpOptionsAndBody(\n      operation,\n      fallbackHttpConfig,\n      linkConfig,\n      contextConfig,\n    );\n\n    let controller: AbortController;\n    if (!(options as any).signal) {\n      const { controller: _controller, signal } = createSignalIfSupported();\n      controller = _controller;\n      if ((controller as unknown) as boolean) {\n        (options as any).signal = signal;\n      }\n    }\n\n    // If requested, set method to GET if there are no mutations.\n    const definitionIsMutation = (d: DefinitionNode) =>\n      d.kind === 'OperationDefinition' && d.operation === 'mutation';\n\n    if (\n      useGETForQueries &&\n      !operation.query.definitions.some(definitionIsMutation)\n    ) {\n      options.method = 'GET';\n    }\n\n    if (options.method === 'GET') {\n      const { newURI, parseError } = rewriteURIForGET(chosenURI, body);\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    }\n\n    return new Observable((observer) => {\n      getFinalPromise(body)\n        .then((resolvedBody) => {\n          if (options.method !== 'GET') {\n            options.body = customSerializer(resolvedBody, customAppendFile);\n            if (options.body instanceof FormData) {\n              // Automatically set by fetch when the body is a FormData instance.\n              delete options.headers['content-type'];\n            }\n          }\n          return options;\n        })\n        .then((newOptions) => customFetch(chosenURI, newOptions))\n        .then((response) => {\n          operation.setContext({ response });\n          return response;\n        })\n        .then(parseAndCheckHttpResponse(operation))\n        .then((result) => {\n          // we have data and can send it to back up the link chain\n          observer.next(result);\n          observer.complete();\n          return result;\n        })\n        .catch((err) => {\n          // fetch was cancelled so it's already been cleaned up in the unsubscribe\n          if (err.name === 'AbortError') {\n            return;\n          }\n          // if it is a network error, BUT there is graphql result info\n          // fire the next observer before calling error\n          // this gives apollo-client (and react-apollo) the `graphqlErrors` and `networErrors`\n          // to pass to UI\n          // this should only happen if we *also* have data as part of the response key per\n          // the spec\n          if (err.result && err.result.errors && err.result.data) {\n            // if we don't call next, the UI can only show networkError because AC didn't\n            // get any graphqlErrors\n            // this is graphql execution result info (i.e errors and possibly data)\n            // this is because there is no formal spec how errors should translate to\n            // http status codes. So an auth error (401) could have both data\n            // from a public field, errors from a private field, and a status of 401\n            // {\n            //  user { // this will have errors\n            //    firstName\n            //  }\n            //  products { // this is public so will have data\n            //    cost\n            //  }\n            // }\n            //\n            // the result of above *could* look like this:\n            // {\n            //   data: { products: [{ cost: \"$10\" }] },\n            //   errors: [{\n            //      message: 'your session has timed out',\n            //      path: []\n            //   }]\n            // }\n            // status code of above would be a 401\n            // in the UI you want to show data where you can, errors as data where you can\n            // and use correct http status codes\n            observer.next(err.result);\n          }\n          observer.error(err);\n        });\n\n      return () => {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if ((controller as unknown) as boolean) {\n          controller.abort();\n        }\n      };\n    });\n  });\n};\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nfunction rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams: Array<string> = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if ('query' in body) {\n    addQueryParam('query', body.query);\n  }\n  if (body.operationName) {\n    addQueryParam('operationName', body.operationName);\n  }\n  if (body.variables != null) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        'Variables map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('variables', serializedVariables);\n  }\n  if (body.extensions != null) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        'Extensions map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('extensions', serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = '';\n  let preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf('#');\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join('&') + fragment;\n  return { newURI };\n}\n\nfunction getFinalPromise(object: any): Promise<any> {\n  return Promise.resolve(object).then((resolvedObject) => {\n    if (resolvedObject == null) {\n      return resolvedObject;\n    }\n\n    if (Array.isArray(resolvedObject)) {\n      return Promise.all(resolvedObject.map((o) => getFinalPromise(o)));\n    } else if (typeof resolvedObject === 'object') {\n      const keys = Object.keys(resolvedObject);\n      return Promise.all(\n        keys.map((key) => getFinalPromise(resolvedObject[key])),\n      ).then((awaitedValues) => {\n        for (let i = 0; i < keys.length; i++) {\n          resolvedObject[keys[i]] = awaitedValues[i];\n        }\n        return resolvedObject;\n      });\n    }\n\n    return resolvedObject;\n  });\n}\n\nfunction defaultSerializer(\n  body: any,\n  appendFile: (form: FormData, index: string, file: File) => void,\n): any {\n  const { clone, files } = extractFiles(\n    body,\n    undefined,\n    (value: any) => defaultIsExtractableFile(value) || value?.createReadStream,\n  );\n\n  const payload = serializeFetchParameter(clone, 'Payload');\n\n  if (!files.size) {\n    return payload;\n  }\n\n  // GraphQL multipart request spec:\n  // https://github.com/jaydenseric/graphql-multipart-request-spec\n\n  const form = new FormData();\n\n  form.append('operations', payload);\n\n  const map = {};\n  let i = 0;\n\n  files.forEach((paths: Array<string>) => {\n    map[++i] = paths;\n  });\n\n  form.append('map', JSON.stringify(map));\n\n  i = 0;\n  files.forEach((_paths: Array<string>, file: File) => {\n    appendFile(form, (++i).toString(), file);\n  });\n\n  return form;\n}\n\nfunction defaultAppendFile(form: FormData, index: string, file: File) {\n  if (file.createReadStream != null) {\n    form.append(index, file.createReadStream(), {\n      filename: file.filename,\n      contentType: file.mimetype,\n    });\n  } else {\n    form.append(index, file, file.name);\n  }\n}\n\nexport class ServerHttpLink extends ApolloLink {\n  public requester: RequestHandler;\n  constructor(opts?: HttpOptions) {\n    super(createServerHttpLink(opts).request);\n  }\n}\n","import {\n  graphql,\n  GraphQLSchema,\n  GraphQLObjectType,\n  GraphQLList,\n  GraphQLType,\n  GraphQLField,\n  GraphQLResolveInfo,\n  getNullableType,\n  getNamedType,\n  GraphQLNamedType,\n  GraphQLFieldResolver,\n  GraphQLNullableType,\n  isSchema,\n  isObjectType,\n  isUnionType,\n  isInterfaceType,\n  isListType,\n  isEnumType,\n  isAbstractType,\n} from 'graphql';\nimport { v4 as uuid } from 'uuid';\n\nimport { buildSchemaFromTypeDefinitions } from '../generate/index';\nimport { forEachField } from '../utils/index';\n\nimport {\n  IMocks,\n  IMockServer,\n  IMockOptions,\n  IMockFn,\n  IMockTypeFn,\n  ITypeDefinitions,\n} from '../Interfaces';\n\n/**\n * This function wraps addMocksToSchema for more convenience\n */\nfunction mockServer(\n  schema: GraphQLSchema | ITypeDefinitions,\n  mocks: IMocks,\n  preserveResolvers: boolean = false,\n): IMockServer {\n  let mySchema: GraphQLSchema;\n  if (!isSchema(schema)) {\n    // TODO: provide useful error messages here if this fails\n    mySchema = buildSchemaFromTypeDefinitions(schema);\n  } else {\n    mySchema = schema;\n  }\n\n  addMocksToSchema({ schema: mySchema, mocks, preserveResolvers });\n\n  return { query: (query, vars) => graphql(mySchema, query, {}, {}, vars) };\n}\n\nconst defaultMockMap: Map<string, IMockFn> = new Map();\ndefaultMockMap.set('Int', () => Math.round(Math.random() * 200) - 100);\ndefaultMockMap.set('Float', () => Math.random() * 200 - 100);\ndefaultMockMap.set('String', () => 'Hello World');\ndefaultMockMap.set('Boolean', () => Math.random() > 0.5);\ndefaultMockMap.set('ID', () => uuid());\n\n// TODO allow providing a seed such that lengths of list could be deterministic\n// this could be done by using casual to get a random list length if the casual\n// object is global.\nfunction addMocksToSchema({\n  schema,\n  mocks = {},\n  preserveResolvers = false,\n}: IMockOptions): void {\n  if (!schema) {\n    throw new Error('Must provide schema to mock');\n  }\n  if (!isSchema(schema)) {\n    throw new Error('Value at \"schema\" must be of type GraphQLSchema');\n  }\n  if (!isObject(mocks)) {\n    throw new Error('mocks must be of type Object');\n  }\n\n  // use Map internally, because that API is nicer.\n  const mockFunctionMap: Map<string, IMockFn> = new Map();\n  Object.keys(mocks).forEach((typeName) => {\n    mockFunctionMap.set(typeName, mocks[typeName]);\n  });\n\n  mockFunctionMap.forEach((mockFunction, mockTypeName) => {\n    if (typeof mockFunction !== 'function') {\n      throw new Error(`mockFunctionMap[${mockTypeName}] must be a function`);\n    }\n  });\n\n  const mockType = function (\n    type: GraphQLType,\n    _typeName?: string,\n    fieldName?: string,\n  ): GraphQLFieldResolver<any, any> {\n    // order of precendence for mocking:\n    // 1. if the object passed in already has fieldName, just use that\n    // --> if it's a function, that becomes your resolver\n    // --> if it's a value, the mock resolver will return that\n    // 2. if the nullableType is a list, recurse\n    // 2. if there's a mock defined for this typeName, that will be used\n    // 3. if there's no mock defined, use the default mocks for this type\n    return (\n      root: any,\n      args: { [key: string]: any },\n      context: any,\n      info: GraphQLResolveInfo,\n    ): any => {\n      // nullability doesn't matter for the purpose of mocking.\n      const fieldType = getNullableType(type) as GraphQLNullableType;\n      const namedFieldType = getNamedType(fieldType);\n\n      if (fieldName && root && typeof root[fieldName] !== 'undefined') {\n        let result: any;\n\n        // if we're here, the field is already defined\n        if (typeof root[fieldName] === 'function') {\n          result = root[fieldName](root, args, context, info);\n          if (result instanceof MockList) {\n            result = result.mock(\n              root,\n              args,\n              context,\n              info,\n              fieldType as GraphQLList<any>,\n              mockType,\n            );\n          }\n        } else {\n          result = root[fieldName];\n        }\n\n        // Now we merge the result with the default mock for this type.\n        // This allows overriding defaults while writing very little code.\n        if (mockFunctionMap.has(namedFieldType.name)) {\n          const mock = mockFunctionMap.get(namedFieldType.name);\n\n          result = mergeMocks(\n            mock.bind(null, root, args, context, info),\n            result,\n          );\n        }\n        return result;\n      }\n\n      if (isListType(fieldType)) {\n        return [\n          mockType(fieldType.ofType)(root, args, context, info),\n          mockType(fieldType.ofType)(root, args, context, info),\n        ];\n      }\n      if (mockFunctionMap.has(fieldType.name) && !isAbstractType(fieldType)) {\n        // the object passed doesn't have this field, so we apply the default mock\n        const mock = mockFunctionMap.get(fieldType.name);\n        return mock(root, args, context, info);\n      }\n      if (isObjectType(fieldType)) {\n        // objects don't return actual data, we only need to mock scalars!\n        return {};\n      }\n      // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type\n      // otherwise randomly pick a type from all implementation types\n      if (isAbstractType(fieldType)) {\n        let implementationType;\n        if (mockFunctionMap.has(fieldType.name)) {\n          const mock = mockFunctionMap.get(fieldType.name);\n          const interfaceMockObj = mock(root, args, context, info);\n          if (!interfaceMockObj || !interfaceMockObj.__typename) {\n            return Error(`Please return a __typename in \"${fieldType.name}\"`);\n          }\n          implementationType = schema.getType(interfaceMockObj.__typename);\n        } else {\n          const possibleTypes = schema.getPossibleTypes(fieldType);\n          implementationType = getRandomElement(possibleTypes);\n        }\n        return {\n          __typename: implementationType,\n          ...mockType(implementationType)(root, args, context, info),\n        };\n      }\n\n      if (isEnumType(fieldType)) {\n        return getRandomElement(fieldType.getValues()).value;\n      }\n\n      if (defaultMockMap.has(fieldType.name)) {\n        const defaultMock = defaultMockMap.get(fieldType.name);\n        return defaultMock(root, args, context, info);\n      }\n\n      // if we get to here, we don't have a value, and we don't have a mock for this type,\n      // we could return undefined, but that would be hard to debug, so we throw instead.\n      // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.\n      return Error(`No mock defined for type \"${fieldType.name}\"`);\n    };\n  };\n\n  forEachField(\n    schema,\n    (field: GraphQLField<any, any>, typeName: string, fieldName: string) => {\n      assignResolveType(field.type, preserveResolvers);\n      let mockResolver: GraphQLFieldResolver<any, any> = mockType(\n        field.type,\n        typeName,\n        fieldName,\n      );\n\n      // we have to handle the root mutation and root query types differently,\n      // because no resolver is called at the root.\n      const queryType = schema.getQueryType();\n      const isOnQueryType = queryType != null && queryType.name === typeName;\n\n      const mutationType = schema.getMutationType();\n      const isOnMutationType =\n        mutationType != null && mutationType.name === typeName;\n\n      if (isOnQueryType || isOnMutationType) {\n        if (mockFunctionMap.has(typeName)) {\n          const rootMock = mockFunctionMap.get(typeName);\n          // XXX: BUG in here, need to provide proper signature for rootMock.\n          if (\n            typeof rootMock(undefined, {}, {}, {} as any)[fieldName] ===\n            'function'\n          ) {\n            mockResolver = (\n              root: any,\n              args: { [key: string]: any },\n              context: any,\n              info: GraphQLResolveInfo,\n            ) => {\n              const updatedRoot = root ?? {}; // TODO: should we clone instead?\n              updatedRoot[fieldName] = rootMock(root, args, context, info)[\n                fieldName\n              ];\n              // XXX this is a bit of a hack to still use mockType, which\n              // lets you mock lists etc. as well\n              // otherwise we could just set field.resolve to rootMock()[fieldName]\n              // it's like pretending there was a resolver that ran before\n              // the root resolver.\n              return mockType(field.type, typeName, fieldName)(\n                updatedRoot,\n                args,\n                context,\n                info,\n              );\n            };\n          }\n        }\n      }\n      if (!preserveResolvers || !field.resolve) {\n        field.resolve = mockResolver;\n      } else {\n        const oldResolver = field.resolve;\n        field.resolve = (\n          rootObject: any,\n          args: { [key: string]: any },\n          context: any,\n          info: GraphQLResolveInfo,\n        ) =>\n          Promise.all([\n            mockResolver(rootObject, args, context, info),\n            oldResolver(rootObject, args, context, info),\n          ]).then((values) => {\n            const [mockedValue, resolvedValue] = values;\n\n            // In case we couldn't mock\n            if (mockedValue instanceof Error) {\n              // only if value was not resolved, populate the error.\n              if (undefined === resolvedValue) {\n                throw mockedValue;\n              }\n              return resolvedValue;\n            }\n\n            if (resolvedValue instanceof Date && mockedValue instanceof Date) {\n              return undefined !== resolvedValue ? resolvedValue : mockedValue;\n            }\n\n            if (isObject(mockedValue) && isObject(resolvedValue)) {\n              // Object.assign() won't do here, as we need to all properties, including\n              // the non-enumerable ones and defined using Object.defineProperty\n              const emptyObject = Object.create(\n                Object.getPrototypeOf(resolvedValue),\n              );\n              return copyOwnProps(emptyObject, resolvedValue, mockedValue);\n            }\n            return undefined !== resolvedValue ? resolvedValue : mockedValue;\n          });\n      }\n    },\n  );\n}\n\nfunction isObject(thing: any) {\n  return thing === Object(thing) && !Array.isArray(thing);\n}\n\n// returns a random element from that ary\nfunction getRandomElement(ary: ReadonlyArray<any>) {\n  const sample = Math.floor(Math.random() * ary.length);\n  return ary[sample];\n}\n\nfunction mergeObjects(a: Record<string, any>, b: Record<string, any>) {\n  return Object.assign(a, b);\n}\n\nfunction copyOwnPropsIfNotPresent(\n  target: Record<string, any>,\n  source: Record<string, any>,\n) {\n  Object.getOwnPropertyNames(source).forEach((prop) => {\n    if (!Object.getOwnPropertyDescriptor(target, prop)) {\n      const propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\n      Object.defineProperty(\n        target,\n        prop,\n        propertyDescriptor == null ? {} : propertyDescriptor,\n      );\n    }\n  });\n}\n\nfunction copyOwnProps(\n  target: Record<string, any>,\n  ...sources: Array<Record<string, any>>\n) {\n  sources.forEach((source) => {\n    let chain = source;\n    while (chain != null) {\n      copyOwnPropsIfNotPresent(target, chain);\n      chain = Object.getPrototypeOf(chain);\n    }\n  });\n  return target;\n}\n\n// takes either an object or a (possibly nested) array\n// and completes the customMock object with any fields\n// defined on genericMock\n// only merges objects or arrays. Scalars are returned as is\nfunction mergeMocks(genericMockFunction: () => any, customMock: any): any {\n  if (Array.isArray(customMock)) {\n    return customMock.map((el: any) => mergeMocks(genericMockFunction, el));\n  }\n  if (isObject(customMock)) {\n    return mergeObjects(genericMockFunction(), customMock);\n  }\n  return customMock;\n}\n\nfunction getResolveType(namedFieldType: GraphQLNamedType) {\n  if (isAbstractType(namedFieldType)) {\n    return namedFieldType.resolveType;\n  }\n}\n\nfunction assignResolveType(type: GraphQLType, preserveResolvers: boolean) {\n  const fieldType = getNullableType(type) as GraphQLNullableType;\n  const namedFieldType = getNamedType(fieldType);\n\n  const oldResolveType = getResolveType(namedFieldType);\n  if (preserveResolvers && oldResolveType != null && oldResolveType.length) {\n    return;\n  }\n\n  if (isInterfaceType(namedFieldType) || isUnionType(namedFieldType)) {\n    // the default `resolveType` always returns null. We add a fallback\n    // resolution that works with how unions and interface are mocked\n    namedFieldType.resolveType = (\n      data: any,\n      _context: any,\n      info: GraphQLResolveInfo,\n    ) => info.schema.getType(data.__typename) as GraphQLObjectType;\n  }\n}\n\nclass MockList {\n  private readonly len: number | Array<number>;\n  private readonly wrappedFunction: GraphQLFieldResolver<any, any> | undefined;\n\n  // wrappedFunction can return another MockList or a value\n  constructor(\n    len: number | Array<number>,\n    wrappedFunction?: GraphQLFieldResolver<any, any>,\n  ) {\n    this.len = len;\n    if (typeof wrappedFunction !== 'undefined') {\n      if (typeof wrappedFunction !== 'function') {\n        throw new Error(\n          'Second argument to MockList must be a function or undefined',\n        );\n      }\n      this.wrappedFunction = wrappedFunction;\n    }\n  }\n\n  public mock(\n    root: any,\n    args: { [key: string]: any },\n    context: any,\n    info: GraphQLResolveInfo,\n    fieldType: GraphQLList<any>,\n    mockTypeFunc: IMockTypeFn,\n  ) {\n    let arr: Array<any>;\n    if (Array.isArray(this.len)) {\n      arr = new Array(this.randint(this.len[0], this.len[1]));\n    } else {\n      arr = new Array(this.len);\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n      if (typeof this.wrappedFunction === 'function') {\n        const res = this.wrappedFunction(root, args, context, info);\n        if (res instanceof MockList) {\n          const nullableType = getNullableType(fieldType.ofType) as GraphQLList<\n            any\n          >;\n          arr[i] = res.mock(\n            root,\n            args,\n            context,\n            info,\n            nullableType,\n            mockTypeFunc,\n          );\n        } else {\n          arr[i] = res;\n        }\n      } else {\n        arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);\n      }\n    }\n    return arr;\n  }\n\n  private randint(low: number, high: number): number {\n    return Math.floor(Math.random() * (high - low + 1) + low);\n  }\n}\n\n// retain addMockFunctionsToSchema for backwards compatibility\n\nfunction addMockFunctionsToSchema({\n  schema,\n  mocks = {},\n  preserveResolvers = false,\n}: IMockOptions): void {\n  addMocksToSchema({ schema, mocks, preserveResolvers });\n}\n\nexport { addMocksToSchema, addMockFunctionsToSchema, MockList, mockServer };\n","import { GraphQLScalarType, GraphQLError } from 'graphql';\n\nconst GraphQLUpload = new GraphQLScalarType({\n  name: 'Upload',\n  description: 'The `Upload` scalar type represents a file upload.',\n  parseValue: (value) => {\n    if (value != null && value.promise instanceof Promise) {\n      // graphql-upload v10\n      return value.promise;\n    } else if (value instanceof Promise) {\n      // graphql-upload v9\n      return value;\n    }\n    throw new GraphQLError('Upload value invalid.');\n  },\n  // serialization requires to support schema stitching\n  serialize: (value) => value,\n  parseLiteral: (ast) => {\n    throw new GraphQLError('Upload literal unsupported.', ast);\n  },\n});\n\nexport { GraphQLUpload };\n","import { ApolloLink } from 'apollo-link';\nimport {\n  GraphQLSchema,\n  DocumentNode,\n  getIntrospectionQuery,\n  buildClientSchema,\n  parse,\n} from 'graphql';\n\nimport { Fetcher } from '../Interfaces';\n\nimport { combineErrors } from './errors';\nimport linkToFetcher from './linkToFetcher';\n\nconst parsedIntrospectionQuery: DocumentNode = parse(getIntrospectionQuery());\n\nexport default function introspectSchema(\n  linkOrFetcher: ApolloLink | Fetcher,\n  linkContext?: { [key: string]: any },\n): Promise<GraphQLSchema> {\n  const fetcher =\n    linkOrFetcher instanceof ApolloLink\n      ? linkToFetcher(linkOrFetcher)\n      : linkOrFetcher;\n\n  return fetcher({\n    query: parsedIntrospectionQuery,\n    context: linkContext,\n  }).then((introspectionResult) => {\n    if (\n      (Array.isArray(introspectionResult.errors) &&\n        introspectionResult.errors.length) ||\n      !introspectionResult.data.__schema\n    ) {\n      if (Array.isArray(introspectionResult.errors)) {\n        const combinedError: Error = combineErrors(introspectionResult.errors);\n        throw combinedError;\n      } else {\n        throw new Error(\n          'Could not obtain introspection result, received: ' +\n            JSON.stringify(introspectionResult),\n        );\n      }\n    } else {\n      const schema = buildClientSchema(\n        introspectionResult.data as {\n          __schema: any;\n        },\n      );\n      return schema;\n    }\n  });\n}\n","import { defaultFieldResolver } from 'graphql';\n\nimport { IGraphQLToolsResolveInfo } from '../Interfaces';\nimport { handleResult } from '../delegate/checkResultAndHandleErrors';\n\nimport { getSubschema } from './subSchema';\nimport { getResponseKeyFromInfo } from './getResponseKeyFromInfo';\nimport { getErrors } from './errors';\n\n/**\n * Resolver that knows how to:\n * a) handle aliases for proxied schemas\n * b) handle errors from proxied schemas\n * c) handle external to internal enum coversion\n */\nexport default function defaultMergedResolver(\n  parent: Record<string, any>,\n  args: Record<string, any>,\n  context: Record<string, any>,\n  info: IGraphQLToolsResolveInfo,\n) {\n  if (!parent) {\n    return null;\n  }\n\n  const responseKey = getResponseKeyFromInfo(info);\n  const errors = getErrors(parent, responseKey);\n\n  // check to see if parent is not a proxied result, i.e. if parent resolver was manually overwritten\n  // See https://github.com/apollographql/graphql-tools/issues/967\n  if (!errors) {\n    return defaultFieldResolver(parent, args, context, info);\n  }\n\n  const result = parent[responseKey];\n  const subschema = getSubschema(parent, responseKey);\n\n  return handleResult(result, errors, subschema, context, info);\n}\n","import { GraphQLType, isAbstractType, isObjectType } from 'graphql';\n\nimport defaultMergedResolver from './defaultMergedResolver';\nimport resolveFromParentTypename from './resolveFromParentTypename';\n\nexport function makeMergedType(type: GraphQLType): void {\n  if (isObjectType(type)) {\n    type.isTypeOf = undefined;\n\n    const fieldMap = type.getFields();\n    Object.keys(fieldMap).forEach((fieldName) => {\n      fieldMap[fieldName].resolve = defaultMergedResolver;\n      fieldMap[fieldName].subscribe = null;\n    });\n  } else if (isAbstractType(type)) {\n    type.resolveType = (parent) => resolveFromParentTypename(parent);\n  }\n}\n","import {\n  GraphQLSchema,\n  GraphQLFieldResolver,\n  GraphQLObjectType,\n} from 'graphql';\n\nimport {\n  Transform,\n  IResolvers,\n  Operation,\n  SubschemaConfig,\n} from '../Interfaces';\nimport delegateToSchema from '../delegate/delegateToSchema';\nimport { handleResult } from '../delegate/checkResultAndHandleErrors';\n\nimport { makeMergedType } from '../stitch/makeMergedType';\nimport { getResponseKeyFromInfo } from '../stitch/getResponseKeyFromInfo';\nimport { getSubschema } from '../stitch/subSchema';\nimport { getErrors } from '../stitch/errors';\n\nexport type Mapping = {\n  [typeName: string]: {\n    [fieldName: string]: {\n      name: string;\n      operation: Operation;\n    };\n  };\n};\n\nexport function generateProxyingResolvers({\n  subschemaConfig,\n  transforms,\n  createProxyingResolver = defaultCreateProxyingResolver,\n}: {\n  subschemaConfig: SubschemaConfig;\n  transforms?: Array<Transform>;\n  createProxyingResolver?: ({\n    schema,\n    transforms,\n    operation,\n    fieldName,\n  }: {\n    schema?: GraphQLSchema | SubschemaConfig;\n    transforms?: Array<Transform>;\n    operation?: Operation;\n    fieldName?: string;\n  }) => GraphQLFieldResolver<any, any>;\n}): IResolvers {\n  const targetSchema = subschemaConfig.schema;\n\n  const mapping = generateSimpleMapping(targetSchema);\n\n  const result = {};\n  Object.keys(mapping).forEach((name) => {\n    result[name] = {};\n    const innerMapping = mapping[name];\n    Object.keys(innerMapping).forEach((from) => {\n      const to = innerMapping[from];\n      const resolverType =\n        to.operation === 'subscription' ? 'subscribe' : 'resolve';\n      result[name][from] = {\n        [resolverType]: createProxyingResolver({\n          schema: subschemaConfig,\n          transforms,\n          operation: to.operation,\n          fieldName: to.name,\n        }),\n      };\n    });\n  });\n  return result;\n}\n\nexport function generateSimpleMapping(targetSchema: GraphQLSchema): Mapping {\n  const query = targetSchema.getQueryType();\n  const mutation = targetSchema.getMutationType();\n  const subscription = targetSchema.getSubscriptionType();\n\n  const result: Mapping = {};\n  if (query != null) {\n    result[query.name] = generateMappingFromObjectType(query, 'query');\n  }\n  if (mutation != null) {\n    result[mutation.name] = generateMappingFromObjectType(mutation, 'mutation');\n  }\n  if (subscription != null) {\n    result[subscription.name] = generateMappingFromObjectType(\n      subscription,\n      'subscription',\n    );\n  }\n\n  return result;\n}\n\nexport function generateMappingFromObjectType(\n  type: GraphQLObjectType,\n  operation: Operation,\n): {\n  [fieldName: string]: {\n    name: string;\n    operation: Operation;\n  };\n} {\n  const result = {};\n  const fields = type.getFields();\n  Object.keys(fields).forEach((fieldName) => {\n    result[fieldName] = {\n      name: fieldName,\n      operation,\n    };\n  });\n  return result;\n}\n\nfunction defaultCreateProxyingResolver({\n  schema,\n  transforms,\n}: {\n  schema: SubschemaConfig;\n  transforms: Array<Transform>;\n}): GraphQLFieldResolver<any, any> {\n  return (parent, _args, context, info) => {\n    if (parent != null) {\n      const responseKey = getResponseKeyFromInfo(info);\n      const errors = getErrors(parent, responseKey);\n\n      if (errors != null) {\n        const subschema = getSubschema(parent, responseKey);\n\n        // if parent contains a proxied result from this subschema, can return that result\n        if (schema === subschema) {\n          const result = parent[responseKey];\n          return handleResult(result, errors, subschema, context, info);\n        }\n      }\n    }\n\n    return delegateToSchema({\n      schema,\n      context,\n      info,\n      transforms,\n    });\n  };\n}\n\nexport function stripResolvers(schema: GraphQLSchema): void {\n  const typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach((typeName) => {\n    if (!typeName.startsWith('__')) {\n      makeMergedType(typeMap[typeName]);\n    }\n  });\n}\n","import { GraphQLSchema } from 'graphql';\n\nimport addResolversToSchema from '../generate/addResolversToSchema';\nimport { Transform, SubschemaConfig, isSubschemaConfig } from '../Interfaces';\nimport { cloneSchema } from '../utils/clone';\n\nimport { generateProxyingResolvers, stripResolvers } from './resolvers';\nimport { applySchemaTransforms } from './transforms';\n\nexport function wrapSchema(\n  subschemaOrSubschemaConfig: GraphQLSchema | SubschemaConfig,\n  transforms?: Array<Transform>,\n): GraphQLSchema {\n  const subschemaConfig: SubschemaConfig = isSubschemaConfig(\n    subschemaOrSubschemaConfig,\n  )\n    ? subschemaOrSubschemaConfig\n    : { schema: subschemaOrSubschemaConfig };\n\n  const schema = cloneSchema(subschemaConfig.schema);\n  stripResolvers(schema);\n\n  addResolversToSchema({\n    schema,\n    resolvers: generateProxyingResolvers({ subschemaConfig, transforms }),\n    resolverValidationOptions: {\n      allowResolversNotInSchema: true,\n    },\n  });\n\n  let schemaTransforms: Array<Transform> = [];\n  if (subschemaConfig.transforms != null) {\n    schemaTransforms = schemaTransforms.concat(subschemaConfig.transforms);\n  }\n  if (transforms != null) {\n    schemaTransforms = schemaTransforms.concat(transforms);\n  }\n\n  return applySchemaTransforms(schema, schemaTransforms);\n}\n","import {\n  DefinitionNode,\n  EnumTypeDefinitionNode,\n  FieldDefinitionNode,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInputType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNamedType,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLType,\n  GraphQLUnionType,\n  InputObjectTypeDefinitionNode,\n  InputValueDefinitionNode,\n  InterfaceTypeDefinitionNode,\n  Kind,\n  ObjectTypeDefinitionNode,\n  ScalarTypeDefinitionNode,\n  TypeNode,\n  UnionTypeDefinitionNode,\n  GraphQLDirective,\n  DirectiveDefinitionNode,\n  DirectiveLocationEnum,\n  DirectiveLocation,\n  GraphQLFieldConfig,\n  StringValueNode,\n  Location,\n  TokenKind,\n} from 'graphql';\n\nimport { createNamedStub, graphqlVersion } from '../utils/index';\n\nimport resolveFromParentTypename from './resolveFromParentTypename';\n\nconst backcompatOptions = { commentDescriptions: true };\n\nexport type GetType = (\n  name: string,\n  // this is a hack\n  type: 'object' | 'interface' | 'input',\n) => GraphQLObjectType | GraphQLInputObjectType | GraphQLInterfaceType;\n\nexport default function typeFromAST(\n  node: DefinitionNode,\n): GraphQLNamedType | GraphQLDirective | null {\n  switch (node.kind) {\n    case Kind.OBJECT_TYPE_DEFINITION:\n      return makeObjectType(node);\n    case Kind.INTERFACE_TYPE_DEFINITION:\n      return makeInterfaceType(node);\n    case Kind.ENUM_TYPE_DEFINITION:\n      return makeEnumType(node);\n    case Kind.UNION_TYPE_DEFINITION:\n      return makeUnionType(node);\n    case Kind.SCALAR_TYPE_DEFINITION:\n      return makeScalarType(node);\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n      return makeInputObjectType(node);\n    case Kind.DIRECTIVE_DEFINITION:\n      return makeDirective(node);\n    default:\n      return null;\n  }\n}\n\nfunction makeObjectType(node: ObjectTypeDefinitionNode): GraphQLObjectType {\n  const config = {\n    name: node.name.value,\n    fields: () => makeFields(node.fields),\n    interfaces: () =>\n      node.interfaces.map(\n        (iface) =>\n          createNamedStub(\n            iface.name.value,\n            'interface',\n          ) as GraphQLInterfaceType,\n      ),\n    description: getDescription(node, backcompatOptions),\n  };\n  return new GraphQLObjectType(config);\n}\n\nfunction makeInterfaceType(\n  node: InterfaceTypeDefinitionNode,\n): GraphQLInterfaceType {\n  const config = {\n    name: node.name.value,\n    fields: () => makeFields(node.fields),\n    interfaces:\n      graphqlVersion() >= 15\n        ? () =>\n            ((node as unknown) as ObjectTypeDefinitionNode).interfaces.map(\n              (iface) =>\n                createNamedStub(\n                  iface.name.value,\n                  'interface',\n                ) as GraphQLInterfaceType,\n            )\n        : undefined,\n    description: getDescription(node, backcompatOptions),\n    resolveType: (parent: any) => resolveFromParentTypename(parent),\n  };\n  return new GraphQLInterfaceType(config);\n}\n\nfunction makeEnumType(node: EnumTypeDefinitionNode): GraphQLEnumType {\n  const values = {};\n  node.values.forEach((value) => {\n    values[value.name.value] = {\n      description: getDescription(value, backcompatOptions),\n    };\n  });\n  return new GraphQLEnumType({\n    name: node.name.value,\n    values,\n    description: getDescription(node, backcompatOptions),\n  });\n}\n\nfunction makeUnionType(node: UnionTypeDefinitionNode): GraphQLUnionType {\n  return new GraphQLUnionType({\n    name: node.name.value,\n    types: () =>\n      node.types.map(\n        (type) => resolveType(type, 'object') as GraphQLObjectType,\n      ),\n    description: getDescription(node, backcompatOptions),\n    resolveType: (parent) => resolveFromParentTypename(parent),\n  });\n}\n\nfunction makeScalarType(node: ScalarTypeDefinitionNode): GraphQLScalarType {\n  return new GraphQLScalarType({\n    name: node.name.value,\n    description: getDescription(node, backcompatOptions),\n    serialize: () => null,\n    // Note: validation calls the parse functions to determine if a\n    // literal value is correct. Returning null would cause use of custom\n    // scalars to always fail validation. Returning false causes them to\n    // always pass validation.\n    parseValue: () => false,\n    parseLiteral: () => false,\n  });\n}\n\nfunction makeInputObjectType(\n  node: InputObjectTypeDefinitionNode,\n): GraphQLInputObjectType {\n  return new GraphQLInputObjectType({\n    name: node.name.value,\n    fields: () => makeValues(node.fields),\n    description: getDescription(node, backcompatOptions),\n  });\n}\n\nfunction makeFields(\n  nodes: ReadonlyArray<FieldDefinitionNode>,\n): Record<string, GraphQLFieldConfig<any, any>> {\n  const result: Record<string, GraphQLFieldConfig<any, any>> = {};\n  nodes.forEach((node) => {\n    const deprecatedDirective = node.directives.find(\n      (directive) => directive.name.value === 'deprecated',\n    );\n\n    let deprecationReason;\n\n    if (deprecatedDirective != null) {\n      const deprecatedArgument = deprecatedDirective.arguments.find(\n        (arg) => arg.name.value === 'reason',\n      );\n      deprecationReason = (deprecatedArgument.value as StringValueNode).value;\n    }\n\n    result[node.name.value] = {\n      type: resolveType(node.type, 'object') as GraphQLObjectType,\n      args: makeValues(node.arguments),\n      description: getDescription(node, backcompatOptions),\n      deprecationReason,\n    };\n  });\n  return result;\n}\n\nfunction makeValues(nodes: ReadonlyArray<InputValueDefinitionNode>) {\n  const result = {};\n  nodes.forEach((node) => {\n    const type = resolveType(node.type, 'input') as GraphQLInputType;\n    result[node.name.value] = {\n      type,\n      defaultValue: node.defaultValue,\n      description: getDescription(node, backcompatOptions),\n    };\n  });\n  return result;\n}\n\nfunction resolveType(\n  node: TypeNode,\n  type: 'object' | 'interface' | 'input',\n): GraphQLType {\n  switch (node.kind) {\n    case Kind.LIST_TYPE:\n      return new GraphQLList(resolveType(node.type, type));\n    case Kind.NON_NULL_TYPE:\n      return new GraphQLNonNull(resolveType(node.type, type));\n    default:\n      return createNamedStub(node.name.value, type);\n  }\n}\n\nfunction makeDirective(node: DirectiveDefinitionNode): GraphQLDirective {\n  const locations: Array<DirectiveLocationEnum> = [];\n  node.locations.forEach((location) => {\n    if (location.value in DirectiveLocation) {\n      locations.push(location.value as DirectiveLocationEnum);\n    }\n  });\n  return new GraphQLDirective({\n    name: node.name.value,\n    description: node.description != null ? node.description.value : null,\n    args: makeValues(node.arguments),\n    locations,\n  });\n}\n\n// graphql < v13 does not export getDescription\n\nfunction getDescription(\n  node: { description?: StringValueNode; loc?: Location },\n  options?: { commentDescriptions?: boolean },\n): string {\n  if (node.description != null) {\n    return node.description.value;\n  }\n  if (options.commentDescriptions) {\n    const rawValue = getLeadingCommentBlock(node);\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue(`\\n${rawValue as string}`);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node: {\n  description?: StringValueNode;\n  loc?: Location;\n}): void | string {\n  const loc = node.loc;\n  if (!loc) {\n    return;\n  }\n  const comments = [];\n  let token = loc.startToken.prev;\n  while (\n    token != null &&\n    token.kind === TokenKind.COMMENT &&\n    token.next != null &&\n    token.prev != null &&\n    token.line + 1 === token.next.line &&\n    token.line !== token.prev.line\n  ) {\n    const value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\n\nfunction dedentBlockStringValue(rawString: string): string {\n  // Expand a block string's raw value into independent lines.\n  const lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n\n  // Remove common indentation from all lines but first.\n  const commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (let i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  }\n\n  // Remove leading and trailing blank lines.\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  }\n\n  // Return a string of the lines joined with U+000A.\n  return lines.join('\\n');\n}\n/**\n * @internal\n */\nexport function getBlockStringIndentation(\n  lines: ReadonlyArray<string>,\n): number {\n  let commonIndent = null;\n\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i];\n    const indent = leadingWhitespace(line);\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str: string) {\n  let i = 0;\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n  return i;\n}\n\nfunction isBlank(str: string) {\n  return leadingWhitespace(str) === str.length;\n}\n","import {\n  GraphQLNamedType,\n  GraphQLObjectType,\n  GraphQLSchema,\n  Kind,\n  SelectionNode,\n  SelectionSetNode,\n  isObjectType,\n  isScalarType,\n} from 'graphql';\nimport { TypeMap } from 'graphql/type/schema';\n\nimport {\n  IDelegateToSchemaOptions,\n  MergeInfo,\n  IResolversParameter,\n  isSubschemaConfig,\n  SubschemaConfig,\n  IGraphQLToolsResolveInfo,\n  MergedTypeInfo,\n  Transform,\n} from '../Interfaces';\nimport ExpandAbstractTypes from '../wrap/transforms/ExpandAbstractTypes';\nimport AddReplacementFragments from '../wrap/transforms/AddReplacementFragments';\nimport {\n  parseFragmentToInlineFragment,\n  concatInlineFragments,\n  typeContainsSelectionSet,\n  parseSelectionSet,\n} from '../utils/index';\n\nimport delegateToSchema from '../delegate/delegateToSchema';\n\ntype MergeTypeCandidate = {\n  type: GraphQLNamedType;\n  schema?: GraphQLSchema;\n  subschema?: GraphQLSchema | SubschemaConfig;\n  transformedSubschema?: GraphQLSchema;\n};\n\nexport function createMergeInfo(\n  allSchemas: Array<GraphQLSchema>,\n  typeCandidates: { [name: string]: Array<MergeTypeCandidate> },\n  mergeTypes?:\n    | boolean\n    | Array<string>\n    | ((\n        typeName: string,\n        mergeTypeCandidates: Array<MergeTypeCandidate>,\n      ) => boolean),\n): MergeInfo {\n  return {\n    delegate(\n      operation: 'query' | 'mutation' | 'subscription',\n      fieldName: string,\n      args: { [key: string]: any },\n      context: { [key: string]: any },\n      info: IGraphQLToolsResolveInfo,\n      transforms: Array<Transform> = [],\n    ) {\n      const schema = guessSchemaByRootField(allSchemas, operation, fieldName);\n      const expandTransforms = new ExpandAbstractTypes(info.schema, schema);\n      const fragmentTransform = new AddReplacementFragments(\n        schema,\n        info.mergeInfo.replacementFragments,\n      );\n      return delegateToSchema({\n        schema,\n        operation,\n        fieldName,\n        args,\n        context,\n        info,\n        transforms: [...transforms, expandTransforms, fragmentTransform],\n      });\n    },\n\n    delegateToSchema(options: IDelegateToSchemaOptions) {\n      return delegateToSchema({\n        ...options,\n        transforms: options.transforms,\n      });\n    },\n    fragments: [],\n    replacementSelectionSets: undefined,\n    replacementFragments: undefined,\n    mergedTypes: createMergedTypes(typeCandidates, mergeTypes),\n  };\n}\n\nfunction createMergedTypes(\n  typeCandidates: { [name: string]: Array<MergeTypeCandidate> },\n  mergeTypes?:\n    | boolean\n    | Array<string>\n    | ((\n        typeName: string,\n        mergeTypeCandidates: Array<MergeTypeCandidate>,\n      ) => boolean),\n): Record<string, MergedTypeInfo> {\n  const mergedTypes: Record<string, MergedTypeInfo> = {};\n\n  Object.keys(typeCandidates).forEach((typeName) => {\n    if (isObjectType(typeCandidates[typeName][0].type)) {\n      const mergedTypeCandidates = typeCandidates[typeName].filter(\n        (typeCandidate) =>\n          typeCandidate.subschema != null &&\n          isSubschemaConfig(typeCandidate.subschema) &&\n          typeCandidate.subschema.merge != null &&\n          typeCandidate.subschema.merge[typeName] != null,\n      );\n\n      if (\n        mergeTypes === true ||\n        (typeof mergeTypes === 'function' &&\n          mergeTypes(typeName, typeCandidates[typeName])) ||\n        (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||\n        mergedTypeCandidates.length\n      ) {\n        const subschemas: Array<SubschemaConfig> = [];\n\n        let requiredSelections: Array<SelectionNode> = [\n          parseSelectionSet('{ __typename }').selections[0],\n        ];\n        const fields = Object.create({});\n        const typeMaps: Map<SubschemaConfig, TypeMap> = new Map();\n        const selectionSets: Map<SubschemaConfig, SelectionSetNode> = new Map();\n\n        mergedTypeCandidates.forEach((typeCandidate) => {\n          const subschemaConfig = typeCandidate.subschema as SubschemaConfig;\n          const transformedSubschema = typeCandidate.transformedSubschema;\n          typeMaps.set(subschemaConfig, transformedSubschema.getTypeMap());\n          const type = transformedSubschema.getType(\n            typeName,\n          ) as GraphQLObjectType;\n          const fieldMap = type.getFields();\n          Object.keys(fieldMap).forEach((fieldName) => {\n            if (fields[fieldName] == null) {\n              fields[fieldName] = [];\n            }\n            fields[fieldName].push(subschemaConfig);\n          });\n\n          const mergedTypeConfig = subschemaConfig.merge[typeName];\n\n          if (mergedTypeConfig.selectionSet) {\n            const selectionSet = parseSelectionSet(\n              mergedTypeConfig.selectionSet,\n            );\n            requiredSelections = requiredSelections.concat(\n              selectionSet.selections,\n            );\n            selectionSets.set(subschemaConfig, selectionSet);\n          }\n\n          if (!mergedTypeConfig.resolve) {\n            mergedTypeConfig.resolve = (\n              originalResult,\n              context,\n              info,\n              subschema,\n              selectionSet,\n            ) =>\n              delegateToSchema({\n                schema: subschema,\n                operation: 'query',\n                fieldName: mergedTypeConfig.fieldName,\n                args: mergedTypeConfig.args(originalResult),\n                selectionSet,\n                context,\n                info,\n                skipTypeMerging: true,\n              });\n          }\n\n          subschemas.push(subschemaConfig);\n        });\n\n        mergedTypes[typeName] = {\n          subschemas,\n          typeMaps,\n          selectionSets,\n          containsSelectionSet: new Map(),\n          uniqueFields: Object.create({}),\n          nonUniqueFields: Object.create({}),\n        };\n\n        subschemas.forEach((subschema) => {\n          const type = typeMaps.get(subschema)[typeName] as GraphQLObjectType;\n          const subschemaMap = new Map();\n          subschemas\n            .filter((s) => s !== subschema)\n            .forEach((s) => {\n              const selectionSet = selectionSets.get(s);\n              if (\n                selectionSet != null &&\n                typeContainsSelectionSet(type, selectionSet)\n              ) {\n                subschemaMap.set(selectionSet, true);\n              }\n            });\n          mergedTypes[typeName].containsSelectionSet.set(\n            subschema,\n            subschemaMap,\n          );\n        });\n\n        Object.keys(fields).forEach((fieldName) => {\n          const supportedBySubschemas = fields[fieldName];\n          if (supportedBySubschemas.length === 1) {\n            mergedTypes[typeName].uniqueFields[fieldName] =\n              supportedBySubschemas[0];\n          } else {\n            mergedTypes[typeName].nonUniqueFields[\n              fieldName\n            ] = supportedBySubschemas;\n          }\n        });\n\n        mergedTypes[typeName].selectionSet = {\n          kind: Kind.SELECTION_SET,\n          selections: requiredSelections,\n        };\n      }\n    }\n  });\n\n  return mergedTypes;\n}\n\nexport function completeMergeInfo(\n  mergeInfo: MergeInfo,\n  resolvers: IResolversParameter,\n): MergeInfo {\n  const replacementSelectionSets = Object.create(null);\n\n  Object.keys(resolvers).forEach((typeName) => {\n    const type = resolvers[typeName];\n    if (isScalarType(type)) {\n      return;\n    }\n    Object.keys(type).forEach((fieldName) => {\n      const field = type[fieldName];\n      if (field.selectionSet) {\n        const selectionSet = parseSelectionSet(field.selectionSet);\n        if (replacementSelectionSets[typeName] == null) {\n          replacementSelectionSets[typeName] = {};\n        }\n        if (replacementSelectionSets[typeName][fieldName] == null) {\n          replacementSelectionSets[typeName][fieldName] = {\n            kind: Kind.SELECTION_SET,\n            selections: [],\n          };\n        }\n        replacementSelectionSets[typeName][\n          fieldName\n        ].selections = replacementSelectionSets[typeName][\n          fieldName\n        ].selections.concat(selectionSet.selections);\n      }\n      if (field.fragment) {\n        mergeInfo.fragments.push({\n          field: fieldName,\n          fragment: field.fragment,\n        });\n      }\n    });\n  });\n\n  const mapping = {};\n  mergeInfo.fragments.forEach(({ field, fragment }) => {\n    const parsedFragment = parseFragmentToInlineFragment(fragment);\n    const actualTypeName = parsedFragment.typeCondition.name.value;\n    if (mapping[actualTypeName] == null) {\n      mapping[actualTypeName] = {};\n    }\n    if (mapping[actualTypeName][field] == null) {\n      mapping[actualTypeName][field] = [];\n    }\n    mapping[actualTypeName][field].push(parsedFragment);\n  });\n\n  const replacementFragments = Object.create(null);\n  Object.keys(mapping).forEach((typeName) => {\n    Object.keys(mapping[typeName]).forEach((field) => {\n      if (replacementFragments[typeName] == null) {\n        replacementFragments[typeName] = {};\n      }\n      replacementFragments[typeName][field] = concatInlineFragments(\n        typeName,\n        mapping[typeName][field],\n      );\n    });\n  });\n\n  mergeInfo.replacementSelectionSets = replacementSelectionSets;\n  mergeInfo.replacementFragments = replacementFragments;\n\n  return mergeInfo;\n}\n\nfunction operationToRootType(\n  operation: 'query' | 'mutation' | 'subscription',\n  schema: GraphQLSchema,\n): GraphQLObjectType {\n  if (operation === 'subscription') {\n    return schema.getSubscriptionType();\n  } else if (operation === 'mutation') {\n    return schema.getMutationType();\n  }\n\n  return schema.getQueryType();\n}\n\nfunction guessSchemaByRootField(\n  schemas: Array<GraphQLSchema>,\n  operation: 'query' | 'mutation' | 'subscription',\n  fieldName: string,\n): GraphQLSchema {\n  for (const schema of schemas) {\n    const rootObject = operationToRootType(operation, schema);\n    if (rootObject != null) {\n      const fields = rootObject.getFields();\n      if (fields[fieldName] != null) {\n        return schema;\n      }\n    }\n  }\n  throw new Error(\n    `Could not find subschema with field \\`${operation}.${fieldName}\\``,\n  );\n}\n","import {\n  DocumentNode,\n  GraphQLNamedType,\n  GraphQLObjectType,\n  GraphQLSchema,\n  getNamedType,\n  isNamedType,\n  parse,\n  Kind,\n  GraphQLDirective,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLEnumType,\n  ASTNode,\n  isSchema,\n  isDirective,\n  isScalarType,\n  isObjectType,\n  isInterfaceType,\n  isUnionType,\n  isEnumType,\n} from 'graphql';\n\nimport {\n  OnTypeConflict,\n  IResolversParameter,\n  isSubschemaConfig,\n  SchemaLikeObject,\n  IResolvers,\n  SubschemaConfig,\n} from '../Interfaces';\nimport {\n  extractExtensionDefinitions,\n  addResolversToSchema,\n} from '../generate/index';\nimport { wrapSchema } from '../wrap/wrapSchema';\nimport {\n  SchemaDirectiveVisitor,\n  cloneDirective,\n  healTypes,\n  forEachField,\n  mergeDeep,\n  graphqlVersion,\n} from '../utils/index';\nimport { toConfig, extendSchema } from '../polyfills/index';\n\nimport typeFromAST from './typeFromAST';\nimport { createMergeInfo, completeMergeInfo } from './mergeInfo';\n\ntype MergeTypeCandidate = {\n  type: GraphQLNamedType;\n  schema?: GraphQLSchema;\n  subschema?: GraphQLSchema | SubschemaConfig;\n  transformedSubschema?: GraphQLSchema;\n};\n\ntype CandidateSelector = (\n  candidates: Array<MergeTypeCandidate>,\n) => MergeTypeCandidate;\n\nexport default function mergeSchemas({\n  subschemas = [],\n  types = [],\n  typeDefs,\n  schemas: schemaLikeObjects = [],\n  onTypeConflict,\n  resolvers = {},\n  schemaDirectives,\n  inheritResolversFromInterfaces,\n  mergeTypes = false,\n  mergeDirectives,\n  queryTypeName = 'Query',\n  mutationTypeName = 'Mutation',\n  subscriptionTypeName = 'Subscription',\n}: {\n  subschemas?: Array<GraphQLSchema | SubschemaConfig>;\n  types?: Array<GraphQLNamedType>;\n  typeDefs?: string | DocumentNode;\n  schemas?: Array<SchemaLikeObject>;\n  onTypeConflict?: OnTypeConflict;\n  resolvers?: IResolversParameter;\n  schemaDirectives?: { [name: string]: typeof SchemaDirectiveVisitor };\n  inheritResolversFromInterfaces?: boolean;\n  mergeTypes?:\n    | boolean\n    | Array<string>\n    | ((\n        typeName: string,\n        mergeTypeCandidates: Array<MergeTypeCandidate>,\n      ) => boolean);\n  mergeDirectives?: boolean;\n  queryTypeName?: string;\n  mutationTypeName?: string;\n  subscriptionTypeName?: string;\n}): GraphQLSchema {\n  const allSchemas: Array<GraphQLSchema> = [];\n  const typeCandidates: { [name: string]: Array<MergeTypeCandidate> } = {};\n  const typeMap: { [name: string]: GraphQLNamedType } = {};\n  const extensions: Array<DocumentNode> = [];\n  const directives: Array<GraphQLDirective> = [];\n\n  let schemas: Array<SchemaLikeObject> = [...subschemas];\n  if (typeDefs) {\n    schemas.push(typeDefs);\n  }\n  if (types != null) {\n    schemas.push(types);\n  }\n  schemas = [...schemas, ...schemaLikeObjects];\n\n  schemas.forEach((schemaLikeObject) => {\n    if (isSchema(schemaLikeObject) || isSubschemaConfig(schemaLikeObject)) {\n      const schema = wrapSchema(schemaLikeObject);\n\n      allSchemas.push(schema);\n\n      const operationTypes = {\n        [queryTypeName]: schema.getQueryType(),\n        [mutationTypeName]: schema.getMutationType(),\n        [subscriptionTypeName]: schema.getSubscriptionType(),\n      };\n\n      Object.keys(operationTypes).forEach((typeName) => {\n        if (operationTypes[typeName] != null) {\n          addTypeCandidate(typeCandidates, typeName, {\n            schema,\n            type: operationTypes[typeName],\n            subschema: schemaLikeObject,\n            transformedSubschema: schema,\n          });\n        }\n      });\n\n      if (mergeDirectives) {\n        const directiveInstances = schema.getDirectives();\n        directiveInstances.forEach((directive) => {\n          directives.push(directive);\n        });\n      }\n\n      const originalTypeMap = schema.getTypeMap();\n      Object.keys(originalTypeMap).forEach((typeName) => {\n        const type: GraphQLNamedType = originalTypeMap[typeName];\n        if (\n          isNamedType(type) &&\n          getNamedType(type).name.slice(0, 2) !== '__' &&\n          type !== operationTypes.Query &&\n          type !== operationTypes.Mutation &&\n          type !== operationTypes.Subscription\n        ) {\n          addTypeCandidate(typeCandidates, type.name, {\n            schema,\n            type,\n            subschema: schemaLikeObject,\n            transformedSubschema: schema,\n          });\n        }\n      });\n    } else if (\n      typeof schemaLikeObject === 'string' ||\n      (schemaLikeObject != null &&\n        (schemaLikeObject as ASTNode).kind === Kind.DOCUMENT)\n    ) {\n      const parsedSchemaDocument =\n        typeof schemaLikeObject === 'string'\n          ? parse(schemaLikeObject)\n          : (schemaLikeObject as DocumentNode);\n\n      parsedSchemaDocument.definitions.forEach((def) => {\n        const type = typeFromAST(def);\n        if (isDirective(type) && mergeDirectives) {\n          directives.push(type);\n        } else if (type != null && !isDirective(type)) {\n          addTypeCandidate(typeCandidates, type.name, {\n            type,\n          });\n        }\n      });\n\n      const extensionsDocument = extractExtensionDefinitions(\n        parsedSchemaDocument,\n      );\n      if (extensionsDocument.definitions.length > 0) {\n        extensions.push(extensionsDocument);\n      }\n    } else if (Array.isArray(schemaLikeObject)) {\n      schemaLikeObject.forEach((type) => {\n        addTypeCandidate(typeCandidates, type.name, {\n          type,\n        });\n      });\n    } else {\n      throw new Error('Invalid schema passed');\n    }\n  });\n\n  let mergeInfo = createMergeInfo(allSchemas, typeCandidates, mergeTypes);\n\n  let finalResolvers: IResolvers;\n  if (typeof resolvers === 'function') {\n    finalResolvers = resolvers(mergeInfo);\n  } else if (Array.isArray(resolvers)) {\n    finalResolvers = resolvers.reduce(\n      (left, right) =>\n        mergeDeep(left, typeof right === 'function' ? right(mergeInfo) : right),\n      {},\n    );\n    if (Array.isArray(resolvers)) {\n      finalResolvers = resolvers.reduce(mergeDeep, {});\n    }\n  } else {\n    finalResolvers = resolvers;\n  }\n\n  if (finalResolvers == null) {\n    finalResolvers = {};\n  }\n\n  mergeInfo = completeMergeInfo(mergeInfo, finalResolvers);\n\n  Object.keys(typeCandidates).forEach((typeName) => {\n    if (\n      typeName === queryTypeName ||\n      typeName === mutationTypeName ||\n      typeName === subscriptionTypeName ||\n      (mergeTypes === true &&\n        !isScalarType(typeCandidates[typeName][0].type)) ||\n      (typeof mergeTypes === 'function' &&\n        mergeTypes(typeName, typeCandidates[typeName])) ||\n      (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||\n      mergeInfo.mergedTypes[typeName] != null\n    ) {\n      typeMap[typeName] = merge(typeName, typeCandidates[typeName]);\n    } else {\n      const candidateSelector =\n        onTypeConflict != null\n          ? onTypeConflictToCandidateSelector(onTypeConflict)\n          : (cands: Array<MergeTypeCandidate>) => cands[cands.length - 1];\n      typeMap[typeName] = candidateSelector(typeCandidates[typeName]).type;\n    }\n  });\n\n  healTypes(typeMap, directives, { skipPruning: true });\n\n  let mergedSchema = new GraphQLSchema({\n    query: typeMap[queryTypeName] as GraphQLObjectType,\n    mutation: typeMap[mutationTypeName] as GraphQLObjectType,\n    subscription: typeMap[subscriptionTypeName] as GraphQLObjectType,\n    types: Object.keys(typeMap).map((key) => typeMap[key]),\n    directives: directives.length\n      ? directives.map((directive) => cloneDirective(directive))\n      : undefined,\n  });\n\n  extensions.forEach((extension) => {\n    mergedSchema = extendSchema(mergedSchema, extension, {\n      commentDescriptions: true,\n    });\n  });\n\n  addResolversToSchema({\n    schema: mergedSchema,\n    resolvers: finalResolvers,\n    inheritResolversFromInterfaces,\n  });\n\n  forEachField(mergedSchema, (field) => {\n    if (field.resolve != null) {\n      const fieldResolver = field.resolve;\n      field.resolve = (parent, args, context, info) => {\n        const newInfo = { ...info, mergeInfo };\n        return fieldResolver(parent, args, context, newInfo);\n      };\n    }\n    if (field.subscribe != null) {\n      const fieldResolver = field.subscribe;\n      field.subscribe = (parent, args, context, info) => {\n        const newInfo = { ...info, mergeInfo };\n        return fieldResolver(parent, args, context, newInfo);\n      };\n    }\n  });\n\n  if (schemaDirectives != null) {\n    SchemaDirectiveVisitor.visitSchemaDirectives(\n      mergedSchema,\n      schemaDirectives,\n    );\n  }\n\n  return mergedSchema;\n}\n\nfunction addTypeCandidate(\n  typeCandidates: { [name: string]: Array<MergeTypeCandidate> },\n  name: string,\n  typeCandidate: MergeTypeCandidate,\n) {\n  if (!typeCandidates[name]) {\n    typeCandidates[name] = [];\n  }\n  typeCandidates[name].push(typeCandidate);\n}\n\nfunction onTypeConflictToCandidateSelector(\n  onTypeConflict: OnTypeConflict,\n): CandidateSelector {\n  return (cands) =>\n    cands.reduce((prev, next) => {\n      const type = onTypeConflict(prev.type, next.type, {\n        left: {\n          schema: prev.schema,\n        },\n        right: {\n          schema: next.schema,\n        },\n      });\n      if (prev.type === type) {\n        return prev;\n      } else if (next.type === type) {\n        return next;\n      }\n      return {\n        schemaName: 'unknown',\n        type,\n      };\n    });\n}\n\nfunction merge(\n  typeName: string,\n  candidates: Array<MergeTypeCandidate>,\n): GraphQLNamedType {\n  const initialCandidateType = candidates[0].type;\n  if (\n    candidates.some(\n      (candidate) =>\n        candidate.type.constructor !== initialCandidateType.constructor,\n    )\n  ) {\n    throw new Error(\n      `Cannot merge different type categories into common type ${typeName}.`,\n    );\n  }\n  if (isObjectType(initialCandidateType)) {\n    return new GraphQLObjectType({\n      name: typeName,\n      fields: candidates.reduce(\n        (acc, candidate) => ({\n          ...acc,\n          ...toConfig(candidate.type).fields,\n        }),\n        {},\n      ),\n      interfaces: candidates.reduce((acc, candidate) => {\n        const interfaces = toConfig(candidate.type).interfaces;\n        return interfaces != null ? acc.concat(interfaces) : acc;\n      }, []),\n    });\n  } else if (isInterfaceType(initialCandidateType)) {\n    const config = {\n      name: typeName,\n      fields: candidates.reduce(\n        (acc, candidate) => ({\n          ...acc,\n          ...toConfig(candidate.type).fields,\n        }),\n        {},\n      ),\n      interfaces:\n        graphqlVersion() >= 15\n          ? candidates.reduce((acc, candidate) => {\n              const interfaces = toConfig(candidate.type).interfaces;\n              return interfaces != null ? acc.concat(interfaces) : acc;\n            }, [])\n          : undefined,\n    };\n    return new GraphQLInterfaceType(config);\n  } else if (isUnionType(initialCandidateType)) {\n    return new GraphQLUnionType({\n      name: typeName,\n      types: candidates.reduce(\n        (acc, candidate) => acc.concat(toConfig(candidate.type).types),\n        [],\n      ),\n    });\n  } else if (isEnumType(initialCandidateType)) {\n    return new GraphQLEnumType({\n      name: typeName,\n      values: candidates.reduce(\n        (acc, candidate) => ({\n          ...acc,\n          ...toConfig(candidate.type).values,\n        }),\n        {},\n      ),\n    });\n  } else if (isScalarType(initialCandidateType)) {\n    throw new Error(\n      `Cannot merge type ${typeName}. Merging not supported for GraphQLScalarType.`,\n    );\n  } else {\n    // not reachable.\n    throw new Error(`Type ${typeName} has unknown GraphQL type.`);\n  }\n}\n","import { IFieldResolver } from '../Interfaces';\n\nimport { unwrapResult, dehoistResult } from './proxiedResult';\nimport defaultMergedResolver from './defaultMergedResolver';\n\nexport function createMergedResolver({\n  fromPath,\n  dehoist,\n  delimeter = '__gqltf__',\n}: {\n  fromPath?: Array<string>;\n  dehoist?: boolean;\n  delimeter?: string;\n}): IFieldResolver<any, any> {\n  const parentErrorResolver: IFieldResolver<any, any> = (\n    parent,\n    args,\n    context,\n    info,\n  ) =>\n    parent instanceof Error\n      ? parent\n      : defaultMergedResolver(parent, args, context, info);\n\n  const unwrappingResolver: IFieldResolver<any, any> =\n    fromPath != null\n      ? (parent, args, context, info) =>\n          parentErrorResolver(\n            unwrapResult(parent, info, fromPath),\n            args,\n            context,\n            info,\n          )\n      : parentErrorResolver;\n\n  const dehoistingResolver: IFieldResolver<any, any> = dehoist\n    ? (parent, args, context, info) =>\n        unwrappingResolver(\n          dehoistResult(parent, delimeter),\n          args,\n          context,\n          info,\n        )\n    : unwrappingResolver;\n\n  const noParentResolver: IFieldResolver<any, any> = (\n    parent,\n    args,\n    context,\n    info,\n  ) => (parent ? dehoistingResolver(parent, args, context, info) : {});\n\n  return noParentResolver;\n}\n","import { GraphQLSchema } from 'graphql';\n\nimport {\n  Transform,\n  SubschemaConfig,\n  GraphQLSchemaWithTransforms,\n} from '../Interfaces';\n\nimport { wrapSchema } from './wrapSchema';\n\n// This function is deprecated in favor of wrapSchema as the name is misleading.\n// transformSchema does not just \"transform\" a schema, it wraps a schema with transforms\n// using a round of delegation.\n// The applySchemaTransforms function actually \"transforms\" the schema and is used during wrapping.\nexport function transformSchema(\n  subschemaOrSubschemaConfig: GraphQLSchema | SubschemaConfig,\n  transforms: Array<Transform>,\n): GraphQLSchemaWithTransforms {\n  const schema: GraphQLSchemaWithTransforms = wrapSchema(\n    subschemaOrSubschemaConfig,\n    transforms,\n  );\n\n  schema.transforms = transforms.slice().reverse();\n  return schema;\n}\n","import {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLNamedType,\n  GraphQLObjectType,\n  GraphQLSchema,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  Kind,\n  NamedTypeNode,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n  visit,\n} from 'graphql';\n\nimport { isSpecifiedScalarType, toConfig } from '../../polyfills/index';\nimport { Transform, Request, Result, MapperKind } from '../../Interfaces';\nimport { mapSchema } from '../../utils/index';\n\nexport type RenameOptions = {\n  renameBuiltins: boolean;\n  renameScalars: boolean;\n};\n\nexport default class RenameTypes implements Transform {\n  private readonly renamer: (name: string) => string | undefined;\n  private map: { [key: string]: string };\n  private reverseMap: { [key: string]: string };\n  private readonly renameBuiltins: boolean;\n  private readonly renameScalars: boolean;\n\n  constructor(\n    renamer: (name: string) => string | undefined,\n    options?: RenameOptions,\n  ) {\n    this.renamer = renamer;\n    this.map = {};\n    this.reverseMap = {};\n    const { renameBuiltins = false, renameScalars = true } =\n      options != null ? options : {};\n    this.renameBuiltins = renameBuiltins;\n    this.renameScalars = renameScalars;\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return mapSchema(originalSchema, {\n      [MapperKind.TYPE]: (type: GraphQLNamedType) => {\n        if (isSpecifiedScalarType(type) && !this.renameBuiltins) {\n          return undefined;\n        }\n        if (isScalarType(type) && !this.renameScalars) {\n          return undefined;\n        }\n        const oldName = type.name;\n        const newName = this.renamer(oldName);\n        if (newName && newName !== oldName) {\n          this.map[oldName] = type.name;\n          this.reverseMap[newName] = oldName;\n\n          const newConfig = {\n            ...toConfig(type),\n            name: newName,\n          };\n\n          if (isObjectType(type)) {\n            return new GraphQLObjectType(newConfig);\n          } else if (isInterfaceType(type)) {\n            return new GraphQLInterfaceType(newConfig);\n          } else if (isUnionType(type)) {\n            return new GraphQLUnionType(newConfig);\n          } else if (isInputObjectType(type)) {\n            return new GraphQLInputObjectType(newConfig);\n          } else if (isEnumType(type)) {\n            return new GraphQLEnumType(newConfig);\n          } else if (isScalarType(type)) {\n            return new GraphQLScalarType(newConfig);\n          }\n\n          throw new Error(`Unknown type ${type as string}.`);\n        }\n      },\n\n      [MapperKind.ROOT_OBJECT]() {\n        return undefined;\n      },\n    });\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const newDocument = visit(originalRequest.document, {\n      [Kind.NAMED_TYPE]: (node: NamedTypeNode) => {\n        const name = node.name.value;\n        if (name in this.reverseMap) {\n          return {\n            ...node,\n            name: {\n              kind: Kind.NAME,\n              value: this.reverseMap[name],\n            },\n          };\n        }\n      },\n    });\n    return {\n      document: newDocument,\n      variables: originalRequest.variables,\n    };\n  }\n\n  public transformResult(result: Result): Result {\n    return {\n      ...result,\n      data: this.renameTypes(result.data),\n    };\n  }\n\n  private renameTypes(value: any): any {\n    if (value == null) {\n      return value;\n    } else if (Array.isArray(value)) {\n      value.forEach((v, index) => {\n        value[index] = this.renameTypes(v);\n      });\n      return value;\n    } else if (typeof value === 'object') {\n      Object.keys(value).forEach((key) => {\n        value[key] =\n          key === '__typename'\n            ? this.renamer(value[key])\n            : this.renameTypes(value[key]);\n      });\n      return value;\n    }\n\n    return value;\n  }\n}\n","import { GraphQLSchema, GraphQLNamedType } from 'graphql';\n\nimport { mapSchema } from '../../utils/index';\nimport { Transform, MapperKind } from '../../Interfaces';\n\nexport default class FilterTypes implements Transform {\n  private readonly filter: (type: GraphQLNamedType) => boolean;\n\n  constructor(filter: (type: GraphQLNamedType) => boolean) {\n    this.filter = filter;\n  }\n\n  public transformSchema(schema: GraphQLSchema): GraphQLSchema {\n    return mapSchema(schema, {\n      [MapperKind.TYPE]: (type: GraphQLNamedType) => {\n        if (this.filter(type)) {\n          return undefined;\n        }\n\n        return null;\n      },\n    });\n  }\n}\n","import {\n  visit,\n  GraphQLSchema,\n  NamedTypeNode,\n  Kind,\n  GraphQLObjectType,\n} from 'graphql';\n\nimport { Request, Result, MapperKind, Transform } from '../../Interfaces';\nimport { mapSchema } from '../../utils/index';\nimport { toConfig } from '../../polyfills/index';\n\nexport default class RenameRootTypes implements Transform {\n  private readonly renamer: (name: string) => string | undefined;\n  private map: { [key: string]: string };\n  private reverseMap: { [key: string]: string };\n\n  constructor(renamer: (name: string) => string | undefined) {\n    this.renamer = renamer;\n    this.map = {};\n    this.reverseMap = {};\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return mapSchema(originalSchema, {\n      [MapperKind.ROOT_OBJECT]: (type) => {\n        const oldName = type.name;\n        const newName = this.renamer(oldName);\n        if (newName && newName !== oldName) {\n          this.map[oldName] = type.name;\n          this.reverseMap[newName] = oldName;\n          return new GraphQLObjectType({\n            ...toConfig(type),\n            name: newName,\n          });\n        }\n      },\n    });\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const newDocument = visit(originalRequest.document, {\n      [Kind.NAMED_TYPE]: (node: NamedTypeNode) => {\n        const name = node.name.value;\n        if (name in this.reverseMap) {\n          return {\n            ...node,\n            name: {\n              kind: Kind.NAME,\n              value: this.reverseMap[name],\n            },\n          };\n        }\n      },\n    });\n    return {\n      document: newDocument,\n      variables: originalRequest.variables,\n    };\n  }\n\n  public transformResult(result: Result): Result {\n    return {\n      ...result,\n      data: this.renameTypes(result.data),\n    };\n  }\n\n  private renameTypes(value: any): any {\n    if (value == null) {\n      return value;\n    } else if (Array.isArray(value)) {\n      value.forEach((v, index) => {\n        value[index] = this.renameTypes(v);\n      });\n      return value;\n    } else if (typeof value === 'object') {\n      Object.keys(value).forEach((key) => {\n        value[key] =\n          key === '__typename'\n            ? this.renamer(value[key])\n            : this.renameTypes(value[key]);\n      });\n      return value;\n    }\n\n    return value;\n  }\n}\n","export default function isEmptyObject(obj: Record<string, any>): boolean {\n  if (obj == null) {\n    return true;\n  }\n\n  for (const key in obj) {\n    if (Object.hasOwnProperty.call(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import {\n  GraphQLSchema,\n  GraphQLType,\n  DocumentNode,\n  TypeInfo,\n  visit,\n  visitWithTypeInfo,\n  Kind,\n  SelectionSetNode,\n  SelectionNode,\n  FragmentDefinitionNode,\n  GraphQLInterfaceType,\n  isObjectType,\n  isInterfaceType,\n  GraphQLObjectType,\n} from 'graphql';\n\nimport isEmptyObject from '../../utils/isEmptyObject';\nimport {\n  Transform,\n  Request,\n  MapperKind,\n  FieldTransformer,\n  FieldNodeTransformer,\n  RenamedField,\n} from '../../Interfaces';\nimport { mapSchema } from '../../utils/index';\nimport { toConfig } from '../../polyfills/index';\n\ntype FieldMapping = {\n  [typeName: string]: {\n    [newFieldName: string]: string;\n  };\n};\n\nexport default class TransformCompositeFields implements Transform {\n  private readonly fieldTransformer: FieldTransformer;\n  private readonly fieldNodeTransformer: FieldNodeTransformer;\n  private transformedSchema: GraphQLSchema;\n  private mapping: FieldMapping;\n\n  constructor(\n    fieldTransformer: FieldTransformer,\n    fieldNodeTransformer?: FieldNodeTransformer,\n  ) {\n    this.fieldTransformer = fieldTransformer;\n    this.fieldNodeTransformer = fieldNodeTransformer;\n    this.mapping = {};\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    this.transformedSchema = mapSchema(originalSchema, {\n      [MapperKind.OBJECT_TYPE]: (type: GraphQLObjectType) =>\n        this.transformFields(type, this.fieldTransformer),\n      [MapperKind.INTERFACE_TYPE]: (type: GraphQLInterfaceType) =>\n        this.transformFields(type, this.fieldTransformer),\n    });\n\n    return this.transformedSchema;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const fragments = {};\n    originalRequest.document.definitions\n      .filter((def) => def.kind === Kind.FRAGMENT_DEFINITION)\n      .forEach((def) => {\n        fragments[(def as FragmentDefinitionNode).name.value] = def;\n      });\n    const document = this.transformDocument(\n      originalRequest.document,\n      this.mapping,\n      this.fieldNodeTransformer,\n      fragments,\n    );\n    return {\n      ...originalRequest,\n      document,\n    };\n  }\n\n  private transformFields(\n    type: GraphQLObjectType,\n    fieldTransformer: FieldTransformer,\n  ): GraphQLObjectType;\n\n  private transformFields(\n    type: GraphQLInterfaceType,\n    fieldTransformer: FieldTransformer,\n  ): GraphQLInterfaceType;\n\n  private transformFields(type: any, fieldTransformer: FieldTransformer): any {\n    const typeConfig = toConfig(type);\n    const fields = type.getFields();\n    const newFields = {};\n\n    Object.keys(fields).forEach((fieldName) => {\n      const field = fields[fieldName];\n      const transformedField = fieldTransformer(type.name, fieldName, field);\n\n      if (typeof transformedField === 'undefined') {\n        newFields[fieldName] = typeConfig.fields[fieldName];\n      } else if (transformedField !== null) {\n        const newName = (transformedField as RenamedField).name;\n\n        if (newName) {\n          newFields[newName] =\n            (transformedField as RenamedField).field != null\n              ? (transformedField as RenamedField).field\n              : typeConfig.fields[fieldName];\n\n          if (newName !== fieldName) {\n            const typeName = type.name;\n            if (!this.mapping[typeName]) {\n              this.mapping[typeName] = {};\n            }\n            this.mapping[typeName][newName] = fieldName;\n          }\n        } else {\n          newFields[fieldName] = transformedField;\n        }\n      }\n    });\n\n    if (isEmptyObject(newFields)) {\n      return null;\n    }\n\n    if (isObjectType(type)) {\n      return new GraphQLObjectType({\n        ...toConfig(type),\n        fields: newFields,\n      });\n    } else if (isInterfaceType(type)) {\n      return new GraphQLInterfaceType({\n        ...toConfig(type),\n        fields: newFields,\n      });\n    }\n  }\n\n  private transformDocument(\n    document: DocumentNode,\n    mapping: FieldMapping,\n    fieldNodeTransformer?: FieldNodeTransformer,\n    fragments: Record<string, FragmentDefinitionNode> = {},\n  ): DocumentNode {\n    const typeInfo = new TypeInfo(this.transformedSchema);\n    const newDocument: DocumentNode = visit(\n      document,\n      visitWithTypeInfo(typeInfo, {\n        leave: {\n          [Kind.SELECTION_SET]: (node: SelectionSetNode): SelectionSetNode => {\n            const parentType: GraphQLType = typeInfo.getParentType();\n            if (parentType != null) {\n              const parentTypeName = parentType.name;\n              let newSelections: Array<SelectionNode> = [];\n\n              node.selections.forEach((selection) => {\n                if (selection.kind !== Kind.FIELD) {\n                  newSelections.push(selection);\n                  return;\n                }\n\n                const newName = selection.name.value;\n\n                const transformedSelection =\n                  fieldNodeTransformer != null\n                    ? fieldNodeTransformer(\n                        parentTypeName,\n                        newName,\n                        selection,\n                        fragments,\n                      )\n                    : selection;\n\n                if (Array.isArray(transformedSelection)) {\n                  newSelections = newSelections.concat(transformedSelection);\n                  return;\n                }\n\n                if (transformedSelection.kind !== Kind.FIELD) {\n                  newSelections.push(transformedSelection);\n                  return;\n                }\n\n                const typeMapping = mapping[parentTypeName];\n                if (typeMapping == null) {\n                  newSelections.push(transformedSelection);\n                  return;\n                }\n\n                const oldName = mapping[parentTypeName][newName];\n                if (oldName == null) {\n                  newSelections.push(transformedSelection);\n                  return;\n                }\n\n                newSelections.push({\n                  ...transformedSelection,\n                  name: {\n                    kind: Kind.NAME,\n                    value: oldName,\n                  },\n                  alias: {\n                    kind: Kind.NAME,\n                    value: newName,\n                  },\n                });\n              });\n\n              return {\n                ...node,\n                selections: newSelections,\n              };\n            }\n          },\n        },\n      }),\n    );\n    return newDocument;\n  }\n}\n","import { GraphQLSchema, GraphQLField, isObjectType } from 'graphql';\n\nimport {\n  Transform,\n  Request,\n  FieldTransformer,\n  FieldNodeTransformer,\n} from '../../Interfaces';\n\nimport TransformCompositeFields from './TransformCompositeFields';\n\nexport default class TransformObjectFields implements Transform {\n  private readonly objectFieldTransformer: FieldTransformer;\n  private readonly fieldNodeTransformer: FieldNodeTransformer;\n  private transformer: TransformCompositeFields;\n\n  constructor(\n    objectFieldTransformer: FieldTransformer,\n    fieldNodeTransformer?: FieldNodeTransformer,\n  ) {\n    this.objectFieldTransformer = objectFieldTransformer;\n    this.fieldNodeTransformer = fieldNodeTransformer;\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    const compositeToObjectFieldTransformer = (\n      typeName: string,\n      fieldName: string,\n      field: GraphQLField<any, any>,\n    ) => {\n      if (isObjectType(originalSchema.getType(typeName))) {\n        return this.objectFieldTransformer(typeName, fieldName, field);\n      }\n\n      return undefined;\n    };\n\n    this.transformer = new TransformCompositeFields(\n      compositeToObjectFieldTransformer,\n      this.fieldNodeTransformer,\n    );\n\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLSchema, GraphQLField, GraphQLFieldConfig } from 'graphql';\n\nimport { Transform, Request, FieldNodeTransformer } from '../../Interfaces';\n\nimport TransformObjectFields from './TransformObjectFields';\n\nexport type RootTransformer = (\n  operation: 'Query' | 'Mutation' | 'Subscription',\n  fieldName: string,\n  field: GraphQLField<any, any>,\n) => GraphQLFieldConfig<any, any> | RenamedField | null | undefined;\n\ntype RenamedField = { name: string; field?: GraphQLFieldConfig<any, any> };\n\nexport default class TransformRootFields implements Transform {\n  private readonly transformer: TransformObjectFields;\n\n  constructor(\n    rootFieldTransformer: RootTransformer,\n    fieldNodeTransformer?: FieldNodeTransformer,\n  ) {\n    const rootToObjectFieldTransformer = (\n      typeName: string,\n      fieldName: string,\n      field: GraphQLField<any, any>,\n    ) => {\n      if (\n        typeName === 'Query' ||\n        typeName === 'Mutation' ||\n        typeName === 'Subscription'\n      ) {\n        return rootFieldTransformer(typeName, fieldName, field);\n      }\n\n      return undefined;\n    };\n    this.transformer = new TransformObjectFields(\n      rootToObjectFieldTransformer,\n      fieldNodeTransformer,\n    );\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLField, GraphQLSchema } from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\n\nimport TransformRootFields from './TransformRootFields';\n\nexport default class RenameRootFields implements Transform {\n  private readonly transformer: TransformRootFields;\n\n  constructor(\n    renamer: (\n      operation: 'Query' | 'Mutation' | 'Subscription',\n      name: string,\n      field: GraphQLField<any, any>,\n    ) => string,\n  ) {\n    this.transformer = new TransformRootFields(\n      (\n        operation: 'Query' | 'Mutation' | 'Subscription',\n        fieldName: string,\n        field: GraphQLField<any, any>,\n      ) => ({\n        name: renamer(operation, fieldName, field),\n      }),\n    );\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLField, GraphQLSchema } from 'graphql';\n\nimport { Transform } from '../../Interfaces';\n\nimport TransformRootFields from './TransformRootFields';\n\nexport type RootFilter = (\n  operation: 'Query' | 'Mutation' | 'Subscription',\n  fieldName: string,\n  field: GraphQLField<any, any>,\n) => boolean;\n\nexport default class FilterRootFields implements Transform {\n  private readonly transformer: TransformRootFields;\n\n  constructor(filter: RootFilter) {\n    this.transformer = new TransformRootFields(\n      (\n        operation: 'Query' | 'Mutation' | 'Subscription',\n        fieldName: string,\n        field: GraphQLField<any, any>,\n      ) => {\n        if (filter(operation, fieldName, field)) {\n          return undefined;\n        }\n\n        return null;\n      },\n    );\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(originalSchema);\n  }\n}\n","import { GraphQLField, GraphQLSchema } from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\n\nimport TransformObjectFields from './TransformObjectFields';\n\nexport default class RenameObjectFields implements Transform {\n  private readonly transformer: TransformObjectFields;\n\n  constructor(\n    renamer: (\n      typeName: string,\n      fieldName: string,\n      field: GraphQLField<any, any>,\n    ) => string,\n  ) {\n    this.transformer = new TransformObjectFields(\n      (typeName: string, fieldName: string, field: GraphQLField<any, any>) => ({\n        name: renamer(typeName, fieldName, field),\n      }),\n    );\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLField, GraphQLSchema } from 'graphql';\n\nimport { Transform, FieldFilter } from '../../Interfaces';\n\nimport TransformObjectFields from './TransformObjectFields';\n\nexport default class FilterObjectFields implements Transform {\n  private readonly transformer: TransformObjectFields;\n\n  constructor(filter: FieldFilter) {\n    this.transformer = new TransformObjectFields(\n      (typeName: string, fieldName: string, field: GraphQLField<any, any>) =>\n        filter(typeName, fieldName, field) ? undefined : null,\n    );\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(originalSchema);\n  }\n}\n","import { GraphQLSchema, GraphQLField, isInterfaceType } from 'graphql';\n\nimport {\n  Transform,\n  Request,\n  FieldTransformer,\n  FieldNodeTransformer,\n} from '../../Interfaces';\n\nimport TransformCompositeFields from './TransformCompositeFields';\n\nexport default class TransformInterfaceFields implements Transform {\n  private readonly interfaceFieldTransformer: FieldTransformer;\n  private readonly fieldNodeTransformer: FieldNodeTransformer;\n  private transformer: TransformCompositeFields;\n\n  constructor(\n    interfaceFieldTransformer: FieldTransformer,\n    fieldNodeTransformer?: FieldNodeTransformer,\n  ) {\n    this.interfaceFieldTransformer = interfaceFieldTransformer;\n    this.fieldNodeTransformer = fieldNodeTransformer;\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    const compositeToObjectFieldTransformer = (\n      typeName: string,\n      fieldName: string,\n      field: GraphQLField<any, any>,\n    ) => {\n      if (isInterfaceType(originalSchema.getType(typeName))) {\n        return this.interfaceFieldTransformer(typeName, fieldName, field);\n      }\n\n      return undefined;\n    };\n\n    this.transformer = new TransformCompositeFields(\n      compositeToObjectFieldTransformer,\n      this.fieldNodeTransformer,\n    );\n\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLField, GraphQLSchema } from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\n\nimport TransformInterfaceFields from './TransformInterfaceFields';\n\nexport default class RenameInterfaceFields implements Transform {\n  private readonly transformer: TransformInterfaceFields;\n\n  constructor(\n    renamer: (\n      typeName: string,\n      fieldName: string,\n      field: GraphQLField<any, any>,\n    ) => string,\n  ) {\n    this.transformer = new TransformInterfaceFields(\n      (typeName: string, fieldName: string, field: GraphQLField<any, any>) => ({\n        name: renamer(typeName, fieldName, field),\n      }),\n    );\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLField, GraphQLSchema } from 'graphql';\n\nimport { Transform, FieldFilter } from '../../Interfaces';\n\nimport TransformInterfaceFields from './TransformInterfaceFields';\n\nexport default class FilterInterfaceFields implements Transform {\n  private readonly transformer: TransformInterfaceFields;\n\n  constructor(filter: FieldFilter) {\n    this.transformer = new TransformInterfaceFields(\n      (typeName: string, fieldName: string, field: GraphQLField<any, any>) =>\n        filter(typeName, fieldName, field) ? undefined : null,\n    );\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(originalSchema);\n  }\n}\n","import {\n  visit,\n  Kind,\n  SelectionSetNode,\n  FragmentDefinitionNode,\n  GraphQLError,\n} from 'graphql';\n\nimport { Transform, Request, Result } from '../../Interfaces';\n\nexport type QueryTransformer = (\n  selectionSet: SelectionSetNode,\n  fragments: Record<string, FragmentDefinitionNode>,\n) => SelectionSetNode;\n\nexport type ResultTransformer = (result: any) => any;\n\nexport type ErrorPathTransformer = (\n  path: ReadonlyArray<string | number>,\n) => Array<string | number>;\n\nexport default class TransformQuery implements Transform {\n  private readonly path: Array<string>;\n  private readonly queryTransformer: QueryTransformer;\n  private readonly resultTransformer: ResultTransformer;\n  private readonly errorPathTransformer: ErrorPathTransformer;\n  private readonly fragments: Record<string, FragmentDefinitionNode>;\n\n  constructor({\n    path,\n    queryTransformer,\n    resultTransformer = (result) => result,\n    errorPathTransformer = (errorPath) => [].concat(errorPath),\n    fragments = {},\n  }: {\n    path: Array<string>;\n    queryTransformer: QueryTransformer;\n    resultTransformer?: ResultTransformer;\n    errorPathTransformer?: ErrorPathTransformer;\n    fragments?: Record<string, FragmentDefinitionNode>;\n  }) {\n    this.path = path;\n    this.queryTransformer = queryTransformer;\n    this.resultTransformer = resultTransformer;\n    this.errorPathTransformer = errorPathTransformer;\n    this.fragments = fragments;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = originalRequest.document;\n\n    const pathLength = this.path.length;\n    let index = 0;\n    const newDocument = visit(document, {\n      [Kind.FIELD]: {\n        enter: (node) => {\n          if (index === pathLength || node.name.value !== this.path[index]) {\n            return false;\n          }\n\n          index++;\n\n          if (index === pathLength) {\n            const selectionSet = this.queryTransformer(\n              node.selectionSet,\n              this.fragments,\n            );\n\n            return {\n              ...node,\n              selectionSet,\n            };\n          }\n        },\n        leave: () => {\n          index--;\n        },\n      },\n    });\n    return {\n      ...originalRequest,\n      document: newDocument,\n    };\n  }\n\n  public transformResult(originalResult: Result): Result {\n    const data = this.transformData(originalResult.data);\n    const errors = originalResult.errors;\n    return {\n      data,\n      errors: errors != null ? this.transformErrors(errors) : undefined,\n    };\n  }\n\n  private transformData(data: any): any {\n    const leafIndex = this.path.length - 1;\n    let index = 0;\n    let newData = data;\n    if (newData) {\n      let next = this.path[index];\n      while (index < leafIndex) {\n        if (data[next]) {\n          newData = newData[next];\n        } else {\n          break;\n        }\n        index++;\n        next = this.path[index];\n      }\n      newData[next] = this.resultTransformer(newData[next]);\n    }\n    return newData;\n  }\n\n  private transformErrors(\n    errors: ReadonlyArray<GraphQLError>,\n  ): ReadonlyArray<GraphQLError> {\n    return errors.map((error) => {\n      const path: ReadonlyArray<string | number> = error.path;\n\n      let match = true;\n      let index = 0;\n      while (index < this.path.length) {\n        if (path[index] !== this.path[index]) {\n          match = false;\n          break;\n        }\n        index++;\n      }\n\n      const newPath = match\n        ? path\n            .slice(0, index)\n            .concat(this.errorPathTransformer(path.slice(index)))\n        : path;\n\n      return new GraphQLError(\n        error.message,\n        error.nodes,\n        error.source,\n        error.positions,\n        newPath,\n        error.originalError,\n        error.extensions,\n      );\n    });\n  }\n}\n","import {\n  GraphQLSchema,\n  FieldNode,\n  SelectionNode,\n  FragmentDefinitionNode,\n} from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\nimport { toConfig } from '../../polyfills/index';\n\nimport TransformObjectFields from './TransformObjectFields';\n\nexport type FieldNodeTransformer = (\n  fieldNode: FieldNode,\n  fragments: Record<string, FragmentDefinitionNode>,\n) => SelectionNode | Array<SelectionNode>;\n\nexport type FieldNodeTransformerMap = {\n  [typeName: string]: {\n    [fieldName: string]: FieldNodeTransformer;\n  };\n};\n\nexport default class MapFields implements Transform {\n  private readonly transformer: TransformObjectFields;\n\n  constructor(fieldNodeTransformerMap: FieldNodeTransformerMap) {\n    this.transformer = new TransformObjectFields(\n      (_typeName, _fieldName, field) => toConfig(field),\n      (typeName, fieldName, fieldNode, fragments) => {\n        const typeTransformers = fieldNodeTransformerMap[typeName];\n        if (typeTransformers == null) {\n          return fieldNode;\n        }\n\n        const fieldNodeTransformer = typeTransformers[fieldName];\n        if (fieldNodeTransformer == null) {\n          return fieldNode;\n        }\n\n        return fieldNodeTransformer(fieldNode, fragments);\n      },\n    );\n  }\n\n  public transformSchema(schema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(schema);\n  }\n\n  public transformRequest(request: Request): Request {\n    return this.transformer.transformRequest(request);\n  }\n}\n","import { GraphQLSchema, extendSchema, parse } from 'graphql';\n\nimport {\n  Transform,\n  IFieldResolver,\n  IResolvers,\n  Request,\n} from '../../Interfaces';\nimport { addResolversToSchema } from '../../generate/index';\nimport { defaultMergedResolver } from '../../stitch/index';\n\nimport MapFields, { FieldNodeTransformerMap } from './MapFields';\n\nexport default class ExtendSchema implements Transform {\n  private readonly typeDefs: string | undefined;\n  private readonly resolvers: IResolvers | undefined;\n  private readonly defaultFieldResolver: IFieldResolver<any, any> | undefined;\n  private readonly transformer: MapFields;\n\n  constructor({\n    typeDefs,\n    resolvers = {},\n    defaultFieldResolver,\n    fieldNodeTransformerMap,\n  }: {\n    typeDefs?: string;\n    resolvers?: IResolvers;\n    defaultFieldResolver?: IFieldResolver<any, any>;\n    fieldNodeTransformerMap?: FieldNodeTransformerMap;\n  }) {\n    this.typeDefs = typeDefs;\n    this.resolvers = resolvers;\n    this.defaultFieldResolver =\n      defaultFieldResolver != null\n        ? defaultFieldResolver\n        : defaultMergedResolver;\n    this.transformer = new MapFields(\n      fieldNodeTransformerMap != null ? fieldNodeTransformerMap : {},\n    );\n  }\n\n  public transformSchema(schema: GraphQLSchema): GraphQLSchema {\n    this.transformer.transformSchema(schema);\n\n    return addResolversToSchema({\n      schema: this.typeDefs\n        ? extendSchema(schema, parse(this.typeDefs))\n        : schema,\n      resolvers: this.resolvers != null ? this.resolvers : {},\n      defaultFieldResolver: this.defaultFieldResolver,\n    });\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLSchema, GraphQLObjectType } from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\nimport {\n  hoistFieldNodes,\n  healSchema,\n  appendFields,\n  removeFields,\n} from '../../utils/index';\nimport {\n  defaultMergedResolver,\n  createMergedResolver,\n} from '../../stitch/index';\n\nimport MapFields from './MapFields';\n\nexport default class WrapFields implements Transform {\n  private readonly outerTypeName: string;\n  private readonly wrappingFieldNames: Array<string>;\n  private readonly wrappingTypeNames: Array<string>;\n  private readonly numWraps: number;\n  private readonly fieldNames: Array<string>;\n  private readonly transformer: Transform;\n\n  constructor(\n    outerTypeName: string,\n    wrappingFieldNames: Array<string>,\n    wrappingTypeNames: Array<string>,\n    fieldNames?: Array<string>,\n  ) {\n    this.outerTypeName = outerTypeName;\n    this.wrappingFieldNames = wrappingFieldNames;\n    this.wrappingTypeNames = wrappingTypeNames;\n    this.numWraps = wrappingFieldNames.length;\n    this.fieldNames = fieldNames;\n\n    const remainingWrappingFieldNames = this.wrappingFieldNames.slice();\n    const outerMostWrappingFieldName = remainingWrappingFieldNames.shift();\n    this.transformer = new MapFields({\n      [outerTypeName]: {\n        [outerMostWrappingFieldName]: (fieldNode, fragments) =>\n          hoistFieldNodes({\n            fieldNode,\n            path: remainingWrappingFieldNames,\n            fieldNames: this.fieldNames,\n            fragments,\n          }),\n      },\n    });\n  }\n\n  public transformSchema(schema: GraphQLSchema): GraphQLSchema {\n    const typeMap = schema.getTypeMap();\n\n    const targetFields = removeFields(\n      typeMap,\n      this.outerTypeName,\n      !this.fieldNames\n        ? () => true\n        : (fieldName) => this.fieldNames.includes(fieldName),\n    );\n\n    let wrapIndex = this.numWraps - 1;\n\n    const innerMostWrappingTypeName = this.wrappingTypeNames[wrapIndex];\n    appendFields(typeMap, innerMostWrappingTypeName, targetFields);\n\n    for (wrapIndex--; wrapIndex > -1; wrapIndex--) {\n      appendFields(typeMap, this.wrappingTypeNames[wrapIndex], {\n        [this.wrappingFieldNames[wrapIndex + 1]]: {\n          type: typeMap[\n            this.wrappingTypeNames[wrapIndex + 1]\n          ] as GraphQLObjectType,\n          resolve: defaultMergedResolver,\n        },\n      });\n    }\n\n    appendFields(typeMap, this.outerTypeName, {\n      [this.wrappingFieldNames[0]]: {\n        type: typeMap[this.wrappingTypeNames[0]] as GraphQLObjectType,\n        resolve: createMergedResolver({ dehoist: true }),\n      },\n    });\n\n    healSchema(schema);\n\n    return this.transformer.transformSchema(schema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLSchema } from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\n\nimport WrapFields from './WrapFields';\n\nexport default class WrapType implements Transform {\n  private readonly transformer: Transform;\n\n  constructor(outerTypeName: string, innerTypeName: string, fieldName: string) {\n    this.transformer = new WrapFields(\n      outerTypeName,\n      [fieldName],\n      [innerTypeName],\n      undefined,\n    );\n  }\n\n  public transformSchema(schema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(schema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLSchema, GraphQLObjectType, getNullableType } from 'graphql';\n\nimport { healSchema, wrapFieldNode, renameFieldNode } from '../../utils/index';\nimport { createMergedResolver } from '../../stitch/index';\nimport { appendFields, removeFields } from '../../utils/fields';\nimport { Transform, Request } from '../../Interfaces';\n\nimport MapFields from './MapFields';\n\nexport default class HoistField implements Transform {\n  private readonly typeName: string;\n  private readonly path: Array<string>;\n  private readonly newFieldName: string;\n  private readonly pathToField: Array<string>;\n  private readonly oldFieldName: string;\n  private readonly transformer: Transform;\n\n  constructor(typeName: string, path: Array<string>, newFieldName: string) {\n    this.typeName = typeName;\n    this.path = path;\n    this.newFieldName = newFieldName;\n\n    this.pathToField = this.path.slice();\n    this.oldFieldName = this.pathToField.pop();\n    this.transformer = new MapFields({\n      [typeName]: {\n        [newFieldName]: (fieldNode) =>\n          wrapFieldNode(\n            renameFieldNode(fieldNode, this.oldFieldName),\n            this.pathToField,\n          ),\n      },\n    });\n  }\n\n  public transformSchema(schema: GraphQLSchema): GraphQLSchema {\n    const typeMap = schema.getTypeMap();\n\n    const innerType: GraphQLObjectType = this.pathToField.reduce(\n      (acc, pathSegment) =>\n        getNullableType(acc.getFields()[pathSegment].type) as GraphQLObjectType,\n      typeMap[this.typeName] as GraphQLObjectType,\n    );\n\n    const targetField = removeFields(\n      typeMap,\n      innerType.name,\n      (fieldName) => fieldName === this.oldFieldName,\n    )[this.oldFieldName];\n\n    const targetType = targetField.type as GraphQLObjectType;\n\n    appendFields(typeMap, this.typeName, {\n      [this.newFieldName]: {\n        type: targetType,\n        resolve: createMergedResolver({ fromPath: this.pathToField }),\n      },\n    });\n\n    healSchema(schema);\n\n    return this.transformer.transformSchema(schema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import {\n  DocumentNode,\n  GraphQLSchema,\n  GraphQLType,\n  InlineFragmentNode,\n  Kind,\n  SelectionSetNode,\n  TypeInfo,\n  OperationDefinitionNode,\n  parse,\n  visit,\n  visitWithTypeInfo,\n} from 'graphql';\n\nimport { concatInlineFragments } from '../../utils/index';\nimport { Transform, Request } from '../../Interfaces';\n\nexport default class ReplaceFieldWithFragment implements Transform {\n  private readonly targetSchema: GraphQLSchema;\n  private readonly mapping: FieldToFragmentMapping;\n\n  constructor(\n    targetSchema: GraphQLSchema,\n    fragments: Array<{\n      field: string;\n      fragment: string;\n    }>,\n  ) {\n    this.targetSchema = targetSchema;\n    this.mapping = {};\n    for (const { field, fragment } of fragments) {\n      const parsedFragment = parseFragmentToInlineFragment(fragment);\n      const actualTypeName = parsedFragment.typeCondition.name.value;\n      if (this.mapping[actualTypeName] == null) {\n        this.mapping[actualTypeName] = {};\n      }\n\n      if (this.mapping[actualTypeName][field] == null) {\n        this.mapping[actualTypeName][field] = [parsedFragment];\n      } else {\n        this.mapping[actualTypeName][field].push(parsedFragment);\n      }\n    }\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = replaceFieldsWithFragments(\n      this.targetSchema,\n      originalRequest.document,\n      this.mapping,\n    );\n    return {\n      ...originalRequest,\n      document,\n    };\n  }\n}\n\ntype FieldToFragmentMapping = {\n  [typeName: string]: { [fieldName: string]: Array<InlineFragmentNode> };\n};\n\nfunction replaceFieldsWithFragments(\n  targetSchema: GraphQLSchema,\n  document: DocumentNode,\n  mapping: FieldToFragmentMapping,\n): DocumentNode {\n  const typeInfo = new TypeInfo(targetSchema);\n  return visit(\n    document,\n    visitWithTypeInfo(typeInfo, {\n      [Kind.SELECTION_SET](\n        node: SelectionSetNode,\n      ): SelectionSetNode | null | undefined {\n        const parentType: GraphQLType = typeInfo.getParentType();\n        if (parentType != null) {\n          const parentTypeName = parentType.name;\n          let selections = node.selections;\n\n          if (mapping[parentTypeName] != null) {\n            node.selections.forEach((selection) => {\n              if (selection.kind === Kind.FIELD) {\n                const name = selection.name.value;\n                const fragments = mapping[parentTypeName][name];\n                if (fragments != null && fragments.length > 0) {\n                  const fragment = concatInlineFragments(\n                    parentTypeName,\n                    fragments,\n                  );\n                  selections = selections.concat(fragment);\n                }\n              }\n            });\n          }\n\n          if (selections !== node.selections) {\n            return {\n              ...node,\n              selections,\n            };\n          }\n        }\n      },\n    }),\n  );\n}\n\nfunction parseFragmentToInlineFragment(\n  definitions: string,\n): InlineFragmentNode {\n  if (definitions.trim().startsWith('fragment')) {\n    const document = parse(definitions);\n    for (const definition of document.definitions) {\n      if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n        return {\n          kind: Kind.INLINE_FRAGMENT,\n          typeCondition: definition.typeCondition,\n          selectionSet: definition.selectionSet,\n        };\n      }\n    }\n  }\n\n  const query = parse(`{${definitions}}`)\n    .definitions[0] as OperationDefinitionNode;\n  for (const selection of query.selectionSet.selections) {\n    if (selection.kind === Kind.INLINE_FRAGMENT) {\n      return selection;\n    }\n  }\n\n  throw new Error('Could not parse fragment');\n}\n","import {\n  FieldNode,\n  visit,\n  Kind,\n  SelectionNode,\n  SelectionSetNode,\n} from 'graphql';\n\nimport { Transform, Request, Result } from '../../Interfaces';\n\nexport type QueryWrapper = (\n  subtree: SelectionSetNode,\n) => SelectionNode | SelectionSetNode;\n\nexport default class WrapQuery implements Transform {\n  private readonly wrapper: QueryWrapper;\n  private readonly extractor: (result: any) => any;\n  private readonly path: Array<string>;\n\n  constructor(\n    path: Array<string>,\n    wrapper: QueryWrapper,\n    extractor: (result: any) => any,\n  ) {\n    this.path = path;\n    this.wrapper = wrapper;\n    this.extractor = extractor;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = originalRequest.document;\n    const fieldPath: Array<string> = [];\n    const ourPath = JSON.stringify(this.path);\n    const newDocument = visit(document, {\n      [Kind.FIELD]: {\n        enter: (node: FieldNode) => {\n          fieldPath.push(node.name.value);\n          if (ourPath === JSON.stringify(fieldPath)) {\n            const wrapResult = this.wrapper(node.selectionSet);\n\n            // Selection can be either a single selection or a selection set. If it's just one selection,\n            // let's wrap it in a selection set. Otherwise, keep it as is.\n            const selectionSet =\n              wrapResult != null && wrapResult.kind === Kind.SELECTION_SET\n                ? wrapResult\n                : {\n                    kind: Kind.SELECTION_SET,\n                    selections: [wrapResult],\n                  };\n\n            return {\n              ...node,\n              selectionSet,\n            };\n          }\n        },\n        leave: () => {\n          fieldPath.pop();\n        },\n      },\n    });\n    return {\n      ...originalRequest,\n      document: newDocument,\n    };\n  }\n\n  public transformResult(originalResult: Result): Result {\n    const rootData = originalResult.data;\n    if (rootData != null) {\n      let data = rootData;\n      const path = [...this.path];\n      while (path.length > 1) {\n        const next = path.shift();\n        if (data[next]) {\n          data = data[next];\n        }\n      }\n      data[path[0]] = this.extractor(data[path[0]]);\n    }\n\n    return {\n      data: rootData,\n      errors: originalResult.errors,\n    };\n  }\n}\n","import { visit, Kind, SelectionSetNode, BREAK, FieldNode } from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\n\nexport default class ExtractField implements Transform {\n  private readonly from: Array<string>;\n  private readonly to: Array<string>;\n\n  constructor({ from, to }: { from: Array<string>; to: Array<string> }) {\n    this.from = from;\n    this.to = to;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    let fromSelection: SelectionSetNode | undefined;\n    const ourPathFrom = JSON.stringify(this.from);\n    const ourPathTo = JSON.stringify(this.to);\n    let fieldPath: Array<string> = [];\n    visit(originalRequest.document, {\n      [Kind.FIELD]: {\n        enter: (node: FieldNode) => {\n          fieldPath.push(node.name.value);\n          if (ourPathFrom === JSON.stringify(fieldPath)) {\n            fromSelection = node.selectionSet;\n            return BREAK;\n          }\n        },\n        leave: () => {\n          fieldPath.pop();\n        },\n      },\n    });\n\n    fieldPath = [];\n    const newDocument = visit(originalRequest.document, {\n      [Kind.FIELD]: {\n        enter: (node: FieldNode) => {\n          fieldPath.push(node.name.value);\n          if (\n            ourPathTo === JSON.stringify(fieldPath) &&\n            fromSelection != null\n          ) {\n            return {\n              ...node,\n              selectionSet: fromSelection,\n            };\n          }\n        },\n        leave: () => {\n          fieldPath.pop();\n        },\n      },\n    });\n    return {\n      ...originalRequest,\n      document: newDocument,\n    };\n  }\n}\n","import { ApolloLink } from 'apollo-link';\nimport {\n  GraphQLFieldResolver,\n  GraphQLSchema,\n  Kind,\n  GraphQLResolveInfo,\n  BuildSchemaOptions,\n  DocumentNode,\n} from 'graphql';\n\nimport { addResolversToSchema } from '../generate/index';\nimport { Fetcher, Operation } from '../Interfaces';\nimport { cloneSchema } from '../utils/index';\nimport { buildSchema } from '../polyfills/index';\nimport { addTypenameToAbstract } from '../delegate/addTypenameToAbstract';\nimport { checkResultAndHandleErrors } from '../delegate/checkResultAndHandleErrors';\n\nimport linkToFetcher, { execute } from '../stitch/linkToFetcher';\nimport { observableToAsyncIterable } from '../stitch/observableToAsyncIterable';\nimport mapAsyncIterator from '../stitch/mapAsyncIterator';\n\nimport { stripResolvers, generateProxyingResolvers } from './resolvers';\n\nexport type ResolverFn = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: GraphQLResolveInfo,\n) => AsyncIterator<any>;\n\nexport default function makeRemoteExecutableSchema({\n  schema: schemaOrTypeDefs,\n  link,\n  fetcher,\n  createResolver: customCreateResolver = createResolver,\n  buildSchemaOptions,\n}: {\n  schema: GraphQLSchema | string;\n  link?: ApolloLink;\n  fetcher?: Fetcher;\n  createResolver?: (fetcher: Fetcher) => GraphQLFieldResolver<any, any>;\n  buildSchemaOptions?: BuildSchemaOptions;\n}): GraphQLSchema {\n  let finalFetcher: Fetcher = fetcher;\n\n  if (finalFetcher == null && link != null) {\n    finalFetcher = linkToFetcher(link);\n  }\n\n  const targetSchema =\n    typeof schemaOrTypeDefs === 'string'\n      ? buildSchema(schemaOrTypeDefs, buildSchemaOptions)\n      : schemaOrTypeDefs;\n\n  const remoteSchema = cloneSchema(targetSchema);\n  stripResolvers(remoteSchema);\n\n  function createProxyingResolver({\n    operation,\n  }: {\n    operation: Operation;\n  }): GraphQLFieldResolver<any, any> {\n    if (operation === 'query' || operation === 'mutation') {\n      return customCreateResolver(finalFetcher);\n    }\n    return createSubscriptionResolver(link);\n  }\n\n  addResolversToSchema({\n    schema: remoteSchema,\n    resolvers: generateProxyingResolvers({\n      subschemaConfig: { schema: remoteSchema },\n      createProxyingResolver,\n    }),\n    resolverValidationOptions: {\n      allowResolversNotInSchema: true,\n    },\n  });\n\n  return remoteSchema;\n}\n\nexport function createResolver(\n  fetcher: Fetcher,\n): GraphQLFieldResolver<any, any> {\n  return async (_root, _args, context, info) => {\n    const fragments = Object.keys(info.fragments).map(\n      (fragment) => info.fragments[fragment],\n    );\n    let query: DocumentNode = {\n      kind: Kind.DOCUMENT,\n      definitions: [info.operation, ...fragments],\n    };\n\n    query = addTypenameToAbstract(info.schema, query);\n\n    const result = await fetcher({\n      query,\n      variables: info.variableValues,\n      context: { graphqlContext: context },\n    });\n    return checkResultAndHandleErrors(result, context, info);\n  };\n}\n\nfunction createSubscriptionResolver(link: ApolloLink): ResolverFn {\n  return (_root, _args, context, info) => {\n    const fragments = Object.keys(info.fragments).map(\n      (fragment) => info.fragments[fragment],\n    );\n    let query: DocumentNode = {\n      kind: Kind.DOCUMENT,\n      definitions: [info.operation, ...fragments],\n    };\n\n    query = addTypenameToAbstract(info.schema, query);\n\n    const operation = {\n      query,\n      variables: info.variableValues,\n      context: { graphqlContext: context },\n    };\n\n    const observable = execute(link, operation);\n    const originalAsyncIterator = observableToAsyncIterable(observable);\n    return mapAsyncIterator(originalAsyncIterator, (result) => ({\n      [info.fieldName]: checkResultAndHandleErrors(result, context, info),\n    }));\n  };\n}\n"],"names":["isAbstractType","Kind","visit","isObjectType","isInterfaceType","GraphQLError","_typeof","isFinite","printError","isUnionType","isEnumType","isScalarType","isInputObjectType","GraphQLString","GraphQLInt","GraphQLFloat","GraphQLBoolean","GraphQLID","GraphQLDirective","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLInputObjectType","GraphQLEnumType","GraphQLScalarType","isListType","GraphQLList","isNonNullType","GraphQLNonNull","graphqlExtendSchema","hasOwn","pruneTypes","valueFromASTUntyped","getTypeSpecifiers","collectFields","typeFromAST","AddMergedTypeSelectionSets","execute","executeLink","print","extendSchema","uuid","isObject","DirectiveLocation","parseFragmentToInlineFragment","replaceFieldsWithFragments","BREAK"],"mappings":"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"}