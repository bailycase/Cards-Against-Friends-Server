import { __spreadArrays, __assign, __extends, __rest, __awaiter, __generator } from 'tslib';
import { $$asyncIterator, isAsyncIterable } from 'iterall';
import { toPromise, execute, ApolloLink, fromError, Observable } from 'apollo-link';
import { isCompositeType, doTypesOverlap, visit as visit$1, visitWithTypeInfo, Kind as Kind$1, getNamedType, TypeInfo, isAbstractType as isAbstractType$1, isObjectType as isObjectType$1, isInterfaceType as isInterfaceType$1, TypeNameMetaFieldDef, GraphQLError as GraphQLError$1, versionInfo, getOperationRootType, lexicographicSortSchema, printError as printError$1, isSchema, isDirective, isNamedType, isUnionType as isUnionType$1, isEnumType as isEnumType$1, isScalarType as isScalarType$1, isInputObjectType as isInputObjectType$1, GraphQLString as GraphQLString$1, GraphQLInt as GraphQLInt$1, GraphQLFloat as GraphQLFloat$1, GraphQLBoolean as GraphQLBoolean$1, GraphQLID as GraphQLID$1, GraphQLSchema, GraphQLDirective as GraphQLDirective$1, GraphQLObjectType as GraphQLObjectType$1, GraphQLInterfaceType as GraphQLInterfaceType$1, GraphQLUnionType as GraphQLUnionType$1, GraphQLInputObjectType as GraphQLInputObjectType$1, GraphQLEnumType as GraphQLEnumType$1, GraphQLScalarType as GraphQLScalarType$1, isListType as isListType$1, GraphQLList as GraphQLList$1, isNonNullType as isNonNullType$1, GraphQLNonNull as GraphQLNonNull$1, isInputType, buildASTSchema, parse, extendSchema as extendSchema$1, isLeafType, getNullableType, responsePathAsArray, typeFromAST as typeFromAST$2, validate, execute as execute$1, subscribe, defaultFieldResolver, print as print$1, graphql, buildClientSchema, getIntrospectionQuery, DirectiveLocation as DirectiveLocation$1, TokenKind, BREAK as BREAK$1 } from 'graphql';
import { deprecated } from 'deprecated-decorator';
import { selectURI, selectHttpOptionsAndBody, fallbackHttpConfig, createSignalIfSupported, parseAndCheckHttpResponse, serializeFetchParameter } from 'apollo-link-http-common';
import { extractFiles, isExtractableFile } from 'extract-files';
import KnownLengthFormData from 'form-data';
import fetch from 'node-fetch';
import { v4 } from 'uuid';

function isSubschemaConfig(value) {
    return Boolean(value.schema);
}
var VisitSchemaKind;
(function (VisitSchemaKind) {
    VisitSchemaKind["TYPE"] = "VisitSchemaKind.TYPE";
    VisitSchemaKind["SCALAR_TYPE"] = "VisitSchemaKind.SCALAR_TYPE";
    VisitSchemaKind["ENUM_TYPE"] = "VisitSchemaKind.ENUM_TYPE";
    VisitSchemaKind["COMPOSITE_TYPE"] = "VisitSchemaKind.COMPOSITE_TYPE";
    VisitSchemaKind["OBJECT_TYPE"] = "VisitSchemaKind.OBJECT_TYPE";
    VisitSchemaKind["INPUT_OBJECT_TYPE"] = "VisitSchemaKind.INPUT_OBJECT_TYPE";
    VisitSchemaKind["ABSTRACT_TYPE"] = "VisitSchemaKind.ABSTRACT_TYPE";
    VisitSchemaKind["UNION_TYPE"] = "VisitSchemaKind.UNION_TYPE";
    VisitSchemaKind["INTERFACE_TYPE"] = "VisitSchemaKind.INTERFACE_TYPE";
    VisitSchemaKind["ROOT_OBJECT"] = "VisitSchemaKind.ROOT_OBJECT";
    VisitSchemaKind["QUERY"] = "VisitSchemaKind.QUERY";
    VisitSchemaKind["MUTATION"] = "VisitSchemaKind.MUTATION";
    VisitSchemaKind["SUBSCRIPTION"] = "VisitSchemaKind.SUBSCRIPTION";
})(VisitSchemaKind || (VisitSchemaKind = {}));
var MapperKind;
(function (MapperKind) {
    MapperKind["TYPE"] = "MapperKind.TYPE";
    MapperKind["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
    MapperKind["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
    MapperKind["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
    MapperKind["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
    MapperKind["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
    MapperKind["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
    MapperKind["UNION_TYPE"] = "MapperKind.UNION_TYPE";
    MapperKind["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
    MapperKind["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
    MapperKind["QUERY"] = "MapperKind.QUERY";
    MapperKind["MUTATION"] = "MapperKind.MUTATION";
    MapperKind["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
    MapperKind["DIRECTIVE"] = "MapperKind.DIRECTIVE";
})(MapperKind || (MapperKind = {}));

function implementsAbstractType(schema, typeA, typeB) {
    if (typeA === typeB) {
        return true;
    }
    else if (isCompositeType(typeA) && isCompositeType(typeB)) {
        return doTypesOverlap(schema, typeA, typeB);
    }
    return false;
}

var ExpandAbstractTypes = /** @class */ (function () {
    function ExpandAbstractTypes(sourceSchema, targetSchema) {
        this.targetSchema = targetSchema;
        this.mapping = extractPossibleTypes(sourceSchema, targetSchema);
        this.reverseMapping = flipMapping(this.mapping);
    }
    ExpandAbstractTypes.prototype.transformRequest = function (originalRequest) {
        var document = expandAbstractTypes(this.targetSchema, this.mapping, this.reverseMapping, originalRequest.document);
        return __assign(__assign({}, originalRequest), { document: document });
    };
    return ExpandAbstractTypes;
}());
function extractPossibleTypes(sourceSchema, targetSchema) {
    var typeMap = sourceSchema.getTypeMap();
    var mapping = {};
    Object.keys(typeMap).forEach(function (typeName) {
        var type = typeMap[typeName];
        if (isAbstractType$1(type)) {
            var targetType = targetSchema.getType(typeName);
            if (!isAbstractType$1(targetType)) {
                var implementations = sourceSchema.getPossibleTypes(type);
                mapping[typeName] = implementations
                    .filter(function (impl) { return targetSchema.getType(impl.name); })
                    .map(function (impl) { return impl.name; });
            }
        }
    });
    return mapping;
}
function flipMapping(mapping) {
    var result = {};
    Object.keys(mapping).forEach(function (typeName) {
        var toTypeNames = mapping[typeName];
        toTypeNames.forEach(function (toTypeName) {
            if (result[toTypeName] == null) {
                result[toTypeName] = [];
            }
            result[toTypeName].push(typeName);
        });
    });
    return result;
}
function expandAbstractTypes(targetSchema, mapping, reverseMapping, document) {
    var _a;
    var operations = document.definitions.filter(function (def) { return def.kind === Kind$1.OPERATION_DEFINITION; });
    var fragments = document.definitions.filter(function (def) { return def.kind === Kind$1.FRAGMENT_DEFINITION; });
    var existingFragmentNames = fragments.map(function (fragment) { return fragment.name.value; });
    var fragmentCounter = 0;
    var generateFragmentName = function (typeName) {
        var fragmentName;
        do {
            fragmentName = "_" + typeName + "_Fragment" + fragmentCounter.toString();
            fragmentCounter++;
        } while (existingFragmentNames.indexOf(fragmentName) !== -1);
        return fragmentName;
    };
    var newFragments = [];
    var fragmentReplacements = {};
    fragments.forEach(function (fragment) {
        newFragments.push(fragment);
        var possibleTypes = mapping[fragment.typeCondition.name.value];
        if (possibleTypes != null) {
            fragmentReplacements[fragment.name.value] = [];
            possibleTypes.forEach(function (possibleTypeName) {
                var name = generateFragmentName(possibleTypeName);
                existingFragmentNames.push(name);
                var newFragment = {
                    kind: Kind$1.FRAGMENT_DEFINITION,
                    name: {
                        kind: Kind$1.NAME,
                        value: name,
                    },
                    typeCondition: {
                        kind: Kind$1.NAMED_TYPE,
                        name: {
                            kind: Kind$1.NAME,
                            value: possibleTypeName,
                        },
                    },
                    selectionSet: fragment.selectionSet,
                };
                newFragments.push(newFragment);
                fragmentReplacements[fragment.name.value].push({
                    fragmentName: name,
                    typeName: possibleTypeName,
                });
            });
        }
    });
    var newDocument = __assign(__assign({}, document), { definitions: __spreadArrays(operations, newFragments) });
    var typeInfo = new TypeInfo(targetSchema);
    return visit$1(newDocument, visitWithTypeInfo(typeInfo, (_a = {},
        _a[Kind$1.SELECTION_SET] = function (node) {
            var newSelections = __spreadArrays(node.selections);
            var maybeType = typeInfo.getParentType();
            if (maybeType != null) {
                var parentType_1 = getNamedType(maybeType);
                node.selections.forEach(function (selection) {
                    if (selection.kind === Kind$1.INLINE_FRAGMENT) {
                        if (selection.typeCondition != null) {
                            var possibleTypes = mapping[selection.typeCondition.name.value];
                            if (possibleTypes != null) {
                                possibleTypes.forEach(function (possibleType) {
                                    var maybePossibleType = targetSchema.getType(possibleType);
                                    if (maybePossibleType != null &&
                                        implementsAbstractType(targetSchema, parentType_1, maybePossibleType)) {
                                        newSelections.push({
                                            kind: Kind$1.INLINE_FRAGMENT,
                                            typeCondition: {
                                                kind: Kind$1.NAMED_TYPE,
                                                name: {
                                                    kind: Kind$1.NAME,
                                                    value: possibleType,
                                                },
                                            },
                                            selectionSet: selection.selectionSet,
                                        });
                                    }
                                });
                            }
                        }
                    }
                    else if (selection.kind === Kind$1.FRAGMENT_SPREAD) {
                        var fragmentName = selection.name.value;
                        var replacements = fragmentReplacements[fragmentName];
                        if (replacements != null) {
                            replacements.forEach(function (replacement) {
                                var typeName = replacement.typeName;
                                var maybeReplacementType = targetSchema.getType(typeName);
                                if (maybeReplacementType != null &&
                                    implementsAbstractType(targetSchema, parentType_1, maybeType)) {
                                    newSelections.push({
                                        kind: Kind$1.FRAGMENT_SPREAD,
                                        name: {
                                            kind: Kind$1.NAME,
                                            value: replacement.fragmentName,
                                        },
                                    });
                                }
                            });
                        }
                    }
                });
                if (reverseMapping[parentType_1.name] != null) {
                    newSelections.push({
                        kind: Kind$1.FIELD,
                        name: {
                            kind: Kind$1.NAME,
                            value: '__typename',
                        },
                    });
                }
            }
            if (newSelections.length !== node.selections.length) {
                return __assign(__assign({}, node), { selections: newSelections });
            }
        },
        _a)));
}

var FilterToSchema = /** @class */ (function () {
    function FilterToSchema(targetSchema) {
        this.targetSchema = targetSchema;
    }
    FilterToSchema.prototype.transformRequest = function (originalRequest) {
        return __assign(__assign({}, originalRequest), filterToSchema(this.targetSchema, originalRequest.document, originalRequest.variables));
    };
    return FilterToSchema;
}());
function filterToSchema(targetSchema, document, variables) {
    var operations = document.definitions.filter(function (def) { return def.kind === Kind$1.OPERATION_DEFINITION; });
    var fragments = document.definitions.filter(function (def) { return def.kind === Kind$1.FRAGMENT_DEFINITION; });
    var usedVariables = [];
    var usedFragments = [];
    var newOperations = [];
    var newFragments = [];
    var validFragments = fragments.filter(function (fragment) {
        var typeName = fragment.typeCondition.name.value;
        return Boolean(targetSchema.getType(typeName));
    });
    var validFragmentsWithType = {};
    validFragments.forEach(function (fragment) {
        var typeName = fragment.typeCondition.name.value;
        var type = targetSchema.getType(typeName);
        validFragmentsWithType[fragment.name.value] = type;
    });
    var fragmentSet = Object.create(null);
    operations.forEach(function (operation) {
        var type;
        if (operation.operation === 'subscription') {
            type = targetSchema.getSubscriptionType();
        }
        else if (operation.operation === 'mutation') {
            type = targetSchema.getMutationType();
        }
        else {
            type = targetSchema.getQueryType();
        }
        var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, operation.selectionSet), selectionSet = _a.selectionSet, operationUsedFragments = _a.usedFragments, operationUsedVariables = _a.usedVariables;
        usedFragments = union(usedFragments, operationUsedFragments);
        var _b = collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments), collectedUsedVariables = _b.usedVariables, collectedNewFragments = _b.newFragments, collectedFragmentSet = _b.fragmentSet;
        var operationOrFragmentVariables = union(operationUsedVariables, collectedUsedVariables);
        usedVariables = union(usedVariables, operationOrFragmentVariables);
        newFragments = collectedNewFragments;
        fragmentSet = collectedFragmentSet;
        var variableDefinitions = operation.variableDefinitions.filter(function (variable) {
            return operationOrFragmentVariables.indexOf(variable.variable.name.value) !==
                -1;
        });
        newOperations.push({
            kind: Kind$1.OPERATION_DEFINITION,
            operation: operation.operation,
            name: operation.name,
            directives: operation.directives,
            variableDefinitions: variableDefinitions,
            selectionSet: selectionSet,
        });
    });
    var newVariables = {};
    usedVariables.forEach(function (variableName) {
        newVariables[variableName] = variables[variableName];
    });
    return {
        document: {
            kind: Kind$1.DOCUMENT,
            definitions: __spreadArrays(newOperations, newFragments),
        },
        variables: newVariables,
    };
}
function collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments) {
    var remainingFragments = usedFragments.slice();
    var usedVariables = [];
    var newFragments = [];
    var _loop_1 = function () {
        var nextFragmentName = remainingFragments.pop();
        var fragment = validFragments.find(function (fr) { return fr.name.value === nextFragmentName; });
        if (fragment != null) {
            var name_1 = nextFragmentName;
            var typeName = fragment.typeCondition.name.value;
            var type = targetSchema.getType(typeName);
            var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, fragment.selectionSet), selectionSet = _a.selectionSet, fragmentUsedFragments = _a.usedFragments, fragmentUsedVariables = _a.usedVariables;
            remainingFragments = union(remainingFragments, fragmentUsedFragments);
            usedVariables = union(usedVariables, fragmentUsedVariables);
            if (!fragmentSet[name_1]) {
                fragmentSet[name_1] = true;
                newFragments.push({
                    kind: Kind$1.FRAGMENT_DEFINITION,
                    name: {
                        kind: Kind$1.NAME,
                        value: name_1,
                    },
                    typeCondition: fragment.typeCondition,
                    selectionSet: selectionSet,
                });
            }
        }
    };
    while (remainingFragments.length !== 0) {
        _loop_1();
    }
    return {
        usedVariables: usedVariables,
        newFragments: newFragments,
        fragmentSet: fragmentSet,
    };
}
function filterSelectionSet(schema, type, validFragments, selectionSet) {
    var _a;
    var usedFragments = [];
    var usedVariables = [];
    var typeInfo = new TypeInfo(schema, undefined, type);
    var filteredSelectionSet = visit$1(selectionSet, visitWithTypeInfo(typeInfo, (_a = {},
        _a[Kind$1.FIELD] = {
            enter: function (node) {
                var parentType = typeInfo.getParentType();
                if (isObjectType$1(parentType) || isInterfaceType$1(parentType)) {
                    var fields = parentType.getFields();
                    var field = node.name.value === '__typename'
                        ? TypeNameMetaFieldDef
                        : fields[node.name.value];
                    if (!field) {
                        return null;
                    }
                    var argNames_1 = (field.args != null ? field.args : []).map(function (arg) { return arg.name; });
                    if (node.arguments != null) {
                        var args = node.arguments.filter(function (arg) { return argNames_1.indexOf(arg.name.value) !== -1; });
                        if (args.length !== node.arguments.length) {
                            return __assign(__assign({}, node), { arguments: args });
                        }
                    }
                }
            },
            leave: function (node) {
                var _a;
                var resolvedType = getNamedType(typeInfo.getType());
                if (isObjectType$1(resolvedType) || isInterfaceType$1(resolvedType)) {
                    var selections = node.selectionSet != null ? node.selectionSet.selections : null;
                    if (selections == null || selections.length === 0) {
                        // need to remove any added variables. Is there a better way to do this?
                        visit$1(node, (_a = {},
                            _a[Kind$1.VARIABLE] = function (variableNode) {
                                var index = usedVariables.indexOf(variableNode.name.value);
                                if (index !== -1) {
                                    usedVariables.splice(index, 1);
                                }
                            },
                            _a));
                        return null;
                    }
                }
            },
        },
        _a[Kind$1.FRAGMENT_SPREAD] = function (node) {
            if (node.name.value in validFragments) {
                var parentType = typeInfo.getParentType();
                var innerType = validFragments[node.name.value];
                if (!implementsAbstractType(schema, parentType, innerType)) {
                    return null;
                }
                usedFragments.push(node.name.value);
                return;
            }
            return null;
        },
        _a[Kind$1.INLINE_FRAGMENT] = {
            enter: function (node) {
                if (node.typeCondition != null) {
                    var parentType = typeInfo.getParentType();
                    var innerType = schema.getType(node.typeCondition.name.value);
                    if (!implementsAbstractType(schema, parentType, innerType)) {
                        return null;
                    }
                }
            },
        },
        _a[Kind$1.VARIABLE] = function (node) {
            usedVariables.push(node.name.value);
        },
        _a)));
    return {
        selectionSet: filteredSelectionSet,
        usedFragments: usedFragments,
        usedVariables: usedVariables,
    };
}
function union() {
    var arrays = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arrays[_i] = arguments[_i];
    }
    var cache = {};
    var result = [];
    arrays.forEach(function (array) {
        array.forEach(function (item) {
            if (!cache[item]) {
                cache[item] = true;
                result.push(item);
            }
        });
    });
    return result;
}

var AddReplacementSelectionSets = /** @class */ (function () {
    function AddReplacementSelectionSets(schema, mapping) {
        this.schema = schema;
        this.mapping = mapping;
    }
    AddReplacementSelectionSets.prototype.transformRequest = function (originalRequest) {
        var document = replaceFieldsWithSelectionSet(this.schema, originalRequest.document, this.mapping);
        return __assign(__assign({}, originalRequest), { document: document });
    };
    return AddReplacementSelectionSets;
}());
function replaceFieldsWithSelectionSet(schema, document, mapping) {
    var _a;
    var typeInfo = new TypeInfo(schema);
    return visit$1(document, visitWithTypeInfo(typeInfo, (_a = {},
        _a[Kind$1.SELECTION_SET] = function (node) {
            var parentType = typeInfo.getParentType();
            if (parentType != null) {
                var parentTypeName_1 = parentType.name;
                var selections_1 = node.selections;
                if (mapping[parentTypeName_1] != null) {
                    node.selections.forEach(function (selection) {
                        if (selection.kind === Kind$1.FIELD) {
                            var name_1 = selection.name.value;
                            var selectionSet = mapping[parentTypeName_1][name_1];
                            if (selectionSet != null) {
                                selections_1 = selections_1.concat(selectionSet.selections);
                            }
                        }
                    });
                }
                if (selections_1 !== node.selections) {
                    return __assign(__assign({}, node), { selections: selections_1 });
                }
            }
        },
        _a)));
}

var AddReplacementFragments = /** @class */ (function () {
    function AddReplacementFragments(targetSchema, mapping) {
        this.targetSchema = targetSchema;
        this.mapping = mapping;
    }
    AddReplacementFragments.prototype.transformRequest = function (originalRequest) {
        var document = replaceFieldsWithFragments(this.targetSchema, originalRequest.document, this.mapping);
        return __assign(__assign({}, originalRequest), { document: document });
    };
    return AddReplacementFragments;
}());
function replaceFieldsWithFragments(targetSchema, document, mapping) {
    var _a;
    var typeInfo = new TypeInfo(targetSchema);
    return visit$1(document, visitWithTypeInfo(typeInfo, (_a = {},
        _a[Kind$1.SELECTION_SET] = function (node) {
            var parentType = typeInfo.getParentType();
            if (parentType != null) {
                var parentTypeName_1 = parentType.name;
                var selections_1 = node.selections;
                if (mapping[parentTypeName_1] != null) {
                    node.selections.forEach(function (selection) {
                        if (selection.kind === Kind$1.FIELD) {
                            var name_1 = selection.name.value;
                            var fragment = mapping[parentTypeName_1][name_1];
                            if (fragment != null) {
                                selections_1 = selections_1.concat(fragment);
                            }
                        }
                    });
                }
                if (selections_1 !== node.selections) {
                    return __assign(__assign({}, node), { selections: selections_1 });
                }
            }
        },
        _a)));
}

var AddMergedTypeFragments = /** @class */ (function () {
    function AddMergedTypeFragments(targetSchema, mapping) {
        this.targetSchema = targetSchema;
        this.mapping = mapping;
    }
    AddMergedTypeFragments.prototype.transformRequest = function (originalRequest) {
        var document = addMergedTypeSelectionSets(this.targetSchema, originalRequest.document, this.mapping);
        return __assign(__assign({}, originalRequest), { document: document });
    };
    return AddMergedTypeFragments;
}());
function addMergedTypeSelectionSets(targetSchema, document, mapping) {
    var _a;
    var typeInfo = new TypeInfo(targetSchema);
    return visit$1(document, visitWithTypeInfo(typeInfo, (_a = {},
        _a[Kind$1.SELECTION_SET] = function (node) {
            var parentType = typeInfo.getParentType();
            if (parentType != null) {
                var parentTypeName = parentType.name;
                var selections = node.selections;
                if (mapping[parentTypeName] != null) {
                    var selectionSet = mapping[parentTypeName].selectionSet;
                    if (selectionSet != null) {
                        selections = selections.concat(selectionSet.selections);
                    }
                }
                if (selections !== node.selections) {
                    return __assign(__assign({}, node), { selections: selections });
                }
            }
        },
        _a)));
}

function addTypenameToAbstract(targetSchema, document) {
    var _a;
    var typeInfo = new TypeInfo(targetSchema);
    return visit$1(document, visitWithTypeInfo(typeInfo, (_a = {},
        _a[Kind$1.SELECTION_SET] = function (node) {
            var parentType = typeInfo.getParentType();
            var selections = node.selections;
            if (parentType != null && isAbstractType$1(parentType)) {
                selections = selections.concat({
                    kind: Kind$1.FIELD,
                    name: {
                        kind: Kind$1.NAME,
                        value: '__typename',
                    },
                });
            }
            if (selections !== node.selections) {
                return __assign(__assign({}, node), { selections: selections });
            }
        },
        _a)));
}

var AddTypenameToAbstract = /** @class */ (function () {
    function AddTypenameToAbstract(targetSchema) {
        this.targetSchema = targetSchema;
    }
    AddTypenameToAbstract.prototype.transformRequest = function (originalRequest) {
        var document = addTypenameToAbstract(this.targetSchema, originalRequest.document);
        return __assign(__assign({}, originalRequest), { document: document });
    };
    return AddTypenameToAbstract;
}());

/**
 * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just
 * resolves aliases.
 * @param info The info argument to the resolver.
 */
function getResponseKeyFromInfo(info) {
    return info.fieldNodes[0].alias != null
        ? info.fieldNodes[0].alias.value
        : info.fieldName;
}

var hasSymbol = (typeof global !== 'undefined' && 'Symbol' in global) ||
    // eslint-disable-next-line no-undef
    (typeof window !== 'undefined' && 'Symbol' in window);
var OBJECT_SUBSCHEMA_SYMBOL = hasSymbol
    ? Symbol('initialSubschema')
    : '@@__initialSubschema';
var FIELD_SUBSCHEMA_MAP_SYMBOL = hasSymbol
    ? Symbol('subschemaMap')
    : '@@__subschemaMap';
var ERROR_SYMBOL = hasSymbol
    ? Symbol('subschemaErrors')
    : '@@__subschemaErrors';

function relocatedError(originalError, nodes, path) {
    if (Array.isArray(originalError.path)) {
        return new GraphQLError$1(originalError.message, originalError.nodes, originalError.source, originalError.positions, path != null ? path : originalError.path, originalError.originalError, originalError.extensions);
    }
    if (originalError == null) {
        return new GraphQLError$1(undefined, nodes, undefined, undefined, path, originalError);
    }
    return new GraphQLError$1(originalError.message, originalError.nodes != null
        ? originalError.nodes
        : nodes, originalError.source, originalError.positions, path, originalError);
}
function slicedError(originalError) {
    return relocatedError(originalError, originalError.nodes, originalError.path != null ? originalError.path.slice(1) : undefined);
}
function getErrorsByPathSegment(errors) {
    var record = Object.create(null);
    errors.forEach(function (error) {
        if (!error.path || error.path.length < 2) {
            return;
        }
        var pathSegment = error.path[1];
        var current = record[pathSegment] != null ? record[pathSegment] : [];
        current.push(slicedError(error));
        record[pathSegment] = current;
    });
    return record;
}
var CombinedError = /** @class */ (function (_super) {
    __extends(CombinedError, _super);
    function CombinedError(message, errors) {
        var _this = _super.call(this, message) || this;
        _this.errors = errors;
        return _this;
    }
    return CombinedError;
}(Error));
function combineErrors(errors) {
    if (errors.length === 1) {
        return new GraphQLError$1(errors[0].message, errors[0].nodes, errors[0].source, errors[0].positions, errors[0].path, errors[0].originalError, errors[0].extensions);
    }
    return new CombinedError(errors.map(function (error) { return error.message; }).join('\n'), errors);
}
function setErrors(result, errors) {
    result[ERROR_SYMBOL] = errors;
}
function getErrors(result, pathSegment) {
    var errors = result != null ? result[ERROR_SYMBOL] : result;
    if (!Array.isArray(errors)) {
        return null;
    }
    var fieldErrors = [];
    for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
        var error = errors_1[_i];
        if (!error.path || error.path[0] === pathSegment) {
            fieldErrors.push(error);
        }
    }
    return fieldErrors;
}

function handleNull(fieldNodes, path, errors) {
    if (errors.length) {
        if (errors.some(function (error) { return !error.path || error.path.length < 2; })) {
            return relocatedError(combineErrors(errors), fieldNodes, path);
        }
        else if (errors.some(function (error) { return typeof error.path[1] === 'string'; })) {
            var childErrors_1 = getErrorsByPathSegment(errors);
            var result_1 = Object.create(null);
            Object.keys(childErrors_1).forEach(function (pathSegment) {
                result_1[pathSegment] = handleNull(fieldNodes, __spreadArrays(path, [pathSegment]), childErrors_1[pathSegment]);
            });
            return result_1;
        }
        var childErrors_2 = getErrorsByPathSegment(errors);
        var result_2 = [];
        Object.keys(childErrors_2).forEach(function (pathSegment) {
            result_2.push(handleNull(fieldNodes, __spreadArrays(path, [parseInt(pathSegment, 10)]), childErrors_2[pathSegment]));
        });
        return result_2;
    }
    return null;
}

var nodejsCustomInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : undefined;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
/**
 * Used to print values in error messages.
 */

function inspect(value) {
  return formatValue(value, []);
}

function formatValue(value, seenValues) {
  switch (_typeof(value)) {
    case 'string':
      return JSON.stringify(value);

    case 'function':
      return value.name ? "[function ".concat(value.name, "]") : '[function]';

    case 'object':
      if (value === null) {
        return 'null';
      }

      return formatObjectValue(value, seenValues);

    default:
      return String(value);
  }
}

function formatObjectValue(value, previouslySeenValues) {
  if (previouslySeenValues.indexOf(value) !== -1) {
    return '[Circular]';
  }

  var seenValues = [].concat(previouslySeenValues, [value]);
  var customInspectFn = getCustomFn(value);

  if (customInspectFn !== undefined) {
    // $FlowFixMe(>=0.90.0)
    var customValue = customInspectFn.call(value); // check for infinite recursion

    if (customValue !== value) {
      return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }

  return formatObject(value, seenValues);
}

function formatObject(object, seenValues) {
  var keys = Object.keys(object);

  if (keys.length === 0) {
    return '{}';
  }

  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return '[' + getObjectTag(object) + ']';
  }

  var properties = keys.map(function (key) {
    var value = formatValue(object[key], seenValues);
    return key + ': ' + value;
  });
  return '{ ' + properties.join(', ') + ' }';
}

function formatArray(array, seenValues) {
  if (array.length === 0) {
    return '[]';
  }

  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return '[Array]';
  }

  var len = Math.min(MAX_ARRAY_LENGTH, array.length);
  var remaining = array.length - len;
  var items = [];

  for (var i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }

  if (remaining === 1) {
    items.push('... 1 more item');
  } else if (remaining > 1) {
    items.push("... ".concat(remaining, " more items"));
  }

  return '[' + items.join(', ') + ']';
}

function getCustomFn(object) {
  var customInspectFn = object[String(nodejsCustomInspectSymbol)];

  if (typeof customInspectFn === 'function') {
    return customInspectFn;
  }

  if (typeof object.inspect === 'function') {
    return object.inspect;
  }
}

function getObjectTag(object) {
  var tag = Object.prototype.toString.call(object).replace(/^\[object /, '').replace(/]$/, '');

  if (tag === 'Object' && typeof object.constructor === 'function') {
    var name = object.constructor.name;

    if (typeof name === 'string' && name !== '') {
      return name;
    }
  }

  return tag;
}

function invariant(condition, message) {
  var booleanCondition = Boolean(condition);

  if (!booleanCondition) {
    throw new Error(message || 'Unexpected invariant triggered');
  }
}

function devAssert(condition, message) {
  var booleanCondition = Boolean(condition);

  if (!booleanCondition) {
    throw new Error(message);
  }
}

/**
 * Returns true if a value is undefined, or NaN.
 */
function isInvalid(value) {
  return value === undefined || value !== value;
}

function _typeof$1(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

/**
 * Return true if `value` is object-like. A value is object-like if it's not
 * `null` and has a `typeof` result of "object".
 */
function isObjectLike(value) {
  return _typeof$1(value) == 'object' && value !== null;
}

/**
 * Represents a location in a Source.
 */

/**
 * Takes a Source and a UTF-8 character offset, and returns the corresponding
 * line and column as a SourceLocation.
 */
function getLocation(source, position) {
  var lineRegexp = /\r\n|[\n\r]/g;
  var line = 1;
  var column = position + 1;
  var match;

  while ((match = lineRegexp.exec(source.body)) && match.index < position) {
    line += 1;
    column = position + 1 - (match.index + match[0].length);
  }

  return {
    line: line,
    column: column
  };
}

/**
 * Render a helpful description of the location in the GraphQL Source document.
 */

function printLocation(location) {
  return printSourceLocation(location.source, getLocation(location.source, location.start));
}
/**
 * Render a helpful description of the location in the GraphQL Source document.
 */

function printSourceLocation(source, sourceLocation) {
  var firstLineColumnOffset = source.locationOffset.column - 1;
  var body = whitespace(firstLineColumnOffset) + source.body;
  var lineIndex = sourceLocation.line - 1;
  var lineOffset = source.locationOffset.line - 1;
  var lineNum = sourceLocation.line + lineOffset;
  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  var columnNum = sourceLocation.column + columnOffset;
  var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
  var lines = body.split(/\r\n|[\n\r]/g);
  var locationLine = lines[lineIndex]; // Special case for minified documents

  if (locationLine.length > 120) {
    var sublineIndex = Math.floor(columnNum / 80);
    var sublineColumnNum = columnNum % 80;
    var sublines = [];

    for (var i = 0; i < locationLine.length; i += 80) {
      sublines.push(locationLine.slice(i, i + 80));
    }

    return locationStr + printPrefixedLines([["".concat(lineNum), sublines[0]]].concat(sublines.slice(1, sublineIndex + 1).map(function (subline) {
      return ['', subline];
    }), [[' ', whitespace(sublineColumnNum - 1) + '^'], ['', sublines[sublineIndex + 1]]]));
  }

  return locationStr + printPrefixedLines([// Lines specified like this: ["prefix", "string"],
  ["".concat(lineNum - 1), lines[lineIndex - 1]], ["".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], ["".concat(lineNum + 1), lines[lineIndex + 1]]]);
}

function printPrefixedLines(lines) {
  var existingLines = lines.filter(function (_ref) {
    var _ = _ref[0],
        line = _ref[1];
    return line !== undefined;
  });
  var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {
    var prefix = _ref2[0];
    return prefix.length;
  }));
  return existingLines.map(function (_ref3) {
    var prefix = _ref3[0],
        line = _ref3[1];
    return lpad(padLen, prefix) + (line ? ' | ' + line : ' |');
  }).join('\n');
}

function whitespace(len) {
  return Array(len + 1).join(' ');
}

function lpad(len, str) {
  return whitespace(len - str.length) + str;
}

/**
 * A GraphQLError describes an Error found during the parse, validate, or
 * execute phases of performing a GraphQL operation. In addition to a message
 * and stack trace, it also includes information about the locations in a
 * GraphQL document and/or execution result that correspond to the Error.
 */

function GraphQLError( // eslint-disable-line no-redeclare
message, nodes, source, positions, path, originalError, extensions) {
  // Compute list of blame nodes.
  var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.


  var _source = source;

  if (!_source && _nodes) {
    var node = _nodes[0];
    _source = node && node.loc && node.loc.source;
  }

  var _positions = positions;

  if (!_positions && _nodes) {
    _positions = _nodes.reduce(function (list, node) {
      if (node.loc) {
        list.push(node.loc.start);
      }

      return list;
    }, []);
  }

  if (_positions && _positions.length === 0) {
    _positions = undefined;
  }

  var _locations;

  if (positions && source) {
    _locations = positions.map(function (pos) {
      return getLocation(source, pos);
    });
  } else if (_nodes) {
    _locations = _nodes.reduce(function (list, node) {
      if (node.loc) {
        list.push(getLocation(node.loc.source, node.loc.start));
      }

      return list;
    }, []);
  }

  var _extensions = extensions;

  if (_extensions == null && originalError != null) {
    var originalExtensions = originalError.extensions;

    if (isObjectLike(originalExtensions)) {
      _extensions = originalExtensions;
    }
  }

  Object.defineProperties(this, {
    message: {
      value: message,
      // By being enumerable, JSON.stringify will include `message` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: true,
      writable: true
    },
    locations: {
      // Coercing falsey values to undefined ensures they will not be included
      // in JSON.stringify() when not provided.
      value: _locations || undefined,
      // By being enumerable, JSON.stringify will include `locations` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: Boolean(_locations)
    },
    path: {
      // Coercing falsey values to undefined ensures they will not be included
      // in JSON.stringify() when not provided.
      value: path || undefined,
      // By being enumerable, JSON.stringify will include `path` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: Boolean(path)
    },
    nodes: {
      value: _nodes || undefined
    },
    source: {
      value: _source || undefined
    },
    positions: {
      value: _positions || undefined
    },
    originalError: {
      value: originalError
    },
    extensions: {
      // Coercing falsey values to undefined ensures they will not be included
      // in JSON.stringify() when not provided.
      value: _extensions || undefined,
      // By being enumerable, JSON.stringify will include `path` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: Boolean(_extensions)
    }
  }); // Include (non-enumerable) stack trace.

  if (originalError && originalError.stack) {
    Object.defineProperty(this, 'stack', {
      value: originalError.stack,
      writable: true,
      configurable: true
    });
  } else if (Error.captureStackTrace) {
    Error.captureStackTrace(this, GraphQLError);
  } else {
    Object.defineProperty(this, 'stack', {
      value: Error().stack,
      writable: true,
      configurable: true
    });
  }
}
GraphQLError.prototype = Object.create(Error.prototype, {
  constructor: {
    value: GraphQLError
  },
  name: {
    value: 'GraphQLError'
  },
  toString: {
    value: function toString() {
      return printError(this);
    }
  }
});
/**
 * Prints a GraphQLError to a string, representing useful location information
 * about the error's position in the source.
 */

function printError(error) {
  var output = error.message;

  if (error.nodes) {
    for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {
      var node = _error$nodes2[_i2];

      if (node.loc) {
        output += '\n\n' + printLocation(node.loc);
      }
    }
  } else if (error.source && error.locations) {
    for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {
      var location = _error$locations2[_i4];
      output += '\n\n' + printSourceLocation(error.source, location);
    }
  }

  return output;
}

/**
 * The set of allowed kind values for AST nodes.
 */
var Kind = Object.freeze({
  // Name
  NAME: 'Name',
  // Document
  DOCUMENT: 'Document',
  OPERATION_DEFINITION: 'OperationDefinition',
  VARIABLE_DEFINITION: 'VariableDefinition',
  SELECTION_SET: 'SelectionSet',
  FIELD: 'Field',
  ARGUMENT: 'Argument',
  // Fragments
  FRAGMENT_SPREAD: 'FragmentSpread',
  INLINE_FRAGMENT: 'InlineFragment',
  FRAGMENT_DEFINITION: 'FragmentDefinition',
  // Values
  VARIABLE: 'Variable',
  INT: 'IntValue',
  FLOAT: 'FloatValue',
  STRING: 'StringValue',
  BOOLEAN: 'BooleanValue',
  NULL: 'NullValue',
  ENUM: 'EnumValue',
  LIST: 'ListValue',
  OBJECT: 'ObjectValue',
  OBJECT_FIELD: 'ObjectField',
  // Directives
  DIRECTIVE: 'Directive',
  // Types
  NAMED_TYPE: 'NamedType',
  LIST_TYPE: 'ListType',
  NON_NULL_TYPE: 'NonNullType',
  // Type System Definitions
  SCHEMA_DEFINITION: 'SchemaDefinition',
  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',
  // Type Definitions
  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',
  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',
  FIELD_DEFINITION: 'FieldDefinition',
  INPUT_VALUE_DEFINITION: 'InputValueDefinition',
  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',
  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',
  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',
  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',
  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',
  // Directive Definitions
  DIRECTIVE_DEFINITION: 'DirectiveDefinition',
  // Type System Extensions
  SCHEMA_EXTENSION: 'SchemaExtension',
  // Type Extensions
  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',
  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',
  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',
  UNION_TYPE_EXTENSION: 'UnionTypeExtension',
  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',
  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'
});
/**
 * The enum type representing the possible kind values of AST nodes.
 */

/* eslint-disable no-redeclare */
// $FlowFixMe
var find = Array.prototype.find ? function (list, predicate) {
  return Array.prototype.find.call(list, predicate);
} : function (list, predicate) {
  for (var _i2 = 0; _i2 < list.length; _i2++) {
    var value = list[_i2];

    if (predicate(value)) {
      return value;
    }
  }
};

/* eslint-disable no-redeclare */
// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/2221
var objectValues = Object.values || function (obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
};

/* eslint-disable no-redeclare */
// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/5838
var objectEntries = Object.entries || function (obj) {
  return Object.keys(obj).map(function (key) {
    return [key, obj[key]];
  });
};

/**
 * Creates a keyed JS object from an array, given a function to produce the keys
 * for each value in the array.
 *
 * This provides a convenient lookup for the array items if the key function
 * produces unique results.
 *
 *     const phoneBook = [
 *       { name: 'Jon', num: '555-1234' },
 *       { name: 'Jenny', num: '867-5309' }
 *     ]
 *
 *     // { Jon: { name: 'Jon', num: '555-1234' },
 *     //   Jenny: { name: 'Jenny', num: '867-5309' } }
 *     const entriesByName = keyMap(
 *       phoneBook,
 *       entry => entry.name
 *     )
 *
 *     // { name: 'Jenny', num: '857-6309' }
 *     const jennyEntry = entriesByName['Jenny']
 *
 */
function keyMap(list, keyFn) {
  return list.reduce(function (map, item) {
    map[keyFn(item)] = item;
    return map;
  }, Object.create(null));
}

/**
 * Creates an object map with the same keys as `map` and values generated by
 * running each value of `map` thru `fn`.
 */
function mapValue(map, fn) {
  var result = Object.create(null);

  for (var _i2 = 0, _objectEntries2 = objectEntries(map); _i2 < _objectEntries2.length; _i2++) {
    var _ref2 = _objectEntries2[_i2];
    var _key = _ref2[0];
    var _value = _ref2[1];
    result[_key] = fn(_value, _key);
  }

  return result;
}

function toObjMap(obj) {
  /* eslint-enable no-redeclare */
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }

  var map = Object.create(null);

  for (var _i2 = 0, _objectEntries2 = objectEntries(obj); _i2 < _objectEntries2.length; _i2++) {
    var _ref2 = _objectEntries2[_i2];
    var key = _ref2[0];
    var value = _ref2[1];
    map[key] = value;
  }

  return map;
}

/**
 * Creates a keyed JS object from an array, given a function to produce the keys
 * and a function to produce the values from each item in the array.
 *
 *     const phoneBook = [
 *       { name: 'Jon', num: '555-1234' },
 *       { name: 'Jenny', num: '867-5309' }
 *     ]
 *
 *     // { Jon: '555-1234', Jenny: '867-5309' }
 *     const phonesByName = keyValMap(
 *       phoneBook,
 *       entry => entry.name,
 *       entry => entry.num
 *     )
 *
 */
function keyValMap(list, keyFn, valFn) {
  return list.reduce(function (map, item) {
    map[keyFn(item)] = valFn(item);
    return map;
  }, Object.create(null));
}

/**
 * A replacement for instanceof which includes an error warning when multi-realm
 * constructors are detected.
 */
// See: https://expressjs.com/en/advanced/best-practice-performance.html#set-node_env-to-production
// See: https://webpack.js.org/guides/production/
const instanceOf = process.env.NODE_ENV === 'production' ? // eslint-disable-next-line no-shadow
function instanceOf(value, constructor) {
  return value instanceof constructor;
} : // eslint-disable-next-line no-shadow
function instanceOf(value, constructor) {
  if (value instanceof constructor) {
    return true;
  }

  if (value) {
    var valueClass = value.constructor;
    var className = constructor.name;

    if (className && valueClass && valueClass.name === className) {
      throw new Error("Cannot use ".concat(className, " \"").concat(value, "\" from another module or realm.\n\nEnsure that there is only one instance of \"graphql\" in the node_modules\ndirectory. If different versions of \"graphql\" are the dependencies of other\nrelied on modules, use \"resolutions\" to ensure only one version is installed.\n\nhttps://yarnpkg.com/en/docs/selective-version-resolutions\n\nDuplicate \"graphql\" modules cannot be used at the same time since different\nversions may have different capabilities and behavior. The data from one\nversion used in the function from another could produce confusing and\nspurious results."));
    }
  }

  return false;
};

/**
 * Returns the first argument it receives.
 */
function identityFunc(x) {
  return x;
}

/**
 * The `defineToJSON()` function defines toJSON() and inspect() prototype
 * methods, if no function provided they become aliases for toString().
 */

function defineToJSON(classObject) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : classObject.prototype.toString;
  classObject.prototype.toJSON = fn;
  classObject.prototype.inspect = fn;

  if (nodejsCustomInspectSymbol) {
    classObject.prototype[nodejsCustomInspectSymbol] = fn;
  }
}

/**
 * The `defineToStringTag()` function checks first to see if the runtime
 * supports the `Symbol` class and then if the `Symbol.toStringTag` constant
 * is defined as a `Symbol` instance. If both conditions are met, the
 * Symbol.toStringTag property is defined as a getter that returns the
 * supplied class constructor's name.
 *
 * @method defineToStringTag
 *
 * @param {Class<any>} classObject a class such as Object, String, Number but
 * typically one of your own creation through the class keyword; `class A {}`,
 * for example.
 */
function defineToStringTag(classObject) {
  if (typeof Symbol === 'function' && Symbol.toStringTag) {
    Object.defineProperty(classObject.prototype, Symbol.toStringTag, {
      get: function get() {
        return this.constructor.name;
      }
    });
  }
}

/**
 * Produces a JavaScript value given a GraphQL Value AST.
 *
 * Unlike `valueFromAST()`, no type is provided. The resulting JavaScript value
 * will reflect the provided GraphQL value AST.
 *
 * | GraphQL Value        | JavaScript Value |
 * | -------------------- | ---------------- |
 * | Input Object         | Object           |
 * | List                 | Array            |
 * | Boolean              | Boolean          |
 * | String / Enum        | String           |
 * | Int / Float          | Number           |
 * | Null                 | null             |
 *
 */
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;

    case Kind.INT:
      return parseInt(valueNode.value, 10);

    case Kind.FLOAT:
      return parseFloat(valueNode.value);

    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;

    case Kind.LIST:
      return valueNode.values.map(function (node) {
        return valueFromASTUntyped(node, variables);
      });

    case Kind.OBJECT:
      return keyValMap(valueNode.fields, function (field) {
        return field.name.value;
      }, function (field) {
        return valueFromASTUntyped(field.value, variables);
      });

    case Kind.VARIABLE:
      {
        var variableName = valueNode.name.value;
        return variables && !isInvalid(variables[variableName]) ? variables[variableName] : undefined;
      }
  } // Not reachable. All possible value nodes have been considered.


  /* istanbul ignore next */
  invariant(false, 'Unexpected value node: ' + inspect(valueNode));
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function assertType(type) {
  if (!isType(type)) {
    throw new Error("Expected ".concat(inspect(type), " to be a GraphQL type."));
  }

  return type;
}
/**
 * There are predicates for each kind of GraphQL type.
 */

// eslint-disable-next-line no-redeclare
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
// eslint-disable-next-line no-redeclare
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
// eslint-disable-next-line no-redeclare
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
// eslint-disable-next-line no-redeclare
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
// eslint-disable-next-line no-redeclare
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
// eslint-disable-next-line no-redeclare
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
// eslint-disable-next-line no-redeclare
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
// eslint-disable-next-line no-redeclare
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
/**
 * These types may describe the parent context of a selection set.
 */

function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
/**
 * List Type Wrapper
 *
 * A list is a wrapping type which points to another type.
 * Lists are often created within the context of defining the fields of
 * an object type.
 *
 * Example:
 *
 *     const PersonType = new GraphQLObjectType({
 *       name: 'Person',
 *       fields: () => ({
 *         parents: { type: GraphQLList(PersonType) },
 *         children: { type: GraphQLList(PersonType) },
 *       })
 *     })
 *
 */

// eslint-disable-next-line no-redeclare
function GraphQLList(ofType) {
  if (this instanceof GraphQLList) {
    this.ofType = assertType(ofType);
  } else {
    return new GraphQLList(ofType);
  }
} // Need to cast through any to alter the prototype.

GraphQLList.prototype.toString = function toString() {
  return '[' + String(this.ofType) + ']';
}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported


defineToStringTag(GraphQLList);
defineToJSON(GraphQLList);
/**
 * Non-Null Type Wrapper
 *
 * A non-null is a wrapping type which points to another type.
 * Non-null types enforce that their values are never null and can ensure
 * an error is raised if this ever occurs during a request. It is useful for
 * fields which you can make a strong guarantee on non-nullability, for example
 * usually the id field of a database row will never be null.
 *
 * Example:
 *
 *     const RowType = new GraphQLObjectType({
 *       name: 'Row',
 *       fields: () => ({
 *         id: { type: GraphQLNonNull(GraphQLString) },
 *       })
 *     })
 *
 * Note: the enforcement of non-nullability occurs within the executor.
 */

// eslint-disable-next-line no-redeclare
function GraphQLNonNull(ofType) {
  if (this instanceof GraphQLNonNull) {
    this.ofType = assertNullableType(ofType);
  } else {
    return new GraphQLNonNull(ofType);
  }
} // Need to cast through any to alter the prototype.

GraphQLNonNull.prototype.toString = function toString() {
  return String(this.ofType) + '!';
}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported


defineToStringTag(GraphQLNonNull);
defineToJSON(GraphQLNonNull);
/**
 * These types can all accept null as a value.
 */

function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function assertNullableType(type) {
  if (!isNullableType(type)) {
    throw new Error("Expected ".concat(inspect(type), " to be a GraphQL nullable type."));
  }

  return type;
}
/**
 * Used while defining GraphQL types to allow for circular references in
 * otherwise immutable type definitions.
 */

function resolveThunk(thunk) {
  // $FlowFixMe(>=0.90.0)
  return typeof thunk === 'function' ? thunk() : thunk;
}

function undefineIfEmpty(arr) {
  return arr && arr.length > 0 ? arr : undefined;
}
/**
 * Scalar Type Definition
 *
 * The leaf values of any request and input values to arguments are
 * Scalars (or Enums) and are defined with a name and a series of functions
 * used to parse input from ast or variables and to ensure validity.
 *
 * If a type's serialize function does not return a value (i.e. it returns
 * `undefined`) then an error will be raised and a `null` value will be returned
 * in the response. If the serialize function returns `null`, then no error will
 * be included in the response.
 *
 * Example:
 *
 *     const OddType = new GraphQLScalarType({
 *       name: 'Odd',
 *       serialize(value) {
 *         if (value % 2 === 1) {
 *           return value;
 *         }
 *       }
 *     });
 *
 */


var GraphQLScalarType =
/*#__PURE__*/
function () {
  function GraphQLScalarType(config) {
    var parseValue = config.parseValue || identityFunc;
    this.name = config.name;
    this.description = config.description;
    this.serialize = config.serialize || identityFunc;
    this.parseValue = parseValue;

    this.parseLiteral = config.parseLiteral || function (node) {
      return parseValue(valueFromASTUntyped(node));
    };

    this.extensions = config.extensions && toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
    typeof config.name === 'string' || devAssert(0, 'Must provide name.');
    config.serialize == null || typeof config.serialize === 'function' || devAssert(0, "".concat(this.name, " must provide \"serialize\" function. If this custom Scalar is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" functions are also provided."));

    if (config.parseLiteral) {
      typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function' || devAssert(0, "".concat(this.name, " must provide both \"parseValue\" and \"parseLiteral\" functions."));
    }
  }

  var _proto = GraphQLScalarType.prototype;

  _proto.toConfig = function toConfig() {
    return {
      name: this.name,
      description: this.description,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes || []
    };
  };

  _proto.toString = function toString() {
    return this.name;
  };

  return GraphQLScalarType;
}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

defineToStringTag(GraphQLScalarType);
defineToJSON(GraphQLScalarType);

/**
 * Object Type Definition
 *
 * Almost all of the GraphQL types you define will be object types. Object types
 * have a name, but most importantly describe their fields.
 *
 * Example:
 *
 *     const AddressType = new GraphQLObjectType({
 *       name: 'Address',
 *       fields: {
 *         street: { type: GraphQLString },
 *         number: { type: GraphQLInt },
 *         formatted: {
 *           type: GraphQLString,
 *           resolve(obj) {
 *             return obj.number + ' ' + obj.street
 *           }
 *         }
 *       }
 *     });
 *
 * When two types need to refer to each other, or a type needs to refer to
 * itself in a field, you can use a function expression (aka a closure or a
 * thunk) to supply the fields lazily.
 *
 * Example:
 *
 *     const PersonType = new GraphQLObjectType({
 *       name: 'Person',
 *       fields: () => ({
 *         name: { type: GraphQLString },
 *         bestFriend: { type: PersonType },
 *       })
 *     });
 *
 */
var GraphQLObjectType =
/*#__PURE__*/
function () {
  function GraphQLObjectType(config) {
    this.name = config.name;
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = config.extensions && toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
    this._fields = defineFieldMap.bind(undefined, config);
    this._interfaces = defineInterfaces.bind(undefined, config);
    typeof config.name === 'string' || devAssert(0, 'Must provide name.');
    config.isTypeOf == null || typeof config.isTypeOf === 'function' || devAssert(0, "".concat(this.name, " must provide \"isTypeOf\" as a function, ") + "but got: ".concat(inspect(config.isTypeOf), "."));
  }

  var _proto2 = GraphQLObjectType.prototype;

  _proto2.getFields = function getFields() {
    if (typeof this._fields === 'function') {
      this._fields = this._fields();
    }

    return this._fields;
  };

  _proto2.getInterfaces = function getInterfaces() {
    if (typeof this._interfaces === 'function') {
      this._interfaces = this._interfaces();
    }

    return this._interfaces;
  };

  _proto2.toConfig = function toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes || []
    };
  };

  _proto2.toString = function toString() {
    return this.name;
  };

  return GraphQLObjectType;
}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

defineToStringTag(GraphQLObjectType);
defineToJSON(GraphQLObjectType);

function defineInterfaces(config) {
  var interfaces = resolveThunk(config.interfaces) || [];
  Array.isArray(interfaces) || devAssert(0, "".concat(config.name, " interfaces must be an Array or a function which returns an Array."));
  return interfaces;
}

function defineFieldMap(config) {
  var fieldMap = resolveThunk(config.fields) || {};
  isPlainObj(fieldMap) || devAssert(0, "".concat(config.name, " fields must be an object with field names as keys or a function which returns such an object."));
  return mapValue(fieldMap, function (fieldConfig, fieldName) {
    isPlainObj(fieldConfig) || devAssert(0, "".concat(config.name, ".").concat(fieldName, " field config must be an object"));
    !('isDeprecated' in fieldConfig) || devAssert(0, "".concat(config.name, ".").concat(fieldName, " should provide \"deprecationReason\" instead of \"isDeprecated\"."));
    fieldConfig.resolve == null || typeof fieldConfig.resolve === 'function' || devAssert(0, "".concat(config.name, ".").concat(fieldName, " field resolver must be a function if ") + "provided, but got: ".concat(inspect(fieldConfig.resolve), "."));
    var argsConfig = fieldConfig.args || {};
    isPlainObj(argsConfig) || devAssert(0, "".concat(config.name, ".").concat(fieldName, " args must be an object with argument names as keys."));
    var args = objectEntries(argsConfig).map(function (_ref) {
      var argName = _ref[0],
          arg = _ref[1];
      return {
        name: argName,
        description: arg.description === undefined ? null : arg.description,
        type: arg.type,
        defaultValue: arg.defaultValue,
        extensions: arg.extensions && toObjMap(arg.extensions),
        astNode: arg.astNode
      };
    });
    return _objectSpread({}, fieldConfig, {
      name: fieldName,
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: args,
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      isDeprecated: Boolean(fieldConfig.deprecationReason),
      deprecationReason: fieldConfig.deprecationReason,
      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    });
  });
}

function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}

function fieldsToFieldsConfig(fields) {
  return mapValue(fields, function (field) {
    return {
      description: field.description,
      type: field.type,
      args: argsToArgsConfig(field.args),
      resolve: field.resolve,
      subscribe: field.subscribe,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    };
  });
}

function argsToArgsConfig(args) {
  return keyValMap(args, function (arg) {
    return arg.name;
  }, function (arg) {
    return {
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      extensions: arg.extensions,
      astNode: arg.astNode
    };
  });
}

/**
 * Interface Type Definition
 *
 * When a field can return one of a heterogeneous set of types, a Interface type
 * is used to describe what types are possible, what fields are in common across
 * all types, as well as a function to determine which type is actually used
 * when the field is resolved.
 *
 * Example:
 *
 *     const EntityType = new GraphQLInterfaceType({
 *       name: 'Entity',
 *       fields: {
 *         name: { type: GraphQLString }
 *       }
 *     });
 *
 */
var GraphQLInterfaceType =
/*#__PURE__*/
function () {
  function GraphQLInterfaceType(config) {
    this.name = config.name;
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = config.extensions && toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
    this._fields = defineFieldMap.bind(undefined, config);
    typeof config.name === 'string' || devAssert(0, 'Must provide name.');
    config.resolveType == null || typeof config.resolveType === 'function' || devAssert(0, "".concat(this.name, " must provide \"resolveType\" as a function, ") + "but got: ".concat(inspect(config.resolveType), "."));
  }

  var _proto3 = GraphQLInterfaceType.prototype;

  _proto3.getFields = function getFields() {
    if (typeof this._fields === 'function') {
      this._fields = this._fields();
    }

    return this._fields;
  };

  _proto3.toConfig = function toConfig() {
    return {
      name: this.name,
      description: this.description,
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes || []
    };
  };

  _proto3.toString = function toString() {
    return this.name;
  };

  return GraphQLInterfaceType;
}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

defineToStringTag(GraphQLInterfaceType);
defineToJSON(GraphQLInterfaceType);

/**
 * Union Type Definition
 *
 * When a field can return one of a heterogeneous set of types, a Union type
 * is used to describe what types are possible as well as providing a function
 * to determine which type is actually used when the field is resolved.
 *
 * Example:
 *
 *     const PetType = new GraphQLUnionType({
 *       name: 'Pet',
 *       types: [ DogType, CatType ],
 *       resolveType(value) {
 *         if (value instanceof Dog) {
 *           return DogType;
 *         }
 *         if (value instanceof Cat) {
 *           return CatType;
 *         }
 *       }
 *     });
 *
 */
var GraphQLUnionType =
/*#__PURE__*/
function () {
  function GraphQLUnionType(config) {
    this.name = config.name;
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = config.extensions && toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
    this._types = defineTypes.bind(undefined, config);
    typeof config.name === 'string' || devAssert(0, 'Must provide name.');
    config.resolveType == null || typeof config.resolveType === 'function' || devAssert(0, "".concat(this.name, " must provide \"resolveType\" as a function, ") + "but got: ".concat(inspect(config.resolveType), "."));
  }

  var _proto4 = GraphQLUnionType.prototype;

  _proto4.getTypes = function getTypes() {
    if (typeof this._types === 'function') {
      this._types = this._types();
    }

    return this._types;
  };

  _proto4.toConfig = function toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes || []
    };
  };

  _proto4.toString = function toString() {
    return this.name;
  };

  return GraphQLUnionType;
}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

defineToStringTag(GraphQLUnionType);
defineToJSON(GraphQLUnionType);

function defineTypes(config) {
  var types = resolveThunk(config.types) || [];
  Array.isArray(types) || devAssert(0, "Must provide Array of types or a function which returns such an array for Union ".concat(config.name, "."));
  return types;
}

/**
 * Enum Type Definition
 *
 * Some leaf values of requests and input values are Enums. GraphQL serializes
 * Enum values as strings, however internally Enums can be represented by any
 * kind of type, often integers.
 *
 * Example:
 *
 *     const RGBType = new GraphQLEnumType({
 *       name: 'RGB',
 *       values: {
 *         RED: { value: 0 },
 *         GREEN: { value: 1 },
 *         BLUE: { value: 2 }
 *       }
 *     });
 *
 * Note: If a value is not provided in a definition, the name of the enum value
 * will be used as its internal value.
 */
var GraphQLEnumType
/* <T> */
=
/*#__PURE__*/
function () {
  function GraphQLEnumType(config) {
    this.name = config.name;
    this.description = config.description;
    this.extensions = config.extensions && toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
    this._values = defineEnumValues(this.name, config.values);
    this._valueLookup = new Map(this._values.map(function (enumValue) {
      return [enumValue.value, enumValue];
    }));
    this._nameLookup = keyMap(this._values, function (value) {
      return value.name;
    });
    typeof config.name === 'string' || devAssert(0, 'Must provide name.');
  }

  var _proto5 = GraphQLEnumType.prototype;

  _proto5.getValues = function getValues() {
    return this._values;
  };

  _proto5.getValue = function getValue(name) {
    return this._nameLookup[name];
  };

  _proto5.serialize = function serialize(value) {
    var enumValue = this._valueLookup.get(value);

    if (enumValue) {
      return enumValue.name;
    }
  };

  _proto5.parseValue = function parseValue(value)
  /* T */
  {
    if (typeof value === 'string') {
      var enumValue = this.getValue(value);

      if (enumValue) {
        return enumValue.value;
      }
    }
  };

  _proto5.parseLiteral = function parseLiteral(valueNode, _variables)
  /* T */
  {
    // Note: variables will be resolved to a value before calling this function.
    if (valueNode.kind === Kind.ENUM) {
      var enumValue = this.getValue(valueNode.value);

      if (enumValue) {
        return enumValue.value;
      }
    }
  };

  _proto5.toConfig = function toConfig() {
    var values = keyValMap(this.getValues(), function (value) {
      return value.name;
    }, function (value) {
      return {
        description: value.description,
        value: value.value,
        deprecationReason: value.deprecationReason,
        extensions: value.extensions,
        astNode: value.astNode
      };
    });
    return {
      name: this.name,
      description: this.description,
      values: values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes || []
    };
  };

  _proto5.toString = function toString() {
    return this.name;
  };

  return GraphQLEnumType;
}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

defineToStringTag(GraphQLEnumType);
defineToJSON(GraphQLEnumType);

function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(0, "".concat(typeName, " values must be an object with value names as keys."));
  return objectEntries(valueMap).map(function (_ref2) {
    var valueName = _ref2[0],
        value = _ref2[1];
    isPlainObj(value) || devAssert(0, "".concat(typeName, ".").concat(valueName, " must refer to an object with a \"value\" key ") + "representing an internal value but got: ".concat(inspect(value), "."));
    !('isDeprecated' in value) || devAssert(0, "".concat(typeName, ".").concat(valueName, " should provide \"deprecationReason\" instead of \"isDeprecated\"."));
    return {
      name: valueName,
      description: value.description,
      value: 'value' in value ? value.value : valueName,
      isDeprecated: Boolean(value.deprecationReason),
      deprecationReason: value.deprecationReason,
      extensions: value.extensions && toObjMap(value.extensions),
      astNode: value.astNode
    };
  });
}

/**
 * Input Object Type Definition
 *
 * An input object defines a structured collection of fields which may be
 * supplied to a field argument.
 *
 * Using `NonNull` will ensure that a value must be provided by the query
 *
 * Example:
 *
 *     const GeoPoint = new GraphQLInputObjectType({
 *       name: 'GeoPoint',
 *       fields: {
 *         lat: { type: GraphQLNonNull(GraphQLFloat) },
 *         lon: { type: GraphQLNonNull(GraphQLFloat) },
 *         alt: { type: GraphQLFloat, defaultValue: 0 },
 *       }
 *     });
 *
 */
var GraphQLInputObjectType =
/*#__PURE__*/
function () {
  function GraphQLInputObjectType(config) {
    this.name = config.name;
    this.description = config.description;
    this.extensions = config.extensions && toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
    this._fields = defineInputFieldMap.bind(undefined, config);
    typeof config.name === 'string' || devAssert(0, 'Must provide name.');
  }

  var _proto6 = GraphQLInputObjectType.prototype;

  _proto6.getFields = function getFields() {
    if (typeof this._fields === 'function') {
      this._fields = this._fields();
    }

    return this._fields;
  };

  _proto6.toConfig = function toConfig() {
    var fields = mapValue(this.getFields(), function (field) {
      return {
        description: field.description,
        type: field.type,
        defaultValue: field.defaultValue,
        extensions: field.extensions,
        astNode: field.astNode
      };
    });
    return {
      name: this.name,
      description: this.description,
      fields: fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes || []
    };
  };

  _proto6.toString = function toString() {
    return this.name;
  };

  return GraphQLInputObjectType;
}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

defineToStringTag(GraphQLInputObjectType);
defineToJSON(GraphQLInputObjectType);

function defineInputFieldMap(config) {
  var fieldMap = resolveThunk(config.fields) || {};
  isPlainObj(fieldMap) || devAssert(0, "".concat(config.name, " fields must be an object with field names as keys or a function which returns such an object."));
  return mapValue(fieldMap, function (fieldConfig, fieldName) {
    !('resolve' in fieldConfig) || devAssert(0, "".concat(config.name, ".").concat(fieldName, " field has a resolve property, but Input Types cannot define resolvers."));
    return _objectSpread({}, fieldConfig, {
      name: fieldName,
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    });
  });
}

/**
 * The set of allowed directive location values.
 */
var DirectiveLocation = Object.freeze({
  // Request Definitions
  QUERY: 'QUERY',
  MUTATION: 'MUTATION',
  SUBSCRIPTION: 'SUBSCRIPTION',
  FIELD: 'FIELD',
  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',
  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',
  INLINE_FRAGMENT: 'INLINE_FRAGMENT',
  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',
  // Type System Definitions
  SCHEMA: 'SCHEMA',
  SCALAR: 'SCALAR',
  OBJECT: 'OBJECT',
  FIELD_DEFINITION: 'FIELD_DEFINITION',
  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',
  INTERFACE: 'INTERFACE',
  UNION: 'UNION',
  ENUM: 'ENUM',
  ENUM_VALUE: 'ENUM_VALUE',
  INPUT_OBJECT: 'INPUT_OBJECT',
  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'
});
/**
 * The enum type representing the directive location values.
 */

/* eslint-disable no-redeclare */
// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/4441
var isFinitePolyfill = Number.isFinite || function (value) {
  return typeof value === 'number' && isFinite(value);
};

/* eslint-disable no-redeclare */
// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/4441
var isInteger = Number.isInteger || function (value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
};

// 32-bit signed integer, providing the broadest support across platforms.
//
// n.b. JavaScript's integers are safe between -(2^53 - 1) and 2^53 - 1 because
// they are internally represented as IEEE 754 doubles.

var MAX_INT = 2147483647;
var MIN_INT = -2147483648;

function serializeInt(value) {
  if (typeof value === 'boolean') {
    return value ? 1 : 0;
  }

  var num = value;

  if (typeof value === 'string' && value !== '') {
    num = Number(value);
  }

  if (!isInteger(num)) {
    throw new TypeError("Int cannot represent non-integer value: ".concat(inspect(value)));
  }

  if (num > MAX_INT || num < MIN_INT) {
    throw new TypeError("Int cannot represent non 32-bit signed integer value: ".concat(inspect(value)));
  }

  return num;
}

function coerceInt(value) {
  if (!isInteger(value)) {
    throw new TypeError("Int cannot represent non-integer value: ".concat(inspect(value)));
  }

  if (value > MAX_INT || value < MIN_INT) {
    throw new TypeError("Int cannot represent non 32-bit signed integer value: ".concat(inspect(value)));
  }

  return value;
}

var GraphQLInt = new GraphQLScalarType({
  name: 'Int',
  description: 'The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.',
  serialize: serializeInt,
  parseValue: coerceInt,
  parseLiteral: function parseLiteral(ast) {
    if (ast.kind === Kind.INT) {
      var num = parseInt(ast.value, 10);

      if (num <= MAX_INT && num >= MIN_INT) {
        return num;
      }
    }

    return undefined;
  }
});

function serializeFloat(value) {
  if (typeof value === 'boolean') {
    return value ? 1 : 0;
  }

  var num = value;

  if (typeof value === 'string' && value !== '') {
    num = Number(value);
  }

  if (!isFinitePolyfill(num)) {
    throw new TypeError("Float cannot represent non numeric value: ".concat(inspect(value)));
  }

  return num;
}

function coerceFloat(value) {
  if (!isFinitePolyfill(value)) {
    throw new TypeError("Float cannot represent non numeric value: ".concat(inspect(value)));
  }

  return value;
}

var GraphQLFloat = new GraphQLScalarType({
  name: 'Float',
  description: 'The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).',
  serialize: serializeFloat,
  parseValue: coerceFloat,
  parseLiteral: function parseLiteral(ast) {
    return ast.kind === Kind.FLOAT || ast.kind === Kind.INT ? parseFloat(ast.value) : undefined;
  }
}); // Support serializing objects with custom valueOf() or toJSON() functions -
// a common way to represent a complex value which can be represented as
// a string (ex: MongoDB id objects).

function serializeObject(value) {
  if (isObjectLike(value)) {
    if (typeof value.valueOf === 'function') {
      var valueOfResult = value.valueOf();

      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }

    if (typeof value.toJSON === 'function') {
      // $FlowFixMe(>=0.90.0)
      return value.toJSON();
    }
  }

  return value;
}

function serializeString(rawValue) {
  var value = serializeObject(rawValue); // Serialize string, boolean and number values to a string, but do not
  // attempt to coerce object, function, symbol, or other types as strings.

  if (typeof value === 'string') {
    return value;
  }

  if (typeof value === 'boolean') {
    return value ? 'true' : 'false';
  }

  if (isFinitePolyfill(value)) {
    return value.toString();
  }

  throw new TypeError("String cannot represent value: ".concat(inspect(rawValue)));
}

function coerceString(value) {
  if (typeof value !== 'string') {
    throw new TypeError("String cannot represent a non string value: ".concat(inspect(value)));
  }

  return value;
}

var GraphQLString = new GraphQLScalarType({
  name: 'String',
  description: 'The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.',
  serialize: serializeString,
  parseValue: coerceString,
  parseLiteral: function parseLiteral(ast) {
    return ast.kind === Kind.STRING ? ast.value : undefined;
  }
});

function serializeBoolean(value) {
  if (typeof value === 'boolean') {
    return value;
  }

  if (isFinitePolyfill(value)) {
    return value !== 0;
  }

  throw new TypeError("Boolean cannot represent a non boolean value: ".concat(inspect(value)));
}

function coerceBoolean(value) {
  if (typeof value !== 'boolean') {
    throw new TypeError("Boolean cannot represent a non boolean value: ".concat(inspect(value)));
  }

  return value;
}

var GraphQLBoolean = new GraphQLScalarType({
  name: 'Boolean',
  description: 'The `Boolean` scalar type represents `true` or `false`.',
  serialize: serializeBoolean,
  parseValue: coerceBoolean,
  parseLiteral: function parseLiteral(ast) {
    return ast.kind === Kind.BOOLEAN ? ast.value : undefined;
  }
});

function serializeID(rawValue) {
  var value = serializeObject(rawValue);

  if (typeof value === 'string') {
    return value;
  }

  if (isInteger(value)) {
    return String(value);
  }

  throw new TypeError("ID cannot represent value: ".concat(inspect(rawValue)));
}

function coerceID(value) {
  if (typeof value === 'string') {
    return value;
  }

  if (isInteger(value)) {
    return value.toString();
  }

  throw new TypeError("ID cannot represent value: ".concat(inspect(value)));
}

var GraphQLID = new GraphQLScalarType({
  name: 'ID',
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize: serializeID,
  parseValue: coerceID,
  parseLiteral: function parseLiteral(ast) {
    return ast.kind === Kind.STRING || ast.kind === Kind.INT ? ast.value : undefined;
  }
});
var specifiedScalarTypes = Object.freeze([GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID]);

/**
 * Directives are used by the GraphQL runtime as a way of modifying execution
 * behavior. Type system creators will usually not create these directly.
 */

var GraphQLDirective =
/*#__PURE__*/
function () {
  function GraphQLDirective(config) {
    this.name = config.name;
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = config.isRepeatable != null && config.isRepeatable;
    this.extensions = config.extensions && toObjMap(config.extensions);
    this.astNode = config.astNode;
    config.name || devAssert(0, 'Directive must be named.');
    Array.isArray(config.locations) || devAssert(0, "@".concat(config.name, " locations must be an Array."));
    var args = config.args || {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(0, "@".concat(config.name, " args must be an object with argument names as keys."));
    this.args = objectEntries(args).map(function (_ref) {
      var argName = _ref[0],
          arg = _ref[1];
      return {
        name: argName,
        description: arg.description === undefined ? null : arg.description,
        type: arg.type,
        defaultValue: arg.defaultValue,
        extensions: arg.extensions && toObjMap(arg.extensions),
        astNode: arg.astNode
      };
    });
  }

  var _proto = GraphQLDirective.prototype;

  _proto.toString = function toString() {
    return '@' + this.name;
  };

  _proto.toConfig = function toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  };

  return GraphQLDirective;
}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

defineToStringTag(GraphQLDirective);
defineToJSON(GraphQLDirective);

/**
 * Used to conditionally include fields or fragments.
 */
var GraphQLIncludeDirective = new GraphQLDirective({
  name: 'include',
  description: 'Directs the executor to include this field or fragment only when the `if` argument is true.',
  locations: [DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
  args: {
    if: {
      type: GraphQLNonNull(GraphQLBoolean),
      description: 'Included when true.'
    }
  }
});
/**
 * Used to conditionally skip (exclude) fields or fragments.
 */

var GraphQLSkipDirective = new GraphQLDirective({
  name: 'skip',
  description: 'Directs the executor to skip this field or fragment when the `if` argument is true.',
  locations: [DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
  args: {
    if: {
      type: GraphQLNonNull(GraphQLBoolean),
      description: 'Skipped when true.'
    }
  }
});
/**
 * Constant string used for default reason for a deprecation.
 */

var DEFAULT_DEPRECATION_REASON = 'No longer supported';
/**
 * Used to declare element of a GraphQL schema as deprecated.
 */

var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: 'deprecated',
  description: 'Marks an element of a GraphQL schema as no longer supported.',
  locations: [DirectiveLocation.FIELD_DEFINITION, DirectiveLocation.ENUM_VALUE],
  args: {
    reason: {
      type: GraphQLString,
      description: 'Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax (as specified by [CommonMark](https://commonmark.org/).',
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
/**
 * The full list of specified directives.
 */

var specifiedDirectives = Object.freeze([GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective]);

var QueryDocumentKeys = {
  Name: [],
  Document: ['definitions'],
  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],
  Variable: ['name'],
  SelectionSet: ['selections'],
  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
  Argument: ['name', 'value'],
  FragmentSpread: ['name', 'directives'],
  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed
  // or removed in the future.
  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ['values'],
  ObjectValue: ['fields'],
  ObjectField: ['name', 'value'],
  Directive: ['name', 'arguments'],
  NamedType: ['name'],
  ListType: ['type'],
  NonNullType: ['type'],
  SchemaDefinition: ['directives', 'operationTypes'],
  OperationTypeDefinition: ['type'],
  ScalarTypeDefinition: ['description', 'name', 'directives'],
  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],
  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
  EnumValueDefinition: ['description', 'name', 'directives'],
  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
  SchemaExtension: ['directives', 'operationTypes'],
  ScalarTypeExtension: ['name', 'directives'],
  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
  InterfaceTypeExtension: ['name', 'directives', 'fields'],
  UnionTypeExtension: ['name', 'directives', 'types'],
  EnumTypeExtension: ['name', 'directives', 'values'],
  InputObjectTypeExtension: ['name', 'directives', 'fields']
};
var BREAK = Object.freeze({});
/**
 * visit() will walk through an AST using a depth first traversal, calling
 * the visitor's enter function at each node in the traversal, and calling the
 * leave function after visiting that node and all of its child nodes.
 *
 * By returning different values from the enter and leave functions, the
 * behavior of the visitor can be altered, including skipping over a sub-tree of
 * the AST (by returning false), editing the AST by returning a value or null
 * to remove the value, or to stop the whole traversal by returning BREAK.
 *
 * When using visit() to edit an AST, the original AST will not be modified, and
 * a new version of the AST with the changes applied will be returned from the
 * visit function.
 *
 *     const editedAST = visit(ast, {
 *       enter(node, key, parent, path, ancestors) {
 *         // @return
 *         //   undefined: no action
 *         //   false: skip visiting this node
 *         //   visitor.BREAK: stop visiting altogether
 *         //   null: delete this node
 *         //   any value: replace this node with the returned value
 *       },
 *       leave(node, key, parent, path, ancestors) {
 *         // @return
 *         //   undefined: no action
 *         //   false: no action
 *         //   visitor.BREAK: stop visiting altogether
 *         //   null: delete this node
 *         //   any value: replace this node with the returned value
 *       }
 *     });
 *
 * Alternatively to providing enter() and leave() functions, a visitor can
 * instead provide functions named the same as the kinds of AST nodes, or
 * enter/leave visitors at a named key, leading to four permutations of
 * visitor API:
 *
 * 1) Named visitors triggered when entering a node a specific kind.
 *
 *     visit(ast, {
 *       Kind(node) {
 *         // enter the "Kind" node
 *       }
 *     })
 *
 * 2) Named visitors that trigger upon entering and leaving a node of
 *    a specific kind.
 *
 *     visit(ast, {
 *       Kind: {
 *         enter(node) {
 *           // enter the "Kind" node
 *         }
 *         leave(node) {
 *           // leave the "Kind" node
 *         }
 *       }
 *     })
 *
 * 3) Generic visitors that trigger upon entering and leaving any node.
 *
 *     visit(ast, {
 *       enter(node) {
 *         // enter any node
 *       },
 *       leave(node) {
 *         // leave any node
 *       }
 *     })
 *
 * 4) Parallel visitors for entering and leaving nodes of a specific kind.
 *
 *     visit(ast, {
 *       enter: {
 *         Kind(node) {
 *           // enter the "Kind" node
 *         }
 *       },
 *       leave: {
 *         Kind(node) {
 *           // leave the "Kind" node
 *         }
 *       }
 *     })
 */

function visit(root, visitor) {
  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;

  /* eslint-disable no-undef-init */
  var stack = undefined;
  var inArray = Array.isArray(root);
  var keys = [root];
  var index = -1;
  var edits = [];
  var node = undefined;
  var key = undefined;
  var parent = undefined;
  var path = [];
  var ancestors = [];
  var newRoot = root;
  /* eslint-enable no-undef-init */

  do {
    index++;
    var isLeaving = index === keys.length;
    var isEdited = isLeaving && edits.length !== 0;

    if (isLeaving) {
      key = ancestors.length === 0 ? undefined : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();

      if (isEdited) {
        if (inArray) {
          node = node.slice();
        } else {
          var clone = {};

          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {
            var k = _Object$keys2[_i2];
            clone[k] = node[k];
          }

          node = clone;
        }

        var editOffset = 0;

        for (var ii = 0; ii < edits.length; ii++) {
          var editKey = edits[ii][0];
          var editValue = edits[ii][1];

          if (inArray) {
            editKey -= editOffset;
          }

          if (inArray && editValue === null) {
            node.splice(editKey, 1);
            editOffset++;
          } else {
            node[editKey] = editValue;
          }
        }
      }

      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else {
      key = parent ? inArray ? index : keys[index] : undefined;
      node = parent ? parent[key] : newRoot;

      if (node === null || node === undefined) {
        continue;
      }

      if (parent) {
        path.push(key);
      }
    }

    var result = void 0;

    if (!Array.isArray(node)) {
      if (!isNode(node)) {
        throw new Error('Invalid AST Node: ' + inspect(node));
      }

      var visitFn = getVisitFn(visitor, node.kind, isLeaving);

      if (visitFn) {
        result = visitFn.call(visitor, node, key, parent, path, ancestors);

        if (result === BREAK) {
          break;
        }

        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== undefined) {
          edits.push([key, result]);

          if (!isLeaving) {
            if (isNode(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
    }

    if (result === undefined && isEdited) {
      edits.push([key, node]);
    }

    if (isLeaving) {
      path.pop();
    } else {
      stack = {
        inArray: inArray,
        index: index,
        keys: keys,
        edits: edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : visitorKeys[node.kind] || [];
      index = -1;
      edits = [];

      if (parent) {
        ancestors.push(parent);
      }

      parent = node;
    }
  } while (stack !== undefined);

  if (edits.length !== 0) {
    newRoot = edits[edits.length - 1][1];
  }

  return newRoot;
}

function isNode(maybeNode) {
  return Boolean(maybeNode && typeof maybeNode.kind === 'string');
}
/**
 * Given a visitor instance, if it is leaving or not, and a node kind, return
 * the function the visitor runtime should call.
 */

function getVisitFn(visitor, kind, isLeaving) {
  var kindVisitor = visitor[kind];

  if (kindVisitor) {
    if (!isLeaving && typeof kindVisitor === 'function') {
      // { Kind() {} }
      return kindVisitor;
    }

    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;

    if (typeof kindSpecificVisitor === 'function') {
      // { Kind: { enter() {}, leave() {} } }
      return kindSpecificVisitor;
    }
  } else {
    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;

    if (specificVisitor) {
      if (typeof specificVisitor === 'function') {
        // { enter() {}, leave() {} }
        return specificVisitor;
      }

      var specificKindVisitor = specificVisitor[kind];

      if (typeof specificKindVisitor === 'function') {
        // { enter: { Kind() {} }, leave: { Kind() {} } }
        return specificKindVisitor;
      }
    }
  }
}

/**
 * Produces the value of a block string from its parsed raw value, similar to
 * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.
 *
 * This implements the GraphQL spec's BlockStringValue() static algorithm.
 */
/**
 * Print a block string in the indented block form by adding a leading and
 * trailing blank line. However, if a block string starts with whitespace and is
 * a single-line, adding a leading blank line would strip that whitespace.
 */


function printBlockString(value) {
  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isSingleLine = value.indexOf('\n') === -1;
  var hasLeadingSpace = value[0] === ' ' || value[0] === '\t';
  var hasTrailingQuote = value[value.length - 1] === '"';
  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || preferMultipleLines;
  var result = ''; // Format a multi-line block quote to account for leading space.

  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
    result += '\n' + indentation;
  }

  result += indentation ? value.replace(/\n/g, '\n' + indentation) : value;

  if (printAsMultipleLines) {
    result += '\n';
  }

  return '"""' + result.replace(/"""/g, '\\"""') + '"""';
}

/**
 * Converts an AST into a string, using one set of reasonable
 * formatting rules.
 */

function print(ast) {
  return visit(ast, {
    leave: printDocASTReducer
  });
} // TODO: provide better type coverage in future

var printDocASTReducer = {
  Name: function Name(node) {
    return node.value;
  },
  Variable: function Variable(node) {
    return '$' + node.name;
  },
  // Document
  Document: function Document(node) {
    return join(node.definitions, '\n\n') + '\n';
  },
  OperationDefinition: function OperationDefinition(node) {
    var op = node.operation;
    var name = node.name;
    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');
    var directives = join(node.directives, ' ');
    var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use
    // the query short form.

    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');
  },
  VariableDefinition: function VariableDefinition(_ref) {
    var variable = _ref.variable,
        type = _ref.type,
        defaultValue = _ref.defaultValue,
        directives = _ref.directives;
    return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));
  },
  SelectionSet: function SelectionSet(_ref2) {
    var selections = _ref2.selections;
    return block(selections);
  },
  Field: function Field(_ref3) {
    var alias = _ref3.alias,
        name = _ref3.name,
        args = _ref3.arguments,
        directives = _ref3.directives,
        selectionSet = _ref3.selectionSet;
    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');
  },
  Argument: function Argument(_ref4) {
    var name = _ref4.name,
        value = _ref4.value;
    return name + ': ' + value;
  },
  // Fragments
  FragmentSpread: function FragmentSpread(_ref5) {
    var name = _ref5.name,
        directives = _ref5.directives;
    return '...' + name + wrap(' ', join(directives, ' '));
  },
  InlineFragment: function InlineFragment(_ref6) {
    var typeCondition = _ref6.typeCondition,
        directives = _ref6.directives,
        selectionSet = _ref6.selectionSet;
    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');
  },
  FragmentDefinition: function FragmentDefinition(_ref7) {
    var name = _ref7.name,
        typeCondition = _ref7.typeCondition,
        variableDefinitions = _ref7.variableDefinitions,
        directives = _ref7.directives,
        selectionSet = _ref7.selectionSet;
    return (// Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      "fragment ".concat(name).concat(wrap('(', join(variableDefinitions, ', '), ')'), " ") + "on ".concat(typeCondition, " ").concat(wrap('', join(directives, ' '), ' ')) + selectionSet
    );
  },
  // Value
  IntValue: function IntValue(_ref8) {
    var value = _ref8.value;
    return value;
  },
  FloatValue: function FloatValue(_ref9) {
    var value = _ref9.value;
    return value;
  },
  StringValue: function StringValue(_ref10, key) {
    var value = _ref10.value,
        isBlockString = _ref10.block;
    return isBlockString ? printBlockString(value, key === 'description' ? '' : '  ') : JSON.stringify(value);
  },
  BooleanValue: function BooleanValue(_ref11) {
    var value = _ref11.value;
    return value ? 'true' : 'false';
  },
  NullValue: function NullValue() {
    return 'null';
  },
  EnumValue: function EnumValue(_ref12) {
    var value = _ref12.value;
    return value;
  },
  ListValue: function ListValue(_ref13) {
    var values = _ref13.values;
    return '[' + join(values, ', ') + ']';
  },
  ObjectValue: function ObjectValue(_ref14) {
    var fields = _ref14.fields;
    return '{' + join(fields, ', ') + '}';
  },
  ObjectField: function ObjectField(_ref15) {
    var name = _ref15.name,
        value = _ref15.value;
    return name + ': ' + value;
  },
  // Directive
  Directive: function Directive(_ref16) {
    var name = _ref16.name,
        args = _ref16.arguments;
    return '@' + name + wrap('(', join(args, ', '), ')');
  },
  // Type
  NamedType: function NamedType(_ref17) {
    var name = _ref17.name;
    return name;
  },
  ListType: function ListType(_ref18) {
    var type = _ref18.type;
    return '[' + type + ']';
  },
  NonNullType: function NonNullType(_ref19) {
    var type = _ref19.type;
    return type + '!';
  },
  // Type System Definitions
  SchemaDefinition: function SchemaDefinition(_ref20) {
    var directives = _ref20.directives,
        operationTypes = _ref20.operationTypes;
    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');
  },
  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
    var operation = _ref21.operation,
        type = _ref21.type;
    return operation + ': ' + type;
  },
  ScalarTypeDefinition: addDescription(function (_ref22) {
    var name = _ref22.name,
        directives = _ref22.directives;
    return join(['scalar', name, join(directives, ' ')], ' ');
  }),
  ObjectTypeDefinition: addDescription(function (_ref23) {
    var name = _ref23.name,
        interfaces = _ref23.interfaces,
        directives = _ref23.directives,
        fields = _ref23.fields;
    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  }),
  FieldDefinition: addDescription(function (_ref24) {
    var name = _ref24.name,
        args = _ref24.arguments,
        type = _ref24.type,
        directives = _ref24.directives;
    return name + (hasMultilineItems(args) ? wrap('(\n', indent(join(args, '\n')), '\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));
  }),
  InputValueDefinition: addDescription(function (_ref25) {
    var name = _ref25.name,
        type = _ref25.type,
        defaultValue = _ref25.defaultValue,
        directives = _ref25.directives;
    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');
  }),
  InterfaceTypeDefinition: addDescription(function (_ref26) {
    var name = _ref26.name,
        directives = _ref26.directives,
        fields = _ref26.fields;
    return join(['interface', name, join(directives, ' '), block(fields)], ' ');
  }),
  UnionTypeDefinition: addDescription(function (_ref27) {
    var name = _ref27.name,
        directives = _ref27.directives,
        types = _ref27.types;
    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
  }),
  EnumTypeDefinition: addDescription(function (_ref28) {
    var name = _ref28.name,
        directives = _ref28.directives,
        values = _ref28.values;
    return join(['enum', name, join(directives, ' '), block(values)], ' ');
  }),
  EnumValueDefinition: addDescription(function (_ref29) {
    var name = _ref29.name,
        directives = _ref29.directives;
    return join([name, join(directives, ' ')], ' ');
  }),
  InputObjectTypeDefinition: addDescription(function (_ref30) {
    var name = _ref30.name,
        directives = _ref30.directives,
        fields = _ref30.fields;
    return join(['input', name, join(directives, ' '), block(fields)], ' ');
  }),
  DirectiveDefinition: addDescription(function (_ref31) {
    var name = _ref31.name,
        args = _ref31.arguments,
        repeatable = _ref31.repeatable,
        locations = _ref31.locations;
    return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\n', indent(join(args, '\n')), '\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');
  }),
  SchemaExtension: function SchemaExtension(_ref32) {
    var directives = _ref32.directives,
        operationTypes = _ref32.operationTypes;
    return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');
  },
  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
    var name = _ref33.name,
        directives = _ref33.directives;
    return join(['extend scalar', name, join(directives, ' ')], ' ');
  },
  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
    var name = _ref34.name,
        interfaces = _ref34.interfaces,
        directives = _ref34.directives,
        fields = _ref34.fields;
    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  },
  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
    var name = _ref35.name,
        directives = _ref35.directives,
        fields = _ref35.fields;
    return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');
  },
  UnionTypeExtension: function UnionTypeExtension(_ref36) {
    var name = _ref36.name,
        directives = _ref36.directives,
        types = _ref36.types;
    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
  },
  EnumTypeExtension: function EnumTypeExtension(_ref37) {
    var name = _ref37.name,
        directives = _ref37.directives,
        values = _ref37.values;
    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');
  },
  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
    var name = _ref38.name,
        directives = _ref38.directives,
        fields = _ref38.fields;
    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');
  }
};

function addDescription(cb) {
  return function (node) {
    return join([node.description, cb(node)], '\n');
  };
}
/**
 * Given maybeArray, print an empty string if it is null or empty, otherwise
 * print all items together separated by separator if provided
 */


function join(maybeArray, separator) {
  return maybeArray ? maybeArray.filter(function (x) {
    return x;
  }).join(separator || '') : '';
}
/**
 * Given array, print each item on its own line, wrapped in an
 * indented "{ }" block.
 */


function block(array) {
  return array && array.length !== 0 ? '{\n' + indent(join(array, '\n')) + '\n}' : '';
}
/**
 * If maybeString is not null or empty, then wrap with start and end, otherwise
 * print an empty string.
 */


function wrap(start, maybeString, end) {
  return maybeString ? start + maybeString + (end || '') : '';
}

function indent(maybeString) {
  return maybeString && '  ' + maybeString.replace(/\n/g, '\n  ');
}

function isMultiline(string) {
  return string.indexOf('\n') !== -1;
}

function hasMultilineItems(maybeArray) {
  return maybeArray && maybeArray.some(isMultiline);
}

/**
 * Given a Schema and an AST node describing a type, return a GraphQLType
 * definition which applies to that type. For example, if provided the parsed
 * AST node for `[User]`, a GraphQLList instance will be returned, containing
 * the type called "User" found in the schema. If a type called "User" is not
 * found in the schema, then undefined will be returned.
 */

/* eslint-disable no-redeclare */

function typeFromAST(schema, typeNode) {
  /* eslint-enable no-redeclare */
  var innerType;

  if (typeNode.kind === Kind.LIST_TYPE) {
    innerType = typeFromAST(schema, typeNode.type);
    return innerType && GraphQLList(innerType);
  }

  if (typeNode.kind === Kind.NON_NULL_TYPE) {
    innerType = typeFromAST(schema, typeNode.type);
    return innerType && GraphQLNonNull(innerType);
  }

  /* istanbul ignore else */
  if (typeNode.kind === Kind.NAMED_TYPE) {
    return schema.getType(typeNode.name.value);
  } // Not reachable. All possible type nodes have been considered.


  /* istanbul ignore next */
  invariant(false, 'Unexpected type node: ' + inspect(typeNode));
}

/**
 * Produces a JavaScript value given a GraphQL Value AST.
 *
 * A GraphQL type must be provided, which will be used to interpret different
 * GraphQL Value literals.
 *
 * Returns `undefined` when the value could not be validly coerced according to
 * the provided type.
 *
 * | GraphQL Value        | JSON Value    |
 * | -------------------- | ------------- |
 * | Input Object         | Object        |
 * | List                 | Array         |
 * | Boolean              | Boolean       |
 * | String               | String        |
 * | Int / Float          | Number        |
 * | Enum Value           | Mixed         |
 * | NullValue            | null          |
 *
 */

function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    // When there is no node, then there is also no value.
    // Importantly, this is different from returning the value null.
    return;
  }

  if (isNonNullType(type)) {
    if (valueNode.kind === Kind.NULL) {
      return; // Invalid: intentionally return no value.
    }

    return valueFromAST(valueNode, type.ofType, variables);
  }

  if (valueNode.kind === Kind.NULL) {
    // This is explicitly returning the value null.
    return null;
  }

  if (valueNode.kind === Kind.VARIABLE) {
    var variableName = valueNode.name.value;

    if (!variables || isInvalid(variables[variableName])) {
      // No valid return value.
      return;
    }

    var variableValue = variables[variableName];

    if (variableValue === null && isNonNullType(type)) {
      return; // Invalid: intentionally return no value.
    } // Note: This does no further checking that this variable is correct.
    // This assumes that this query has been validated and the variable
    // usage here is of the correct type.


    return variableValue;
  }

  if (isListType(type)) {
    var itemType = type.ofType;

    if (valueNode.kind === Kind.LIST) {
      var coercedValues = [];

      for (var _i2 = 0, _valueNode$values2 = valueNode.values; _i2 < _valueNode$values2.length; _i2++) {
        var itemNode = _valueNode$values2[_i2];

        if (isMissingVariable(itemNode, variables)) {
          // If an array contains a missing variable, it is either coerced to
          // null or if the item type is non-null, it considered invalid.
          if (isNonNullType(itemType)) {
            return; // Invalid: intentionally return no value.
          }

          coercedValues.push(null);
        } else {
          var itemValue = valueFromAST(itemNode, itemType, variables);

          if (isInvalid(itemValue)) {
            return; // Invalid: intentionally return no value.
          }

          coercedValues.push(itemValue);
        }
      }

      return coercedValues;
    }

    var coercedValue = valueFromAST(valueNode, itemType, variables);

    if (isInvalid(coercedValue)) {
      return; // Invalid: intentionally return no value.
    }

    return [coercedValue];
  }

  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return; // Invalid: intentionally return no value.
    }

    var coercedObj = Object.create(null);
    var fieldNodes = keyMap(valueNode.fields, function (field) {
      return field.name.value;
    });

    for (var _i4 = 0, _objectValues2 = objectValues(type.getFields()); _i4 < _objectValues2.length; _i4++) {
      var field = _objectValues2[_i4];
      var fieldNode = fieldNodes[field.name];

      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== undefined) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return; // Invalid: intentionally return no value.
        }

        continue;
      }

      var fieldValue = valueFromAST(fieldNode.value, field.type, variables);

      if (isInvalid(fieldValue)) {
        return; // Invalid: intentionally return no value.
      }

      coercedObj[field.name] = fieldValue;
    }

    return coercedObj;
  }

  if (isEnumType(type)) {
    if (valueNode.kind !== Kind.ENUM) {
      return; // Invalid: intentionally return no value.
    }

    var enumValue = type.getValue(valueNode.value);

    if (!enumValue) {
      return; // Invalid: intentionally return no value.
    }

    return enumValue.value;
  }

  /* istanbul ignore else */
  if (isScalarType(type)) {
    // Scalars fulfill parsing a literal value via parseLiteral().
    // Invalid values represent a failure to parse correctly, in which case
    // no value is returned.
    var result;

    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return; // Invalid: intentionally return no value.
    }

    if (isInvalid(result)) {
      return; // Invalid: intentionally return no value.
    }

    return result;
  } // Not reachable. All possible input types have been considered.


  /* istanbul ignore next */
  invariant(false, 'Unexpected input type: ' + inspect(type));
} // Returns true if the provided valueNode is a variable which is not defined
// in the set of variables.

function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (!variables || isInvalid(variables[valueNode.name.value]));
}

/**
 * Prepares an object map of argument values given a list of argument
 * definitions and list of argument AST nodes.
 *
 * Note: The returned value is a plain Object with a prototype, since it is
 * exposed to user code. Care should be taken to not pull values from the
 * Object prototype.
 */


function getArgumentValues(def, node, variableValues) {
  var coercedValues = {};
  var argNodeMap = keyMap(node.arguments || [], function (arg) {
    return arg.name.value;
  });

  for (var _i4 = 0, _def$args2 = def.args; _i4 < _def$args2.length; _i4++) {
    var argDef = _def$args2[_i4];
    var name = argDef.name;
    var argType = argDef.type;
    var argumentNode = argNodeMap[name];

    if (!argumentNode) {
      if (argDef.defaultValue !== undefined) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError("Argument \"".concat(name, "\" of required type \"").concat(inspect(argType), "\" ") + 'was not provided.', node);
      }

      continue;
    }

    var valueNode = argumentNode.value;
    var isNull = valueNode.kind === Kind.NULL;

    if (valueNode.kind === Kind.VARIABLE) {
      var variableName = valueNode.name.value;

      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== undefined) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError("Argument \"".concat(name, "\" of required type \"").concat(inspect(argType), "\" ") + "was provided the variable \"$".concat(variableName, "\" which was not provided a runtime value."), valueNode);
        }

        continue;
      }

      isNull = variableValues[variableName] == null;
    }

    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError("Argument \"".concat(name, "\" of non-null type \"").concat(inspect(argType), "\" ") + 'must not be null.', valueNode);
    }

    var coercedValue = valueFromAST(valueNode, argType, variableValues);

    if (coercedValue === undefined) {
      // Note: ValuesOfCorrectType validation should catch this before
      // execution. This is a runtime check to ensure execution does not
      // continue with an invalid argument value.
      throw new GraphQLError("Argument \"".concat(name, "\" has invalid value ").concat(print(valueNode), "."), valueNode);
    }

    coercedValues[name] = coercedValue;
  }

  return coercedValues;
}
/**
 * Prepares an object map of argument values given a directive definition
 * and a AST node which may contain directives. Optionally also accepts a map
 * of variable values.
 *
 * If the directive does not exist on the node, returns undefined.
 *
 * Note: The returned value is a plain Object with a prototype, since it is
 * exposed to user code. Care should be taken to not pull values from the
 * Object prototype.
 */

function getDirectiveValues(directiveDef, node, variableValues) {
  var directiveNode = node.directives && find(node.directives, function (directive) {
    return directive.name.value === directiveDef.name;
  });

  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

/**
 * Given a selectionSet, adds all of the fields in that selection to
 * the passed in map of fields, and returns it at the end.
 *
 * CollectFields requires the "runtime type" of an object. For a field which
 * returns an Interface or Union type, the "runtime type" will be the actual
 * Object type returned by that field.
 */


function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (var _i6 = 0, _selectionSet$selecti2 = selectionSet.selections; _i6 < _selectionSet$selecti2.length; _i6++) {
    var selection = _selectionSet$selecti2[_i6];

    switch (selection.kind) {
      case Kind.FIELD:
        {
          if (!shouldIncludeNode(exeContext, selection)) {
            continue;
          }

          var name = getFieldEntryKey(selection);

          if (!fields[name]) {
            fields[name] = [];
          }

          fields[name].push(selection);
          break;
        }

      case Kind.INLINE_FRAGMENT:
        {
          if (!shouldIncludeNode(exeContext, selection) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {
            continue;
          }

          collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
          break;
        }

      case Kind.FRAGMENT_SPREAD:
        {
          var fragName = selection.name.value;

          if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection)) {
            continue;
          }

          visitedFragmentNames[fragName] = true;
          var fragment = exeContext.fragments[fragName];

          if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {
            continue;
          }

          collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
          break;
        }
    }
  }

  return fields;
}
/**
 * Determines if a field should be included based on the @include and @skip
 * directives, where @skip has higher precedence than @include.
 */

function shouldIncludeNode(exeContext, node) {
  var skip = getDirectiveValues(GraphQLSkipDirective, node, exeContext.variableValues);

  if (skip && skip.if === true) {
    return false;
  }

  var include = getDirectiveValues(GraphQLIncludeDirective, node, exeContext.variableValues);

  if (include && include.if === false) {
    return false;
  }

  return true;
}
/**
 * Determines if a fragment is applicable to the given type.
 */


function doesFragmentConditionMatch(exeContext, fragment, type) {
  var typeConditionNode = fragment.typeCondition;

  if (!typeConditionNode) {
    return true;
  }

  var conditionalType = typeFromAST(exeContext.schema, typeConditionNode);

  if (conditionalType === type) {
    return true;
  }

  if (isAbstractType(conditionalType)) {
    return exeContext.schema.isPossibleType(conditionalType, type);
  }

  return false;
}
/**
 * Implements the logic to compute the key of a given field's entry
 */


function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}

function getSubschema(result, responseKey) {
    var subschema = result[FIELD_SUBSCHEMA_MAP_SYMBOL] &&
        result[FIELD_SUBSCHEMA_MAP_SYMBOL][responseKey];
    return subschema ? subschema : result[OBJECT_SUBSCHEMA_SYMBOL];
}
function setObjectSubschema(result, subschema) {
    result[OBJECT_SUBSCHEMA_SYMBOL] = subschema;
}

function resolveFromParentTypename(parent) {
    var parentTypename = parent['__typename'];
    if (!parentTypename) {
        throw new Error('Did not fetch typename for object, unable to resolve interface.');
    }
    return parentTypename;
}

var version;
if (versionInfo != null && versionInfo.major >= 15) {
    version = 15;
}
else if (getOperationRootType != null) {
    version = 14;
}
else if (lexicographicSortSchema != null) {
    version = 13;
}
else if (printError$1 != null) {
    version = 12;
}
else {
    version = 11;
}
function graphqlVersion() {
    return version;
}

// graphql <v14.2 does not support toConfig
function schemaToConfig(schema) {
    if (schema.toConfig != null) {
        return schema.toConfig();
    }
    var newTypes = [];
    var types = schema.getTypeMap();
    Object.keys(types).forEach(function (typeName) {
        newTypes.push(types[typeName]);
    });
    var schemaConfig = {
        query: schema.getQueryType(),
        mutation: schema.getMutationType(),
        subscription: schema.getSubscriptionType(),
        types: newTypes,
        directives: schema.getDirectives().slice(),
        extensions: schema.extensions,
        astNode: schema.astNode,
        extensionASTNodes: schema.extensionASTNodes != null ? schema.extensionASTNodes : [],
        assumeValid: schema.__validationErrors !==
            undefined,
    };
    if (graphqlVersion() >= 15) {
        schemaConfig.description = schema.description;
    }
    return schemaConfig;
}
function toConfig(graphqlObject) {
    if (isSchema(graphqlObject)) {
        return schemaToConfig(graphqlObject);
    }
    else if (isDirective(graphqlObject)) {
        return directiveToConfig(graphqlObject);
    }
    else if (isNamedType(graphqlObject)) {
        return typeToConfig(graphqlObject);
    }
    // Input and output fields do not have predicates defined, but using duck typing,
    // type is defined for input and output fields
    if (graphqlObject.type != null) {
        if (graphqlObject.args != null ||
            graphqlObject.resolve != null ||
            graphqlObject.subscribe != null) {
            return fieldToConfig(graphqlObject);
        }
        else if (graphqlObject.defaultValue !== undefined) {
            return inputFieldToConfig(graphqlObject);
        }
        // Not all input and output fields can be checked by above in older versions
        // of graphql, but almost all properties on the field and config are identical.
        // In particular, just name and isDeprecated should be removed.
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var name_1 = graphqlObject.name, isDeprecated = graphqlObject.isDeprecated, rest = __rest(graphqlObject, ["name", "isDeprecated"]);
        return __assign({}, rest);
    }
    throw new Error("Unknown graphql object " + graphqlObject);
}
function typeToConfig(type) {
    if (isObjectType$1(type)) {
        return objectTypeToConfig(type);
    }
    else if (isInterfaceType$1(type)) {
        return interfaceTypeToConfig(type);
    }
    else if (isUnionType$1(type)) {
        return unionTypeToConfig(type);
    }
    else if (isEnumType$1(type)) {
        return enumTypeToConfig(type);
    }
    else if (isScalarType$1(type)) {
        return scalarTypeToConfig(type);
    }
    else if (isInputObjectType$1(type)) {
        return inputObjectTypeToConfig(type);
    }
    throw new Error("Unknown type " + type);
}
function objectTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        interfaces: type.getInterfaces(),
        fields: fieldMapToConfig(type.getFields()),
        isTypeOf: type.isTypeOf,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
function interfaceTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        fields: fieldMapToConfig(type.getFields()),
        resolveType: type.resolveType,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    if (graphqlVersion() >= 15) {
        typeConfig.interfaces = type.getInterfaces();
    }
    return typeConfig;
}
function unionTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        types: type.getTypes(),
        resolveType: type.resolveType,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
function enumTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var newValues = {};
    type.getValues().forEach(function (value) {
        newValues[value.name] = {
            description: value.description,
            value: value.value,
            deprecationReason: value.deprecationReason,
            extensions: value.extensions,
            astNode: value.astNode,
        };
    });
    var typeConfig = {
        name: type.name,
        description: type.description,
        values: newValues,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
var hasOwn = Object.prototype.hasOwnProperty;
function scalarTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        serialize: graphqlVersion() >= 14 || hasOwn.call(type, 'serialize')
            ? type.serialize
            : type._scalarConfig.serialize,
        parseValue: graphqlVersion() >= 14 || hasOwn.call(type, 'parseValue')
            ? type.parseValue
            : type._scalarConfig.parseValue,
        parseLiteral: graphqlVersion() >= 14 || hasOwn.call(type, 'parseLiteral')
            ? type.parseLiteral
            : type._scalarConfig.parseLiteral,
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
function inputObjectTypeToConfig(type) {
    if (type.toConfig != null) {
        return type.toConfig();
    }
    var typeConfig = {
        name: type.name,
        description: type.description,
        fields: inputFieldMapToConfig(type.getFields()),
        extensions: type.extensions,
        astNode: type.astNode,
        extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : [],
    };
    return typeConfig;
}
function inputFieldMapToConfig(fields) {
    var newFields = {};
    Object.keys(fields).forEach(function (fieldName) {
        var field = fields[fieldName];
        newFields[fieldName] = toConfig(field);
    });
    return newFields;
}
function inputFieldToConfig(field) {
    return {
        description: field.description,
        type: field.type,
        defaultValue: field.defaultValue,
        extensions: field.extensions,
        astNode: field.astNode,
    };
}
function directiveToConfig(directive) {
    if (directive.toConfig != null) {
        return directive.toConfig();
    }
    var directiveConfig = {
        name: directive.name,
        description: directive.description,
        locations: directive.locations,
        args: argumentMapToConfig(directive.args),
        isRepeatable: directive
            .isRepeatable,
        extensions: directive.extensions,
        astNode: directive.astNode,
    };
    return directiveConfig;
}
function fieldMapToConfig(fields) {
    var newFields = {};
    Object.keys(fields).forEach(function (fieldName) {
        var field = fields[fieldName];
        newFields[fieldName] = toConfig(field);
    });
    return newFields;
}
function fieldToConfig(field) {
    return {
        description: field.description,
        type: field.type,
        args: argumentMapToConfig(field.args),
        resolve: field.resolve,
        subscribe: field.subscribe,
        deprecationReason: field.deprecationReason,
        extensions: field.extensions,
        astNode: field.astNode,
    };
}
function argumentMapToConfig(args) {
    var newArguments = {};
    args.forEach(function (arg) {
        newArguments[arg.name] = argumentToConfig(arg);
    });
    return newArguments;
}
function argumentToConfig(arg) {
    return {
        description: arg.description,
        type: arg.type,
        defaultValue: arg.defaultValue,
        extensions: arg.extensions,
        astNode: arg.astNode,
    };
}

function isSpecifiedScalarType(type) {
    return (isNamedType(type) &&
        // Would prefer to use specifiedScalarTypes.some(), however %checks needs
        // a simple expression.
        (type.name === GraphQLString$1.name ||
            type.name === GraphQLInt$1.name ||
            type.name === GraphQLFloat$1.name ||
            type.name === GraphQLBoolean$1.name ||
            type.name === GraphQLID$1.name));
}

function mapSchema(schema, schemaMapper) {
    if (schemaMapper === void 0) { schemaMapper = {}; }
    var originalTypeMap = schema.getTypeMap();
    var newTypeMap = {};
    Object.keys(originalTypeMap).forEach(function (typeName) {
        if (!typeName.startsWith('__')) {
            var typeMapper = getMapper(schema, schemaMapper, originalTypeMap[typeName]);
            if (typeMapper != null) {
                var newType = typeMapper(originalTypeMap[typeName], schema);
                newTypeMap[typeName] =
                    newType !== undefined ? newType : originalTypeMap[typeName];
            }
            else {
                newTypeMap[typeName] = originalTypeMap[typeName];
            }
        }
    });
    var queryType = schema.getQueryType();
    var mutationType = schema.getMutationType();
    var subscriptionType = schema.getSubscriptionType();
    var newQueryTypeName = queryType != null
        ? newTypeMap[queryType.name] != null
            ? newTypeMap[queryType.name].name
            : undefined
        : undefined;
    var newMutationTypeName = mutationType != null
        ? newTypeMap[mutationType.name] != null
            ? newTypeMap[mutationType.name].name
            : undefined
        : undefined;
    var newSubscriptionTypeName = subscriptionType != null
        ? newTypeMap[subscriptionType.name] != null
            ? newTypeMap[subscriptionType.name].name
            : undefined
        : undefined;
    var originalDirectives = schema.getDirectives();
    var newDirectives = [];
    originalDirectives.forEach(function (directive) {
        var directiveMapper = getMapper(schema, schemaMapper, directive);
        if (directiveMapper != null) {
            var newDirective = directiveMapper(directive, schema);
            if (newDirective != null) {
                newDirectives.push(newDirective);
            }
        }
        else {
            newDirectives.push(directive);
        }
    });
    var _a = rewireTypes(newTypeMap, newDirectives), typeMap = _a.typeMap, directives = _a.directives;
    return new GraphQLSchema(__assign(__assign({}, toConfig(schema)), { query: newQueryTypeName
            ? typeMap[newQueryTypeName]
            : undefined, mutation: newMutationTypeName
            ? typeMap[newMutationTypeName]
            : undefined, subscription: newSubscriptionTypeName != null
            ? typeMap[newSubscriptionTypeName]
            : undefined, types: Object.keys(typeMap).map(function (typeName) { return typeMap[typeName]; }), directives: directives }));
}
function getTypeSpecifiers(type, schema) {
    var specifiers = [MapperKind.TYPE];
    if (isObjectType$1(type)) {
        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);
        var query = schema.getQueryType();
        var mutation = schema.getMutationType();
        var subscription = schema.getSubscriptionType();
        if (type === query) {
            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);
        }
        else if (type === mutation) {
            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);
        }
        else if (type === subscription) {
            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);
        }
    }
    else if (isInputType(type)) {
        specifiers.push(MapperKind.INPUT_OBJECT_TYPE);
    }
    else if (isInterfaceType$1(type)) {
        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);
    }
    else if (isUnionType$1(type)) {
        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);
    }
    else if (isEnumType$1(type)) {
        specifiers.push(MapperKind.ENUM_TYPE);
    }
    else if (isScalarType$1(type)) {
        specifiers.push(MapperKind.SCALAR_TYPE);
    }
    return specifiers;
}
function getMapper(schema, schemaMapper, typeOrDirective) {
    if (isNamedType(typeOrDirective)) {
        var specifiers = getTypeSpecifiers(typeOrDirective, schema);
        var typeMapper = void 0;
        var stack = __spreadArrays(specifiers);
        while (!typeMapper && stack.length > 0) {
            var next = stack.pop();
            typeMapper = schemaMapper[next];
        }
        return typeMapper != null ? typeMapper : null;
    }
    else if (isDirective(typeOrDirective)) {
        var directiveMapper = schemaMapper[MapperKind.DIRECTIVE];
        return directiveMapper != null ? directiveMapper : null;
    }
}
function rewireTypes(originalTypeMap, directives) {
    var newTypeMap = Object.create(null);
    Object.keys(originalTypeMap).forEach(function (typeName) {
        var namedType = originalTypeMap[typeName];
        if (namedType == null || typeName.startsWith('__')) {
            return;
        }
        var newName = namedType.name;
        if (newName.startsWith('__')) {
            return;
        }
        if (newTypeMap[newName] != null) {
            throw new Error("Duplicate schema type name " + newName);
        }
        newTypeMap[newName] = namedType;
    });
    Object.keys(newTypeMap).forEach(function (typeName) {
        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
    });
    var newDirectives = directives.map(function (directive) {
        return rewireDirective(directive);
    });
    return pruneTypes(newTypeMap, newDirectives);
    function rewireDirective(directive) {
        var directiveConfig = toConfig(directive);
        directiveConfig.args = rewireArgs(directiveConfig.args);
        return new GraphQLDirective$1(directiveConfig);
    }
    function rewireArgs(args) {
        var rewiredArgs = {};
        Object.keys(args).forEach(function (argName) {
            var arg = args[argName];
            var rewiredArgType = rewireType(arg.type);
            if (rewiredArgType != null) {
                arg.type = rewiredArgType;
                rewiredArgs[argName] = arg;
            }
        });
        return rewiredArgs;
    }
    function rewireNamedType(type) {
        if (isObjectType$1(type)) {
            var config_1 = toConfig(type);
            var newConfig = __assign(__assign({}, config_1), { fields: function () { return rewireFields(config_1.fields); }, interfaces: function () { return rewireNamedTypes(config_1.interfaces); } });
            return new GraphQLObjectType$1(newConfig);
        }
        else if (isInterfaceType$1(type)) {
            var config_2 = toConfig(type);
            var newConfig = __assign(__assign({}, config_2), { fields: function () { return rewireFields(config_2.fields); } });
            if (graphqlVersion() >= 15) {
                newConfig.interfaces = function () {
                    return rewireNamedTypes(config_2
                        .interfaces);
                };
            }
            return new GraphQLInterfaceType$1(newConfig);
        }
        else if (isUnionType$1(type)) {
            var config_3 = toConfig(type);
            var newConfig = __assign(__assign({}, config_3), { types: function () { return rewireNamedTypes(config_3.types); } });
            return new GraphQLUnionType$1(newConfig);
        }
        else if (isInputObjectType$1(type)) {
            var config_4 = toConfig(type);
            var newConfig = __assign(__assign({}, config_4), { fields: function () { return rewireInputFields(config_4.fields); } });
            return new GraphQLInputObjectType$1(newConfig);
        }
        else if (isEnumType$1(type)) {
            var enumConfig = toConfig(type);
            return new GraphQLEnumType$1(enumConfig);
        }
        else if (isScalarType$1(type)) {
            if (isSpecifiedScalarType(type)) {
                return type;
            }
            var scalarConfig = toConfig(type);
            return new GraphQLScalarType$1(scalarConfig);
        }
        throw new Error("Unexpected schema type: " + type);
    }
    function rewireFields(fields) {
        var rewiredFields = {};
        Object.keys(fields).forEach(function (fieldName) {
            var field = fields[fieldName];
            var rewiredFieldType = rewireType(field.type);
            if (rewiredFieldType != null) {
                field.type = rewiredFieldType;
                field.args = rewireArgs(field.args);
                rewiredFields[fieldName] = field;
            }
        });
        return rewiredFields;
    }
    function rewireInputFields(fields) {
        var rewiredFields = {};
        Object.keys(fields).forEach(function (fieldName) {
            var field = fields[fieldName];
            var rewiredFieldType = rewireType(field.type);
            if (rewiredFieldType != null) {
                field.type = rewiredFieldType;
                rewiredFields[fieldName] = field;
            }
        });
        return rewiredFields;
    }
    function rewireNamedTypes(namedTypes) {
        var rewiredTypes = [];
        namedTypes.forEach(function (namedType) {
            var rewiredType = rewireType(namedType);
            if (rewiredType != null) {
                rewiredTypes.push(rewiredType);
            }
        });
        return rewiredTypes;
    }
    function rewireType(type) {
        if (isListType$1(type)) {
            var rewiredType = rewireType(type.ofType);
            return rewiredType != null ? new GraphQLList$1(rewiredType) : null;
        }
        else if (isNonNullType$1(type)) {
            var rewiredType = rewireType(type.ofType);
            return rewiredType != null
                ? new GraphQLNonNull$1(rewiredType)
                : null;
        }
        else if (isNamedType(type)) {
            var originalType = originalTypeMap[type.name];
            return originalType != null ? newTypeMap[originalType.name] : null;
        }
        return null;
    }
}
function pruneTypes(typeMap, directives) {
    var newTypeMap = {};
    var implementedInterfaces = {};
    Object.keys(typeMap).forEach(function (typeName) {
        var namedType = typeMap[typeName];
        if (isObjectType$1(namedType) ||
            (graphqlVersion() >= 15 && isInterfaceType$1(namedType))) {
            namedType.getInterfaces().forEach(function (iface) {
                implementedInterfaces[iface.name] = true;
            });
        }
    });
    var prunedTypeMap = false;
    var typeNames = Object.keys(typeMap);
    for (var i = 0; i < typeNames.length; i++) {
        var typeName = typeNames[i];
        var type = typeMap[typeName];
        if (isObjectType$1(type) || isInputObjectType$1(type)) {
            // prune types with no fields
            if (Object.keys(type.getFields()).length) {
                newTypeMap[typeName] = type;
            }
            else {
                prunedTypeMap = true;
            }
        }
        else if (isUnionType$1(type)) {
            // prune unions without underlying types
            if (type.getTypes().length) {
                newTypeMap[typeName] = type;
            }
            else {
                prunedTypeMap = true;
            }
        }
        else if (isInterfaceType$1(type)) {
            // prune interfaces without fields or without implementations
            if (Object.keys(type.getFields()).length &&
                implementedInterfaces[type.name]) {
                newTypeMap[typeName] = type;
            }
            else {
                prunedTypeMap = true;
            }
        }
        else {
            newTypeMap[typeName] = type;
        }
    }
    // every prune requires another round of healing
    return prunedTypeMap
        ? rewireTypes(newTypeMap, directives)
        : { typeMap: typeMap, directives: directives };
}

function filterSchema(_a) {
    var _b;
    var schema = _a.schema, _c = _a.rootFieldFilter, rootFieldFilter = _c === void 0 ? function () { return true; } : _c, _d = _a.typeFilter, typeFilter = _d === void 0 ? function () { return true; } : _d, _e = _a.fieldFilter, fieldFilter = _e === void 0 ? function () { return true; } : _e;
    var filteredSchema = mapSchema(schema, (_b = {},
        _b[MapperKind.QUERY] = function (type) {
            return filterRootFields(type, 'Query', rootFieldFilter);
        },
        _b[MapperKind.MUTATION] = function (type) {
            return filterRootFields(type, 'Mutation', rootFieldFilter);
        },
        _b[MapperKind.SUBSCRIPTION] = function (type) {
            return filterRootFields(type, 'Subscription', rootFieldFilter);
        },
        _b[MapperKind.OBJECT_TYPE] = function (type) {
            return typeFilter(type.name, type)
                ? filterObjectFields(type, fieldFilter)
                : null;
        },
        _b[MapperKind.INTERFACE_TYPE] = function (type) {
            return typeFilter(type.name, type) ? undefined : null;
        },
        _b[MapperKind.UNION_TYPE] = function (type) {
            return typeFilter(type.name, type) ? undefined : null;
        },
        _b[MapperKind.INPUT_OBJECT_TYPE] = function (type) {
            return typeFilter(type.name, type) ? undefined : null;
        },
        _b[MapperKind.ENUM_TYPE] = function (type) {
            return typeFilter(type.name, type) ? undefined : null;
        },
        _b[MapperKind.SCALAR_TYPE] = function (type) {
            return typeFilter(type.name, type) ? undefined : null;
        },
        _b));
    filteredSchema.transforms = schema.transforms;
    return filteredSchema;
}
function filterRootFields(type, operation, rootFieldFilter) {
    var config = toConfig(type);
    Object.keys(config.fields).forEach(function (fieldName) {
        if (!rootFieldFilter(operation, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
        }
    });
    return new GraphQLObjectType$1(config);
}
function filterObjectFields(type, fieldFilter) {
    var config = toConfig(type);
    Object.keys(config.fields).forEach(function (fieldName) {
        if (!fieldFilter(type.name, fieldName, config.fields[fieldName])) {
            delete config.fields[fieldName];
        }
    });
    return new GraphQLObjectType$1(config);
}

function cloneDirective(directive) {
    return new GraphQLDirective$1(toConfig(directive));
}
function cloneType(type) {
    if (isObjectType$1(type)) {
        var config = toConfig(type);
        return new GraphQLObjectType$1(__assign(__assign({}, config), { interfaces: typeof config.interfaces === 'function'
                ? config.interfaces
                : config.interfaces.slice() }));
    }
    else if (isInterfaceType$1(type)) {
        var config = toConfig(type);
        var newConfig = __assign(__assign({}, config), { interfaces: graphqlVersion() >= 15
                ? typeof config
                    .interfaces === 'function'
                    ? config
                        .interfaces
                    : config.interfaces.slice()
                : undefined });
        return new GraphQLInterfaceType$1(newConfig);
    }
    else if (isUnionType$1(type)) {
        var config = toConfig(type);
        return new GraphQLUnionType$1(__assign(__assign({}, config), { types: config.types.slice() }));
    }
    else if (isInputObjectType$1(type)) {
        return new GraphQLInputObjectType$1(toConfig(type));
    }
    else if (isEnumType$1(type)) {
        return new GraphQLEnumType$1(toConfig(type));
    }
    else if (isScalarType$1(type)) {
        return isSpecifiedScalarType(type)
            ? type
            : new GraphQLScalarType$1(toConfig(type));
    }
    throw new Error("Invalid type " + type);
}
function cloneSchema(schema) {
    return mapSchema(schema);
}

// polyfill for graphql prior to v13 which do not pass options to buildASTSchema
function buildSchema(ast, buildSchemaOptions) {
    return buildASTSchema(parse(ast), buildSchemaOptions);
}

function getResolversFromSchema(schema) {
    var resolvers = Object.create({});
    var typeMap = schema.getTypeMap();
    Object.keys(typeMap).forEach(function (typeName) {
        var type = typeMap[typeName];
        if (isScalarType$1(type)) {
            if (!isSpecifiedScalarType(type)) {
                resolvers[typeName] = cloneType(type);
            }
        }
        else if (isEnumType$1(type)) {
            resolvers[typeName] = {};
            var values = type.getValues();
            values.forEach(function (value) {
                resolvers[typeName][value.name] = value.value;
            });
        }
        else if (isInterfaceType$1(type)) {
            if (type.resolveType != null) {
                resolvers[typeName] = {
                    __resolveType: type.resolveType,
                };
            }
        }
        else if (isUnionType$1(type)) {
            if (type.resolveType != null) {
                resolvers[typeName] = {
                    __resolveType: type.resolveType,
                };
            }
        }
        else if (isObjectType$1(type)) {
            resolvers[typeName] = {};
            if (type.isTypeOf != null) {
                resolvers[typeName].__isTypeOf = type.isTypeOf;
            }
            var fields_1 = type.getFields();
            Object.keys(fields_1).forEach(function (fieldName) {
                var field = fields_1[fieldName];
                resolvers[typeName][fieldName] = {
                    resolve: field.resolve,
                    subscribe: field.subscribe,
                };
            });
        }
    });
    return resolvers;
}

// polyfill for graphql < v14.2 which does not support subscriptions
function extendSchema(schema, extension, options) {
    var subscriptionType = schema.getSubscriptionType();
    if (subscriptionType == null) {
        return extendSchema$1(schema, extension, options);
    }
    var resolvers = getResolversFromSchema(schema);
    var subscriptionTypeName = subscriptionType.name;
    var subscriptionResolvers = resolvers[subscriptionTypeName];
    var extendedSchema = extendSchema$1(schema, extension, options);
    var fields = extendedSchema.getSubscriptionType().getFields();
    Object.keys(subscriptionResolvers).forEach(function (fieldName) {
        fields[fieldName].subscribe = subscriptionResolvers[fieldName].subscribe;
    });
    return extendedSchema;
}

function each(arrayOrObject, callback) {
    Object.keys(arrayOrObject).forEach(function (key) {
        callback(arrayOrObject[key], key);
    });
}

// A more powerful version of each that has the ability to replace or remove
// array or object keys.
function updateEachKey(arrayOrObject, 
// The callback can return nothing to leave the key untouched, null to remove
// the key from the array or object, or a non-null V to replace the value.
updater) {
    var deletedCount = 0;
    Object.keys(arrayOrObject).forEach(function (key) {
        var result = updater(arrayOrObject[key], key);
        if (typeof result === 'undefined') {
            return;
        }
        if (result === null) {
            delete arrayOrObject[key];
            deletedCount++;
            return;
        }
        arrayOrObject[key] = result;
    });
    if (deletedCount > 0 && Array.isArray(arrayOrObject)) {
        // Remove any holes from the array due to deleted elements.
        arrayOrObject.splice(0).forEach(function (elem) {
            arrayOrObject.push(elem);
        });
    }
}

function createNamedStub(name, type) {
    var constructor;
    if (type === 'object') {
        constructor = GraphQLObjectType$1;
    }
    else if (type === 'interface') {
        constructor = GraphQLInterfaceType$1;
    }
    else {
        constructor = GraphQLInputObjectType$1;
    }
    return new constructor({
        name: name,
        fields: {
            __fake: {
                type: GraphQLString$1,
            },
        },
    });
}
function isStub(type) {
    if (isObjectType$1(type) || isInterfaceType$1(type) || isInputObjectType$1(type)) {
        var fields = type.getFields();
        var fieldNames = Object.keys(fields);
        return fieldNames.length === 1 && fields[fieldNames[0]].name === '__fake';
    }
    return false;
}
function getBuiltInForStub(type) {
    switch (type.name) {
        case GraphQLInt$1.name:
            return GraphQLInt$1;
        case GraphQLFloat$1.name:
            return GraphQLFloat$1;
        case GraphQLString$1.name:
            return GraphQLString$1;
        case GraphQLBoolean$1.name:
            return GraphQLBoolean$1;
        case GraphQLID$1.name:
            return GraphQLID$1;
        default:
            return type;
    }
}

var hasOwn$1 = Object.prototype.hasOwnProperty;
// Update any references to named schema types that disagree with the named
// types found in schema.getTypeMap().
function healSchema(schema) {
    var typeMap = schema.getTypeMap();
    var directives = schema.getDirectives();
    var queryType = schema.getQueryType();
    var mutationType = schema.getMutationType();
    var subscriptionType = schema.getSubscriptionType();
    var newQueryTypeName = queryType != null
        ? typeMap[queryType.name] != null
            ? typeMap[queryType.name].name
            : undefined
        : undefined;
    var newMutationTypeName = mutationType != null
        ? typeMap[mutationType.name] != null
            ? typeMap[mutationType.name].name
            : undefined
        : undefined;
    var newSubscriptionTypeName = subscriptionType != null
        ? typeMap[subscriptionType.name] != null
            ? typeMap[subscriptionType.name].name
            : undefined
        : undefined;
    healTypes(typeMap, directives);
    var filteredTypeMap = {};
    Object.keys(typeMap).forEach(function (typeName) {
        if (!typeName.startsWith('__')) {
            filteredTypeMap[typeName] = typeMap[typeName];
        }
    });
    var healedSchema = new GraphQLSchema(__assign(__assign({}, toConfig(schema)), { query: newQueryTypeName ? filteredTypeMap[newQueryTypeName] : undefined, mutation: newMutationTypeName
            ? filteredTypeMap[newMutationTypeName]
            : undefined, subscription: newSubscriptionTypeName
            ? filteredTypeMap[newSubscriptionTypeName]
            : undefined, types: Object.keys(filteredTypeMap).map(function (typeName) { return filteredTypeMap[typeName]; }), directives: directives.slice() }));
    // Reconstruct the schema to reinitialize private variables
    // e.g. the stored implementation map and the proper root types.
    Object.assign(schema, healedSchema);
    return schema;
}
function healTypes(originalTypeMap, directives, config) {
    if (config === void 0) { config = {
        skipPruning: false,
    }; }
    var actualNamedTypeMap = Object.create(null);
    // If any of the .name properties of the GraphQLNamedType objects in
    // schema.getTypeMap() have changed, the keys of the type map need to
    // be updated accordingly.
    each(originalTypeMap, function (namedType, typeName) {
        if (namedType == null || typeName.startsWith('__')) {
            return;
        }
        var actualName = namedType.name;
        if (actualName.startsWith('__')) {
            return;
        }
        if (hasOwn$1.call(actualNamedTypeMap, actualName)) {
            throw new Error("Duplicate schema type name " + actualName);
        }
        actualNamedTypeMap[actualName] = namedType;
        // Note: we are deliberately leaving namedType in the schema by its
        // original name (which might be different from actualName), so that
        // references by that name can be healed.
    });
    // Now add back every named type by its actual name.
    each(actualNamedTypeMap, function (namedType, typeName) {
        originalTypeMap[typeName] = namedType;
    });
    // Directive declaration argument types can refer to named types.
    each(directives, function (decl) {
        updateEachKey(decl.args, function (arg) {
            arg.type = healType(arg.type);
            return arg.type === null ? null : arg;
        });
    });
    each(originalTypeMap, function (namedType, typeName) {
        // Heal all named types, except for dangling references, kept only to redirect.
        if (!typeName.startsWith('__') &&
            hasOwn$1.call(actualNamedTypeMap, typeName)) {
            if (namedType != null) {
                healNamedType(namedType);
            }
        }
    });
    updateEachKey(originalTypeMap, function (_namedType, typeName) {
        // Dangling references to renamed types should remain in the schema
        // during healing, but must be removed now, so that the following
        // invariant holds for all names: schema.getType(name).name === name
        if (!typeName.startsWith('__') &&
            !hasOwn$1.call(actualNamedTypeMap, typeName)) {
            return null;
        }
    });
    if (!config.skipPruning) {
        pruneTypes$1(originalTypeMap, directives);
    }
    function healNamedType(type) {
        if (isObjectType$1(type)) {
            healFields(type);
            healInterfaces(type);
            return;
        }
        else if (isInterfaceType$1(type)) {
            healFields(type);
            if (graphqlVersion() >= 15) {
                healInterfaces(type);
            }
            return;
        }
        else if (isUnionType$1(type)) {
            healUnderlyingTypes(type);
            return;
        }
        else if (isInputObjectType$1(type)) {
            healInputFields(type);
            return;
        }
        else if (isLeafType(type)) {
            return;
        }
        throw new Error("Unexpected schema type: " + type);
    }
    function healFields(type) {
        updateEachKey(type.getFields(), function (field) {
            updateEachKey(field.args, function (arg) {
                arg.type = healType(arg.type);
                return arg.type === null ? null : arg;
            });
            field.type = healType(field.type);
            return field.type === null ? null : field;
        });
    }
    function healInterfaces(type) {
        updateEachKey(type.getInterfaces(), function (iface) {
            var healedType = healType(iface);
            return healedType;
        });
    }
    function healInputFields(type) {
        updateEachKey(type.getFields(), function (field) {
            field.type = healType(field.type);
            return field.type === null ? null : field;
        });
    }
    function healUnderlyingTypes(type) {
        updateEachKey(type.getTypes(), function (t) {
            var healedType = healType(t);
            return healedType;
        });
    }
    function healType(type) {
        // Unwrap the two known wrapper types
        if (isListType$1(type)) {
            var healedType = healType(type.ofType);
            return healedType != null ? new GraphQLList$1(healedType) : null;
        }
        else if (isNonNullType$1(type)) {
            var healedType = healType(type.ofType);
            return healedType != null ? new GraphQLNonNull$1(healedType) : null;
        }
        else if (isNamedType(type)) {
            // If a type annotation on a field or an argument or a union member is
            // any `GraphQLNamedType` with a `name`, then it must end up identical
            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source
            // of truth for all named schema types.
            // Note that new types can still be simply added by adding a field, as
            // the official type will be undefined, not null.
            var officialType = originalTypeMap[type.name];
            if (officialType === undefined) {
                if (isStub(type)) {
                    officialType = getBuiltInForStub(type);
                }
                else {
                    officialType = type;
                }
                originalTypeMap[type.name] = officialType;
            }
            return officialType;
        }
        return null;
    }
}
function pruneTypes$1(typeMap, directives) {
    var implementedInterfaces = {};
    each(typeMap, function (namedType) {
        if (isObjectType$1(namedType) ||
            (graphqlVersion() >= 15 && isInterfaceType$1(namedType))) {
            each(namedType.getInterfaces(), function (iface) {
                implementedInterfaces[iface.name] = true;
            });
        }
    });
    var prunedTypeMap = false;
    var typeNames = Object.keys(typeMap);
    for (var i = 0; i < typeNames.length; i++) {
        var typeName = typeNames[i];
        var type = typeMap[typeName];
        if (isObjectType$1(type) || isInputObjectType$1(type)) {
            // prune types with no fields
            if (!Object.keys(type.getFields()).length) {
                typeMap[typeName] = null;
                prunedTypeMap = true;
            }
        }
        else if (isUnionType$1(type)) {
            // prune unions without underlying types
            if (!type.getTypes().length) {
                typeMap[typeName] = null;
                prunedTypeMap = true;
            }
        }
        else if (isInterfaceType$1(type)) {
            // prune interfaces without fields or without implementations
            if (!Object.keys(type.getFields()).length ||
                !implementedInterfaces[type.name]) {
                typeMap[typeName] = null;
                prunedTypeMap = true;
            }
        }
    }
    // every prune requires another round of healing
    if (prunedTypeMap) {
        healTypes(typeMap, directives);
    }
}

// Abstract base class of any visitor implementation, defining the available
// visitor methods along with their parameter types, and providing a static
// helper function for determining whether a subclass implements a given
// visitor method, as opposed to inheriting one of the stubs defined here.
var SchemaVisitor = /** @class */ (function () {
    function SchemaVisitor() {
    }
    // Determine if this SchemaVisitor (sub)class implements a particular
    // visitor method.
    SchemaVisitor.implementsVisitorMethod = function (methodName) {
        if (!methodName.startsWith('visit')) {
            return false;
        }
        var method = this.prototype[methodName];
        if (typeof method !== 'function') {
            return false;
        }
        if (this === SchemaVisitor) {
            // The SchemaVisitor class implements every visitor method.
            return true;
        }
        var stub = SchemaVisitor.prototype[methodName];
        if (method === stub) {
            // If this.prototype[methodName] was just inherited from SchemaVisitor,
            // then this class does not really implement the method.
            return false;
        }
        return true;
    };
    // Concrete subclasses of SchemaVisitor should override one or more of these
    // visitor methods, in order to express their interest in handling certain
    // schema types/locations. Each method may return null to remove the given
    // type from the schema, a non-null value of the same type to update the
    // type in the schema, or nothing to leave the type as it was.
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    SchemaVisitor.prototype.visitSchema = function (_schema) { };
    SchemaVisitor.prototype.visitScalar = function (_scalar) { };
    SchemaVisitor.prototype.visitObject = function (_object) { };
    SchemaVisitor.prototype.visitFieldDefinition = function (_field, _details) { };
    SchemaVisitor.prototype.visitArgumentDefinition = function (_argument, _details) { };
    SchemaVisitor.prototype.visitInterface = function (_iface) { };
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    SchemaVisitor.prototype.visitUnion = function (_union) { };
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    SchemaVisitor.prototype.visitEnum = function (_type) { };
    SchemaVisitor.prototype.visitEnumValue = function (_value, _details) { };
    SchemaVisitor.prototype.visitInputObject = function (_object) { };
    SchemaVisitor.prototype.visitInputFieldDefinition = function (_field, _details) { };
    return SchemaVisitor;
}());

// Similar to the graphql-js function of the same name, slightly simplified:
// https://github.com/graphql/graphql-js/blob/master/src/utilities/valueFromASTUntyped.js
function valueFromASTUntyped$1(valueNode) {
    switch (valueNode.kind) {
        case Kind$1.NULL:
            return null;
        case Kind$1.INT:
            return parseInt(valueNode.value, 10);
        case Kind$1.FLOAT:
            return parseFloat(valueNode.value);
        case Kind$1.STRING:
        case Kind$1.ENUM:
        case Kind$1.BOOLEAN:
            return valueNode.value;
        case Kind$1.LIST:
            return valueNode.values.map(valueFromASTUntyped$1);
        case Kind$1.OBJECT: {
            var obj_1 = Object.create(null);
            valueNode.fields.forEach(function (field) {
                obj_1[field.name.value] = valueFromASTUntyped$1(field.value);
            });
            return obj_1;
        }
        /* istanbul ignore next */
        default:
            throw new Error('Unexpected value kind: ' + valueNode.kind);
    }
}

// Generic function for visiting GraphQLSchema objects.
function visitSchema(schema, 
// To accommodate as many different visitor patterns as possible, the
// visitSchema function does not simply accept a single instance of the
// SchemaVisitor class, but instead accepts a function that takes the
// current VisitableSchemaType object and the name of a visitor method and
// returns an array of SchemaVisitor instances that implement the visitor
// method and have an interest in handling the given VisitableSchemaType
// object. In the simplest case, this function can always return an array
// containing a single visitor object, without even looking at the type or
// methodName parameters. In other cases, this function might sometimes
// return an empty array to indicate there are no visitors that should be
// applied to the given VisitableSchemaType object. For an example of a
// visitor pattern that benefits from this abstraction, see the
// SchemaDirectiveVisitor class below.
visitorOrVisitorSelector) {
    var visitorSelector = typeof visitorOrVisitorSelector === 'function'
        ? visitorOrVisitorSelector
        : function () { return visitorOrVisitorSelector; };
    // Helper function that calls visitorSelector and applies the resulting
    // visitors to the given type, with arguments [type, ...args].
    function callMethod(methodName, type) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var visitors = visitorSelector(type, methodName);
        visitors = Array.isArray(visitors) ? visitors : [visitors];
        var finalType = type;
        visitors.every(function (visitorOrVisitorDef) {
            var newType;
            if (visitorOrVisitorDef instanceof SchemaVisitor) {
                newType = visitorOrVisitorDef[methodName].apply(visitorOrVisitorDef, __spreadArrays([finalType], args));
            }
            else if (isNamedType(finalType) &&
                (methodName === 'visitScalar' ||
                    methodName === 'visitEnum' ||
                    methodName === 'visitObject' ||
                    methodName === 'visitInputObject' ||
                    methodName === 'visitUnion' ||
                    methodName === 'visitInterface')) {
                var specifiers = getTypeSpecifiers$1(finalType, schema);
                var typeVisitor = getVisitor(visitorOrVisitorDef, specifiers);
                newType =
                    typeVisitor != null ? typeVisitor(finalType, schema) : undefined;
            }
            if (typeof newType === 'undefined') {
                // Keep going without modifying type.
                return true;
            }
            if (methodName === 'visitSchema' || isSchema(finalType)) {
                throw new Error("Method " + methodName + " cannot replace schema with " + newType);
            }
            if (newType === null) {
                // Stop the loop and return null form callMethod, which will cause
                // the type to be removed from the schema.
                finalType = null;
                return false;
            }
            // Update type to the new type returned by the visitor method, so that
            // later directives will see the new type, and callMethod will return
            // the final type.
            finalType = newType;
            return true;
        });
        // If there were no directives for this type object, or if all visitor
        // methods returned nothing, type will be returned unmodified.
        return finalType;
    }
    // Recursive helper function that calls any appropriate visitor methods for
    // each object in the schema, then traverses the object's children (if any).
    function visit(type) {
        if (isSchema(type)) {
            // Unlike the other types, the root GraphQLSchema object cannot be
            // replaced by visitor methods, because that would make life very hard
            // for SchemaVisitor subclasses that rely on the original schema object.
            callMethod('visitSchema', type);
            var typeMap_1 = type.getTypeMap();
            each(typeMap_1, function (namedType, typeName) {
                if (!typeName.startsWith('__') && namedType != null) {
                    // Call visit recursively to let it determine which concrete
                    // subclass of GraphQLNamedType we found in the type map.
                    // We do not use updateEachKey because we want to preserve
                    // deleted types in the typeMap so that other types that reference
                    // the deleted types can be healed.
                    typeMap_1[typeName] = visit(namedType);
                }
            });
            return type;
        }
        if (isObjectType$1(type)) {
            // Note that callMethod('visitObject', type) may not actually call any
            // methods, if there are no @directive annotations associated with this
            // type, or if this SchemaDirectiveVisitor subclass does not override
            // the visitObject method.
            var newObject = callMethod('visitObject', type);
            if (newObject != null) {
                visitFields(newObject);
            }
            return newObject;
        }
        if (isInterfaceType$1(type)) {
            var newInterface = callMethod('visitInterface', type);
            if (newInterface != null) {
                visitFields(newInterface);
            }
            return newInterface;
        }
        if (isInputObjectType$1(type)) {
            var newInputObject_1 = callMethod('visitInputObject', type);
            if (newInputObject_1 != null) {
                var fieldMap = newInputObject_1.getFields();
                updateEachKey(fieldMap, function (field) {
                    return callMethod('visitInputFieldDefinition', field, {
                        // Since we call a different method for input object fields, we
                        // can't reuse the visitFields function here.
                        objectType: newInputObject_1,
                    });
                });
            }
            return newInputObject_1;
        }
        if (isScalarType$1(type)) {
            return callMethod('visitScalar', type);
        }
        if (isUnionType$1(type)) {
            return callMethod('visitUnion', type);
        }
        if (isEnumType$1(type)) {
            var newEnum_1 = callMethod('visitEnum', type);
            if (newEnum_1 != null) {
                updateEachKey(newEnum_1.getValues(), function (value) {
                    return callMethod('visitEnumValue', value, {
                        enumType: newEnum_1,
                    });
                });
            }
            return newEnum_1;
        }
        throw new Error("Unexpected schema type: " + type);
    }
    function visitFields(type) {
        updateEachKey(type.getFields(), function (field) {
            // It would be nice if we could call visit(field) recursively here, but
            // GraphQLField is merely a type, not a value that can be detected using
            // an instanceof check, so we have to visit the fields in this lexical
            // context, so that TypeScript can validate the call to
            // visitFieldDefinition.
            var newField = callMethod('visitFieldDefinition', field, {
                // While any field visitor needs a reference to the field object, some
                // field visitors may also need to know the enclosing (parent) type,
                // perhaps to determine if the parent is a GraphQLObjectType or a
                // GraphQLInterfaceType. To obtain a reference to the parent, a
                // visitor method can have a second parameter, which will be an object
                // with an .objectType property referring to the parent.
                objectType: type,
            });
            if (newField.args != null) {
                updateEachKey(newField.args, function (arg) {
                    return callMethod('visitArgumentDefinition', arg, {
                        // Like visitFieldDefinition, visitArgumentDefinition takes a
                        // second parameter that provides additional context, namely the
                        // parent .field and grandparent .objectType. Remember that the
                        // current GraphQLSchema is always available via this.schema.
                        field: newField,
                        objectType: type,
                    });
                });
            }
            return newField;
        });
    }
    visit(schema);
    // Automatically update any references to named schema types replaced
    // during the traversal, so implementors don't have to worry about that.
    healSchema(schema);
    // Return schema for convenience, even though schema parameter has all updated types.
    return schema;
}
function getTypeSpecifiers$1(type, schema) {
    var specifiers = [VisitSchemaKind.TYPE];
    if (isObjectType$1(type)) {
        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.OBJECT_TYPE);
        var query = schema.getQueryType();
        var mutation = schema.getMutationType();
        var subscription = schema.getSubscriptionType();
        if (type === query) {
            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.QUERY);
        }
        else if (type === mutation) {
            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.MUTATION);
        }
        else if (type === subscription) {
            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.SUBSCRIPTION);
        }
    }
    else if (isInputType(type)) {
        specifiers.push(VisitSchemaKind.INPUT_OBJECT_TYPE);
    }
    else if (isInterfaceType$1(type)) {
        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.INTERFACE_TYPE);
    }
    else if (isUnionType$1(type)) {
        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.UNION_TYPE);
    }
    else if (isEnumType$1(type)) {
        specifiers.push(VisitSchemaKind.ENUM_TYPE);
    }
    else if (isScalarType$1(type)) {
        specifiers.push(VisitSchemaKind.SCALAR_TYPE);
    }
    return specifiers;
}
function getVisitor(visitorDef, specifiers) {
    var typeVisitor;
    var stack = __spreadArrays(specifiers);
    while (!typeVisitor && stack.length > 0) {
        var next = stack.pop();
        typeVisitor = visitorDef[next];
    }
    return typeVisitor != null ? typeVisitor : null;
}

var hasOwn$2 = Object.prototype.hasOwnProperty;
// This class represents a reusable implementation of a @directive that may
// appear in a GraphQL schema written in Schema Definition Language.
//
// By overriding one or more visit{Object,Union,...} methods, a subclass
// registers interest in certain schema types, such as GraphQLObjectType,
// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is
// called with a GraphQLSchema object and a map of visitor subclasses, the
// overidden methods of those subclasses allow the visitors to obtain
// references to any type objects that have @directives attached to them,
// enabling visitors to inspect or modify the schema as appropriate.
//
// For example, if a directive called @rest(url: "...") appears after a field
// definition, a SchemaDirectiveVisitor subclass could provide meaning to that
// directive by overriding the visitFieldDefinition method (which receives a
// GraphQLField parameter), and then the body of that visitor method could
// manipulate the field's resolver function to fetch data from a REST endpoint
// described by the url argument passed to the @rest directive:
//
//   const typeDefs = `
//   type Query {
//     people: [Person] @rest(url: "/api/v1/people")
//   }`;
//
//   const schema = makeExecutableSchema({ typeDefs });
//
//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {
//     rest: class extends SchemaDirectiveVisitor {
//       public visitFieldDefinition(field: GraphQLField<any, any>) {
//         const { url } = this.args;
//         field.resolve = () => fetch(url);
//       }
//     }
//   });
//
// The subclass in this example is defined as an anonymous class expression,
// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be
// defined in a library using a named class declaration, and then exported for
// consumption by other modules and packages.
//
// See below for a complete list of overridable visitor methods, their
// parameter types, and more details about the properties exposed by instances
// of the SchemaDirectiveVisitor class.
var SchemaDirectiveVisitor = /** @class */ (function (_super) {
    __extends(SchemaDirectiveVisitor, _super);
    // Mark the constructor protected to enforce passing SchemaDirectiveVisitor
    // subclasses (not instances) to visitSchemaDirectives.
    function SchemaDirectiveVisitor(config) {
        var _this = _super.call(this) || this;
        _this.name = config.name;
        _this.args = config.args;
        _this.visitedType = config.visitedType;
        _this.schema = config.schema;
        _this.context = config.context;
        return _this;
    }
    // Override this method to return a custom GraphQLDirective (or modify one
    // already present in the schema) to enforce argument types, provide default
    // argument values, or specify schema locations where this @directive may
    // appear. By default, any declaration found in the schema will be returned.
    SchemaDirectiveVisitor.getDirectiveDeclaration = function (directiveName, schema) {
        return schema.getDirective(directiveName);
    };
    // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every
    // @directive in the schema and create an appropriate SchemaDirectiveVisitor
    // instance to visit the object decorated by the @directive.
    SchemaDirectiveVisitor.visitSchemaDirectives = function (schema, directiveVisitors, 
    // Optional context object that will be available to all visitor instances
    // via this.context. Defaults to an empty null-prototype object.
    context) {
        if (context === void 0) { context = Object.create(null); }
        // If the schema declares any directives for public consumption, record
        // them here so that we can properly coerce arguments when/if we encounter
        // an occurrence of the directive while walking the schema below.
        var declaredDirectives = this.getDeclaredDirectives(schema, directiveVisitors);
        // Map from directive names to lists of SchemaDirectiveVisitor instances
        // created while visiting the schema.
        var createdVisitors = Object.create(null);
        Object.keys(directiveVisitors).forEach(function (directiveName) {
            createdVisitors[directiveName] = [];
        });
        function visitorSelector(type, methodName) {
            var directiveNodes = type.astNode != null ? type.astNode.directives : [];
            var extensionASTNodes = type.extensionASTNodes;
            if (extensionASTNodes != null) {
                extensionASTNodes.forEach(function (extensionASTNode) {
                    directiveNodes = directiveNodes.concat(extensionASTNode.directives);
                });
            }
            var visitors = [];
            directiveNodes.forEach(function (directiveNode) {
                var directiveName = directiveNode.name.value;
                if (!hasOwn$2.call(directiveVisitors, directiveName)) {
                    return;
                }
                var visitorClass = directiveVisitors[directiveName];
                // Avoid creating visitor objects if visitorClass does not override
                // the visitor method named by methodName.
                if (!visitorClass.implementsVisitorMethod(methodName)) {
                    return;
                }
                var decl = declaredDirectives[directiveName];
                var args;
                if (decl != null) {
                    // If this directive was explicitly declared, use the declared
                    // argument types (and any default values) to check, coerce, and/or
                    // supply default values for the given arguments.
                    args = getArgumentValues(decl, directiveNode);
                }
                else {
                    // If this directive was not explicitly declared, just convert the
                    // argument nodes to their corresponding JavaScript values.
                    args = Object.create(null);
                    if (directiveNode.arguments != null) {
                        directiveNode.arguments.forEach(function (arg) {
                            args[arg.name.value] = valueFromASTUntyped$1(arg.value);
                        });
                    }
                }
                // As foretold in comments near the top of the visitSchemaDirectives
                // method, this is where instances of the SchemaDirectiveVisitor class
                // get created and assigned names. While subclasses could override the
                // constructor method, the constructor is marked as protected, so
                // these are the only arguments that will ever be passed.
                visitors.push(new visitorClass({
                    name: directiveName,
                    args: args,
                    visitedType: type,
                    schema: schema,
                    context: context,
                }));
            });
            if (visitors.length > 0) {
                visitors.forEach(function (visitor) {
                    createdVisitors[visitor.name].push(visitor);
                });
            }
            return visitors;
        }
        visitSchema(schema, visitorSelector);
        return createdVisitors;
    };
    SchemaDirectiveVisitor.getDeclaredDirectives = function (schema, directiveVisitors) {
        var declaredDirectives = Object.create(null);
        each(schema.getDirectives(), function (decl) {
            declaredDirectives[decl.name] = decl;
        });
        // If the visitor subclass overrides getDirectiveDeclaration, and it
        // returns a non-null GraphQLDirective, use that instead of any directive
        // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor
        // goes to the trouble of implementing getDirectiveDeclaration, it should
        // be able to rely on that implementation.
        each(directiveVisitors, function (visitorClass, directiveName) {
            var decl = visitorClass.getDirectiveDeclaration(directiveName, schema);
            if (decl != null) {
                declaredDirectives[directiveName] = decl;
            }
        });
        each(declaredDirectives, function (decl, name) {
            if (!hasOwn$2.call(directiveVisitors, name)) {
                // SchemaDirectiveVisitors.visitSchemaDirectives might be called
                // multiple times with partial directiveVisitors maps, so it's not
                // necessarily an error for directiveVisitors to be missing an
                // implementation of a directive that was declared in the schema.
                return;
            }
            var visitorClass = directiveVisitors[name];
            each(decl.locations, function (loc) {
                var visitorMethodName = directiveLocationToVisitorMethodName(loc);
                if (SchemaVisitor.implementsVisitorMethod(visitorMethodName) &&
                    !visitorClass.implementsVisitorMethod(visitorMethodName)) {
                    // While visitor subclasses may implement extra visitor methods,
                    // it's definitely a mistake if the GraphQLDirective declares itself
                    // applicable to certain schema locations, and the visitor subclass
                    // does not implement all the corresponding methods.
                    throw new Error("SchemaDirectiveVisitor for @" + name + " must implement " + visitorMethodName + " method");
                }
            });
        });
        return declaredDirectives;
    };
    return SchemaDirectiveVisitor;
}(SchemaVisitor));
// Convert a string like "FIELD_DEFINITION" to "visitFieldDefinition".
function directiveLocationToVisitorMethodName(loc) {
    return ('visit' +
        loc.replace(/([^_]*)_?/g, function (_wholeMatch, part) {
            return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
        }));
}

function forEachField(schema, fn) {
    var typeMap = schema.getTypeMap();
    Object.keys(typeMap).forEach(function (typeName) {
        var type = typeMap[typeName];
        // TODO: maybe have an option to include these?
        if (!getNamedType(type).name.startsWith('__') && isObjectType$1(type)) {
            var fields_1 = type.getFields();
            Object.keys(fields_1).forEach(function (fieldName) {
                var field = fields_1[fieldName];
                fn(field, typeName, fieldName);
            });
        }
    });
}

function forEachDefaultValue(schema, fn) {
    var typeMap = schema.getTypeMap();
    Object.keys(typeMap).forEach(function (typeName) {
        var type = typeMap[typeName];
        if (!getNamedType(type).name.startsWith('__')) {
            if (isObjectType$1(type)) {
                var fields_1 = type.getFields();
                Object.keys(fields_1).forEach(function (fieldName) {
                    var field = fields_1[fieldName];
                    field.args.forEach(function (arg) {
                        arg.defaultValue = fn(arg.type, arg.defaultValue);
                    });
                });
            }
            else if (isInputObjectType$1(type)) {
                var fields_2 = type.getFields();
                Object.keys(fields_2).forEach(function (fieldName) {
                    var field = fields_2[fieldName];
                    field.defaultValue = fn(field.type, field.defaultValue);
                });
            }
        }
    });
}

function transformInputValue(type, value, transformer) {
    if (value == null) {
        return value;
    }
    var nullableType = getNullableType(type);
    if (isLeafType(nullableType)) {
        return transformer(nullableType, value);
    }
    else if (isListType$1(nullableType)) {
        return value.map(function (listMember) {
            return transformInputValue(nullableType.ofType, listMember, transformer);
        });
    }
    else if (isInputObjectType$1(nullableType)) {
        var fields_1 = nullableType.getFields();
        var newValue_1 = {};
        Object.keys(value).forEach(function (key) {
            newValue_1[key] = transformInputValue(fields_1[key].type, value[key], transformer);
        });
        return newValue_1;
    }
    // unreachable, no other possible return value
}
function serializeInputValue(type, value) {
    return transformInputValue(type, value, function (t, v) { return t.serialize(v); });
}
function parseInputValue(type, value) {
    return transformInputValue(type, value, function (t, v) { return t.parseValue(v); });
}
function parseInputValueLiteral(type, value) {
    return transformInputValue(type, value, function (t, v) { return t.parseLiteral(v, {}); });
}

function concatInlineFragments(type, fragments) {
    var fragmentSelections = fragments.reduce(function (selections, fragment) {
        return selections.concat(fragment.selectionSet.selections);
    }, []);
    var deduplicatedFragmentSelection = deduplicateSelection(fragmentSelections);
    return {
        kind: Kind$1.INLINE_FRAGMENT,
        typeCondition: {
            kind: Kind$1.NAMED_TYPE,
            name: {
                kind: Kind$1.NAME,
                value: type,
            },
        },
        selectionSet: {
            kind: Kind$1.SELECTION_SET,
            selections: deduplicatedFragmentSelection,
        },
    };
}
var hasOwn$3 = Object.prototype.hasOwnProperty;
function deduplicateSelection(nodes) {
    var selectionMap = nodes.reduce(function (map, node) {
        var _a, _b, _c;
        switch (node.kind) {
            case 'Field': {
                if (node.alias != null) {
                    if (hasOwn$3.call(map, node.alias.value)) {
                        return map;
                    }
                    return __assign(__assign({}, map), (_a = {}, _a[node.alias.value] = node, _a));
                }
                if (hasOwn$3.call(map, node.name.value)) {
                    return map;
                }
                return __assign(__assign({}, map), (_b = {}, _b[node.name.value] = node, _b));
            }
            case 'FragmentSpread': {
                if (hasOwn$3.call(map, node.name.value)) {
                    return map;
                }
                return __assign(__assign({}, map), (_c = {}, _c[node.name.value] = node, _c));
            }
            case 'InlineFragment': {
                if (map.__fragment != null) {
                    var fragment = map.__fragment;
                    return __assign(__assign({}, map), { __fragment: concatInlineFragments(fragment.typeCondition.name.value, [fragment, node]) });
                }
                return __assign(__assign({}, map), { __fragment: node });
            }
            default: {
                return map;
            }
        }
    }, {});
    var selection = Object.keys(selectionMap).reduce(function (selectionList, node) { return selectionList.concat(selectionMap[node]); }, []);
    return selection;
}
function parseFragmentToInlineFragment(definitions) {
    if (definitions.trim().startsWith('fragment')) {
        var document_1 = parse(definitions);
        for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {
            var definition = _a[_i];
            if (definition.kind === Kind$1.FRAGMENT_DEFINITION) {
                return {
                    kind: Kind$1.INLINE_FRAGMENT,
                    typeCondition: definition.typeCondition,
                    selectionSet: definition.selectionSet,
                };
            }
        }
    }
    var query = parse("{" + definitions + "}")
        .definitions[0];
    for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {
        var selection = _c[_b];
        if (selection.kind === Kind$1.INLINE_FRAGMENT) {
            return selection;
        }
    }
    throw new Error('Could not parse fragment');
}

function parseSelectionSet(selectionSet) {
    var query = parse(selectionSet).definitions[0];
    return query.selectionSet;
}
function typeContainsSelectionSet(type, selectionSet) {
    var fields = type.getFields();
    for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {
        var selection = _a[_i];
        if (selection.kind === Kind$1.FIELD) {
            var field = fields[selection.name.value];
            if (field == null) {
                return false;
            }
            if (selection.selectionSet != null) {
                return typeContainsSelectionSet(getNamedType(field.type), selection.selectionSet);
            }
        }
        else if (selection.kind === Kind$1.INLINE_FRAGMENT) {
            var containsSelectionSet = typeContainsSelectionSet(type, selection.selectionSet);
            if (!containsSelectionSet) {
                return false;
            }
        }
    }
    return true;
}

function mergeDeep(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    var output = __assign({}, target);
    sources.forEach(function (source) {
        if (isObject(target) && isObject(source)) {
            Object.keys(source).forEach(function (key) {
                var _a, _b;
                if (isObject(source[key])) {
                    if (!(key in target)) {
                        Object.assign(output, (_a = {}, _a[key] = source[key], _a));
                    }
                    else {
                        output[key] = mergeDeep(target[key], source[key]);
                    }
                }
                else {
                    Object.assign(output, (_b = {}, _b[key] = source[key], _b));
                }
            });
        }
    });
    return output;
}
function isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item);
}

function renameFieldNode(fieldNode, name) {
    return __assign(__assign({}, fieldNode), { alias: {
            kind: Kind$1.NAME,
            value: fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value,
        }, name: {
            kind: Kind$1.NAME,
            value: name,
        } });
}
function preAliasFieldNode(fieldNode, str) {
    return __assign(__assign({}, fieldNode), { alias: {
            kind: Kind$1.NAME,
            value: "" + str + (fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value),
        } });
}
function wrapFieldNode(fieldNode, path) {
    var newFieldNode = fieldNode;
    path.forEach(function (fieldName) {
        newFieldNode = {
            kind: Kind$1.FIELD,
            name: {
                kind: Kind$1.NAME,
                value: fieldName,
            },
            selectionSet: {
                kind: Kind$1.SELECTION_SET,
                selections: [fieldNode],
            },
        };
    });
    return newFieldNode;
}
function collectFields$1(selectionSet, fragments, fields, visitedFragmentNames) {
    if (fields === void 0) { fields = []; }
    if (visitedFragmentNames === void 0) { visitedFragmentNames = {}; }
    if (selectionSet != null) {
        selectionSet.selections.forEach(function (selection) {
            switch (selection.kind) {
                case Kind$1.FIELD:
                    fields.push(selection);
                    break;
                case Kind$1.INLINE_FRAGMENT:
                    collectFields$1(selection.selectionSet, fragments, fields, visitedFragmentNames);
                    break;
                case Kind$1.FRAGMENT_SPREAD: {
                    var fragmentName = selection.name.value;
                    if (!visitedFragmentNames[fragmentName]) {
                        visitedFragmentNames[fragmentName] = true;
                        collectFields$1(fragments[fragmentName].selectionSet, fragments, fields, visitedFragmentNames);
                    }
                    break;
                }
            }
        });
    }
    return fields;
}
function hoistFieldNodes(_a) {
    var fieldNode = _a.fieldNode, fieldNames = _a.fieldNames, _b = _a.path, path = _b === void 0 ? [] : _b, _c = _a.delimeter, delimeter = _c === void 0 ? '__gqltf__' : _c, fragments = _a.fragments;
    var alias = fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value;
    var newFieldNodes = [];
    if (path.length) {
        var remainingPathSegments_1 = path.slice();
        var initialPathSegment_1 = remainingPathSegments_1.shift();
        collectFields$1(fieldNode.selectionSet, fragments).forEach(function (possibleFieldNode) {
            if (possibleFieldNode.name.value === initialPathSegment_1) {
                newFieldNodes = newFieldNodes.concat(hoistFieldNodes({
                    fieldNode: preAliasFieldNode(possibleFieldNode, "" + alias + delimeter),
                    fieldNames: fieldNames,
                    path: remainingPathSegments_1,
                    delimeter: delimeter,
                    fragments: fragments,
                }));
            }
        });
    }
    else {
        collectFields$1(fieldNode.selectionSet, fragments).forEach(function (possibleFieldNode) {
            if (!fieldNames || fieldNames.includes(possibleFieldNode.name.value)) {
                newFieldNodes.push(preAliasFieldNode(possibleFieldNode, "" + alias + delimeter));
            }
        });
    }
    return newFieldNodes;
}

function appendFields(typeMap, typeName, fields) {
    var type = typeMap[typeName];
    if (type != null) {
        var typeConfig = toConfig(type);
        var originalFields_1 = typeConfig.fields;
        var newFields_1 = {};
        Object.keys(originalFields_1).forEach(function (fieldName) {
            newFields_1[fieldName] = originalFields_1[fieldName];
        });
        Object.keys(fields).forEach(function (fieldName) {
            newFields_1[fieldName] = fields[fieldName];
        });
        type = new GraphQLObjectType$1(__assign(__assign({}, typeConfig), { fields: newFields_1 }));
    }
    else {
        type = new GraphQLObjectType$1({
            name: typeName,
            fields: fields,
        });
    }
    typeMap[typeName] = type;
}
function removeFields(typeMap, typeName, testFn) {
    var type = typeMap[typeName];
    var typeConfig = toConfig(type);
    var originalFields = typeConfig.fields;
    var newFields = {};
    var removedFields = {};
    Object.keys(originalFields).forEach(function (fieldName) {
        if (testFn(fieldName, originalFields[fieldName])) {
            removedFields[fieldName] = originalFields[fieldName];
        }
        else {
            newFields[fieldName] = originalFields[fieldName];
        }
    });
    type = new GraphQLObjectType$1(__assign(__assign({}, typeConfig), { fields: newFields }));
    typeMap[typeName] = type;
    return removedFields;
}

function unwrapResult(parent, info, path) {
    var newParent = parent;
    var pathLength = path.length;
    for (var i = 0; i < pathLength; i++) {
        var responseKey = path[i];
        var errors = getErrors(newParent, responseKey);
        var subschema = getSubschema(newParent, responseKey);
        var object = newParent[responseKey];
        if (object == null) {
            return handleNull(info.fieldNodes, responsePathAsArray(info.path), errors);
        }
        setErrors(object, errors.map(function (error) {
            return relocatedError(error, error.nodes, error.path != null ? error.path.slice(1) : undefined);
        }));
        setObjectSubschema(object, subschema);
        newParent = object;
    }
    return newParent;
}
function dehoistResult(parent, delimeter) {
    if (delimeter === void 0) { delimeter = '__gqltf__'; }
    var result = Object.create(null);
    Object.keys(parent).forEach(function (alias) {
        var obj = result;
        var fieldNames = alias.split(delimeter);
        var fieldName = fieldNames.pop();
        fieldNames.forEach(function (key) {
            obj = obj[key] = obj[key] || Object.create(null);
        });
        obj[fieldName] = parent[alias];
    });
    result[ERROR_SYMBOL] = parent[ERROR_SYMBOL].map(function (error) {
        if (error.path != null) {
            var path = error.path.slice();
            var pathSegment = path.shift();
            var expandedPathSegment = pathSegment.split(delimeter);
            return relocatedError(error, error.nodes, expandedPathSegment.concat(path));
        }
        return error;
    });
    result[OBJECT_SUBSCHEMA_SYMBOL] = parent[OBJECT_SUBSCHEMA_SYMBOL];
    return result;
}
function mergeProxiedResults(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    var errors = target[ERROR_SYMBOL].concat(sources.map(function (source) { return source[ERROR_SYMBOL]; }));
    var fieldSubschemaMap = sources.reduce(function (acc, source) {
        var subschema = source[OBJECT_SUBSCHEMA_SYMBOL];
        Object.keys(source).forEach(function (key) {
            acc[key] = subschema;
        });
        return acc;
    }, {});
    var result = mergeDeep.apply(void 0, __spreadArrays([target], sources));
    result[ERROR_SYMBOL] = errors;
    result[FIELD_SUBSCHEMA_MAP_SYMBOL] = target[FIELD_SUBSCHEMA_MAP_SYMBOL]
        ? mergeDeep(target[FIELD_SUBSCHEMA_MAP_SYMBOL], fieldSubschemaMap)
        : fieldSubschemaMap;
    return result;
}

function buildDelegationPlan(mergedTypeInfo, originalSelections, sourceSubschemas, targetSubschemas) {
    // 1.  calculate if possible to delegate to given subschema
    //    TODO: change logic so that required selection set can be spread across multiple subschemas?
    var proxiableSubschemas = [];
    var nonProxiableSubschemas = [];
    targetSubschemas.forEach(function (t) {
        if (sourceSubschemas.some(function (s) {
            var selectionSet = mergedTypeInfo.selectionSets.get(t);
            return mergedTypeInfo.containsSelectionSet.get(s).get(selectionSet);
        })) {
            proxiableSubschemas.push(t);
        }
        else {
            nonProxiableSubschemas.push(t);
        }
    });
    var uniqueFields = mergedTypeInfo.uniqueFields, nonUniqueFields = mergedTypeInfo.nonUniqueFields;
    var unproxiableSelections = [];
    // 2. for each selection:
    var delegationMap = new Map();
    originalSelections.forEach(function (selection) {
        // 2a. use uniqueFields map to assign fields to subschema if one of possible subschemas
        var uniqueSubschema = uniqueFields[selection.name.value];
        if (uniqueSubschema != null) {
            if (proxiableSubschemas.includes(uniqueSubschema)) {
                var existingSubschema = delegationMap.get(uniqueSubschema);
                if (existingSubschema != null) {
                    existingSubschema.push(selection);
                }
                else {
                    delegationMap.set(uniqueSubschema, [selection]);
                }
            }
            else {
                unproxiableSelections.push(selection);
            }
        }
        else {
            // 2b. use nonUniqueFields to assign to a possible subschema,
            //     preferring one of the subschemas already targets of delegation
            var nonUniqueSubschemas = nonUniqueFields[selection.name.value];
            nonUniqueSubschemas = nonUniqueSubschemas.filter(function (s) {
                return proxiableSubschemas.includes(s);
            });
            if (nonUniqueSubschemas != null) {
                var subschemas_1 = Array.from(delegationMap.keys());
                var existingSubschema = nonUniqueSubschemas.find(function (s) {
                    return subschemas_1.includes(s);
                });
                if (existingSubschema != null) {
                    delegationMap.get(existingSubschema).push(selection);
                }
                else {
                    delegationMap.set(nonUniqueSubschemas[0], [selection]);
                }
            }
            else {
                unproxiableSelections.push(selection);
            }
        }
    });
    return {
        delegationMap: delegationMap,
        unproxiableSelections: unproxiableSelections,
        proxiableSubschemas: proxiableSubschemas,
        nonProxiableSubschemas: nonProxiableSubschemas,
    };
}
function mergeFields(mergedTypeInfo, typeName, object, originalSelections, sourceSubschemas, targetSubschemas, context, info) {
    if (!originalSelections.length) {
        return object;
    }
    var _a = buildDelegationPlan(mergedTypeInfo, originalSelections, sourceSubschemas, targetSubschemas), delegationMap = _a.delegationMap, unproxiableSelections = _a.unproxiableSelections, proxiableSubschemas = _a.proxiableSubschemas, nonProxiableSubschemas = _a.nonProxiableSubschemas;
    if (!delegationMap.size) {
        return object;
    }
    var maybePromises = [];
    delegationMap.forEach(function (selections, s) {
        var maybePromise = s.merge[typeName].resolve(object, context, info, s, {
            kind: Kind$1.SELECTION_SET,
            selections: selections,
        });
        maybePromises.push(maybePromise);
    });
    var containsPromises = false;
    for (var _i = 0, maybePromises_1 = maybePromises; _i < maybePromises_1.length; _i++) {
        var maybePromise = maybePromises_1[_i];
        if (maybePromise instanceof Promise) {
            containsPromises = true;
            break;
        }
    }
    return containsPromises
        ? Promise.all(maybePromises).then(function (results) {
            return mergeFields(mergedTypeInfo, typeName, mergeProxiedResults.apply(void 0, __spreadArrays([object], results)), unproxiableSelections, sourceSubschemas.concat(proxiableSubschemas), nonProxiableSubschemas, context, info);
        })
        : mergeFields(mergedTypeInfo, typeName, mergeProxiedResults.apply(void 0, __spreadArrays([object], maybePromises)), unproxiableSelections, sourceSubschemas.concat(proxiableSubschemas), nonProxiableSubschemas, context, info);
}

function handleObject(type, object, errors, subschema, context, info, skipTypeMerging) {
    setErrors(object, errors.map(function (error) {
        return relocatedError(error, error.nodes, error.path != null ? error.path.slice(1) : undefined);
    }));
    setObjectSubschema(object, subschema);
    if (skipTypeMerging || !info.mergeInfo) {
        return object;
    }
    var typeName = isAbstractType$1(type)
        ? info.schema.getTypeMap()[resolveFromParentTypename(object)].name
        : type.name;
    var mergedTypeInfo = info.mergeInfo.mergedTypes[typeName];
    var targetSubschemas;
    if (mergedTypeInfo != null) {
        targetSubschemas = mergedTypeInfo.subschemas;
    }
    if (!targetSubschemas) {
        return object;
    }
    targetSubschemas = targetSubschemas.filter(function (s) { return s !== subschema; });
    if (!targetSubschemas.length) {
        return object;
    }
    var subFields = collectSubFields(info, object.__typename);
    var selections = getFieldsNotInSubschema(subFields, subschema, mergedTypeInfo, object.__typename);
    return mergeFields(mergedTypeInfo, typeName, object, selections, [subschema], targetSubschemas, context, info);
}
function collectSubFields(info, typeName) {
    var subFieldNodes = Object.create(null);
    var visitedFragmentNames = Object.create(null);
    info.fieldNodes.forEach(function (fieldNode) {
        subFieldNodes = collectFields({
            schema: info.schema,
            variableValues: info.variableValues,
            fragments: info.fragments,
        }, info.schema.getType(typeName), fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);
    });
    return subFieldNodes;
}
function getFieldsNotInSubschema(subFieldNodes, subschema, mergedTypeInfo, typeName) {
    var typeMap = isSubschemaConfig(subschema)
        ? mergedTypeInfo.typeMaps.get(subschema)
        : subschema.getTypeMap();
    var fields = typeMap[typeName].getFields();
    var fieldsNotInSchema = [];
    Object.keys(subFieldNodes).forEach(function (responseName) {
        subFieldNodes[responseName].forEach(function (subFieldNode) {
            if (!fields[subFieldNode.name.value]) {
                fieldsNotInSchema.push(subFieldNode);
            }
        });
    });
    return fieldsNotInSchema;
}

function handleList(type, list, errors, subschema, context, info, skipTypeMerging) {
    var childErrors = getErrorsByPathSegment(errors);
    return list.map(function (listMember, index) {
        return handleListMember(getNullableType(type.ofType), listMember, index, childErrors[index] != null ? childErrors[index] : [], subschema, context, info, skipTypeMerging);
    });
}
function handleListMember(type, listMember, index, errors, subschema, context, info, skipTypeMerging) {
    if (listMember == null) {
        return handleNull(info.fieldNodes, __spreadArrays(responsePathAsArray(info.path), [index]), errors);
    }
    if (isLeafType(type)) {
        return type.parseValue(listMember);
    }
    else if (isCompositeType(type)) {
        return handleObject(type, listMember, errors, subschema, context, info, skipTypeMerging);
    }
    else if (isListType$1(type)) {
        return handleList(type, listMember, errors, subschema, context, info, skipTypeMerging);
    }
}

function checkResultAndHandleErrors(result, context, info, responseKey, subschema, returnType, skipTypeMerging) {
    if (responseKey === void 0) { responseKey = getResponseKeyFromInfo(info); }
    if (returnType === void 0) { returnType = info.returnType; }
    var errors = result.errors != null ? result.errors : [];
    var data = result.data != null ? result.data[responseKey] : undefined;
    return handleResult(data, errors, subschema, context, info, returnType, skipTypeMerging);
}
function handleResult(result, errors, subschema, context, info, returnType, skipTypeMerging) {
    if (returnType === void 0) { returnType = info.returnType; }
    var type = getNullableType(returnType);
    if (result == null) {
        return handleNull(info.fieldNodes, responsePathAsArray(info.path), errors);
    }
    if (isLeafType(type)) {
        return type.parseValue(result);
    }
    else if (isCompositeType(type)) {
        return handleObject(type, result, errors, subschema, context, info, skipTypeMerging);
    }
    else if (isListType$1(type)) {
        return handleList(type, result, errors, subschema, context, info, skipTypeMerging);
    }
}

var CheckResultAndHandleErrors = /** @class */ (function () {
    function CheckResultAndHandleErrors(info, fieldName, subschema, context, returnType, typeMerge) {
        if (returnType === void 0) { returnType = info.returnType; }
        this.context = context;
        this.info = info;
        this.fieldName = fieldName;
        this.subschema = subschema;
        this.returnType = returnType;
        this.typeMerge = typeMerge;
    }
    CheckResultAndHandleErrors.prototype.transformResult = function (result) {
        return checkResultAndHandleErrors(result, this.context != null ? this.context : {}, this.info, this.fieldName, this.subschema, this.returnType, this.typeMerge);
    };
    return CheckResultAndHandleErrors;
}());

function astFromType(type) {
    if (isNonNullType$1(type)) {
        var innerType = astFromType(type.ofType);
        if (innerType.kind === Kind$1.NON_NULL_TYPE) {
            throw new Error("Invalid type node " + JSON.stringify(type) + ". Inner type of non-null type cannot be a non-null type.");
        }
        return {
            kind: Kind$1.NON_NULL_TYPE,
            type: innerType,
        };
    }
    else if (isListType$1(type)) {
        return {
            kind: Kind$1.LIST_TYPE,
            type: astFromType(type.ofType),
        };
    }
    return {
        kind: Kind$1.NAMED_TYPE,
        name: {
            kind: Kind$1.NAME,
            value: type.name,
        },
    };
}

function updateArgument(argName, argType, argumentNodes, variableDefinitionsMap, variableValues, newArg) {
    var varName;
    var numGeneratedVariables = 0;
    do {
        varName = "_v" + (numGeneratedVariables++).toString() + "_" + argName;
    } while (variableDefinitionsMap[varName] != null);
    argumentNodes[argName] = {
        kind: Kind$1.ARGUMENT,
        name: {
            kind: Kind$1.NAME,
            value: argName,
        },
        value: {
            kind: Kind$1.VARIABLE,
            name: {
                kind: Kind$1.NAME,
                value: varName,
            },
        },
    };
    variableDefinitionsMap[varName] = {
        kind: Kind$1.VARIABLE_DEFINITION,
        variable: {
            kind: Kind$1.VARIABLE,
            name: {
                kind: Kind$1.NAME,
                value: varName,
            },
        },
        type: astFromType(argType),
    };
    variableValues[varName] = newArg;
}

var AddArgumentsAsVariables = /** @class */ (function () {
    function AddArgumentsAsVariables(targetSchema, args) {
        this.targetSchema = targetSchema;
        this.args = args;
    }
    AddArgumentsAsVariables.prototype.transformRequest = function (originalRequest) {
        var _a = addVariablesToRootField(this.targetSchema, originalRequest, this.args), document = _a.document, newVariables = _a.newVariables;
        return {
            document: document,
            variables: newVariables,
        };
    };
    return AddArgumentsAsVariables;
}());
function addVariablesToRootField(targetSchema, originalRequest, args) {
    var document = originalRequest.document;
    var variableValues = originalRequest.variables;
    var operations = document.definitions.filter(function (def) { return def.kind === Kind$1.OPERATION_DEFINITION; });
    var fragments = document.definitions.filter(function (def) { return def.kind === Kind$1.FRAGMENT_DEFINITION; });
    var newOperations = operations.map(function (operation) {
        var variableDefinitionMap = {};
        operation.variableDefinitions.forEach(function (def) {
            var varName = def.variable.name.value;
            variableDefinitionMap[varName] = def;
        });
        var type;
        if (operation.operation === 'subscription') {
            type = targetSchema.getSubscriptionType();
        }
        else if (operation.operation === 'mutation') {
            type = targetSchema.getMutationType();
        }
        else {
            type = targetSchema.getQueryType();
        }
        var newSelectionSet = [];
        operation.selectionSet.selections.forEach(function (selection) {
            if (selection.kind === Kind$1.FIELD) {
                var argumentNodes = selection.arguments;
                var argumentNodeMap_1 = {};
                argumentNodes.forEach(function (argument) {
                    argumentNodeMap_1[argument.name.value] = argument;
                });
                var targetField = type.getFields()[selection.name.value];
                // excludes __typename
                if (targetField != null) {
                    updateArguments(targetField, argumentNodeMap_1, variableDefinitionMap, variableValues, args);
                }
                newSelectionSet.push(__assign(__assign({}, selection), { arguments: Object.keys(argumentNodeMap_1).map(function (argName) { return argumentNodeMap_1[argName]; }) }));
            }
            else {
                newSelectionSet.push(selection);
            }
        });
        return __assign(__assign({}, operation), { variableDefinitions: Object.keys(variableDefinitionMap).map(function (varName) { return variableDefinitionMap[varName]; }), selectionSet: {
                kind: Kind$1.SELECTION_SET,
                selections: newSelectionSet,
            } });
    });
    return {
        document: __assign(__assign({}, document), { definitions: __spreadArrays(newOperations, fragments) }),
        newVariables: variableValues,
    };
}
var hasOwn$4 = Object.prototype.hasOwnProperty;
function updateArguments(targetField, argumentNodeMap, variableDefinitionMap, variableValues, newArgs) {
    targetField.args.forEach(function (argument) {
        var argName = argument.name;
        var argType = argument.type;
        if (hasOwn$4.call(newArgs, argName)) {
            updateArgument(argName, argType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(argType, newArgs[argName]));
        }
    });
}

function applySchemaTransforms(originalSchema, transforms) {
    return transforms.reduce(function (schema, transform) {
        return transform.transformSchema != null
            ? transform.transformSchema(cloneSchema(schema))
            : schema;
    }, originalSchema);
}
function applyRequestTransforms(originalRequest, transforms) {
    return transforms.reduce(function (request, transform) {
        return transform.transformRequest != null
            ? transform.transformRequest(request)
            : request;
    }, originalRequest);
}
function applyResultTransforms(originalResult, transforms) {
    return transforms.reduceRight(function (result, transform) {
        return transform.transformResult != null
            ? transform.transformResult(result)
            : result;
    }, originalResult);
}

function linkToFetcher(link) {
    return function (fetcherOperation) {
        return toPromise(execute(link, fetcherOperation));
    };
}

function observableToAsyncIterable(observable) {
    var _a;
    var pullQueue = [];
    var pushQueue = [];
    var listening = true;
    var pushValue = function (value) {
        if (pullQueue.length !== 0) {
            pullQueue.shift()({ value: value, done: false });
        }
        else {
            pushQueue.push({ value: value });
        }
    };
    var pushError = function (error) {
        if (pullQueue.length !== 0) {
            pullQueue.shift()({ value: { errors: [error] }, done: false });
        }
        else {
            pushQueue.push({ value: { errors: [error] } });
        }
    };
    var pullValue = function () {
        return new Promise(function (resolve) {
            if (pushQueue.length !== 0) {
                var element = pushQueue.shift();
                // either {value: {errors: [...]}} or {value: ...}
                resolve(__assign(__assign({}, element), { done: false }));
            }
            else {
                pullQueue.push(resolve);
            }
        });
    };
    var subscription = observable.subscribe({
        next: function (value) {
            pushValue(value);
        },
        error: function (err) {
            pushError(err);
        },
    });
    var emptyQueue = function () {
        if (listening) {
            listening = false;
            subscription.unsubscribe();
            pullQueue.forEach(function (resolve) { return resolve({ value: undefined, done: true }); });
            pullQueue.length = 0;
            pushQueue.length = 0;
        }
    };
    return _a = {
            next: function () {
                return listening ? pullValue() : this.return();
            },
            return: function () {
                emptyQueue();
                return Promise.resolve({ value: undefined, done: true });
            },
            throw: function (error) {
                emptyQueue();
                return Promise.reject(error);
            }
        },
        _a[$$asyncIterator] = function () {
            return this;
        },
        _a;
}

/**
 * Given an AsyncIterable and a callback function, return an AsyncIterator
 * which produces values mapped via calling the callback function.
 */
function mapAsyncIterator(iterator, callback, rejectCallback) {
    var _a;
    var $return;
    var abruptClose;
    if (typeof iterator.return === 'function') {
        $return = iterator.return;
        abruptClose = function (error) {
            var rethrow = function () { return Promise.reject(error); };
            return $return.call(iterator).then(rethrow, rethrow);
        };
    }
    function mapResult(result) {
        return result.done
            ? result
            : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
    }
    var mapReject;
    if (rejectCallback) {
        // Capture rejectCallback to ensure it cannot be null.
        var reject_1 = rejectCallback;
        mapReject = function (error) {
            return asyncMapValue(error, reject_1).then(iteratorResult, abruptClose);
        };
    }
    return _a = {
            next: function () {
                return iterator.next().then(mapResult, mapReject);
            },
            return: function () {
                return $return
                    ? $return.call(iterator).then(mapResult, mapReject)
                    : Promise.resolve({ value: undefined, done: true });
            },
            throw: function (error) {
                if (typeof iterator.throw === 'function') {
                    return iterator.throw(error).then(mapResult, mapReject);
                }
                return Promise.reject(error).catch(abruptClose);
            }
        },
        _a[$$asyncIterator] = function () {
            return this;
        },
        _a;
}
function asyncMapValue(value, callback) {
    return new Promise(function (resolve) { return resolve(callback(value)); });
}
function iteratorResult(value) {
    return { value: value, done: false };
}

function getDelegatingOperation(parentType, schema) {
    if (parentType === schema.getMutationType()) {
        return 'mutation';
    }
    else if (parentType === schema.getSubscriptionType()) {
        return 'subscription';
    }
    return 'query';
}
function createRequestFromInfo(_a) {
    var info = _a.info, _b = _a.operation, operation = _b === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _b, _c = _a.fieldName, fieldName = _c === void 0 ? info.fieldName : _c, selectionSet = _a.selectionSet, fieldNodes = _a.fieldNodes;
    return createRequest({
        sourceSchema: info.schema,
        sourceParentType: info.parentType,
        sourceFieldName: info.fieldName,
        fragments: info.fragments,
        variableDefinitions: info.operation.variableDefinitions,
        variableValues: info.variableValues,
        targetOperation: operation,
        targetFieldName: fieldName,
        selectionSet: selectionSet,
        fieldNodes: selectionSet != null
            ? undefined
            : fieldNodes != null
                ? fieldNodes
                : info.fieldNodes,
    });
}
function createRequest(_a) {
    var sourceSchema = _a.sourceSchema, sourceParentType = _a.sourceParentType, sourceFieldName = _a.sourceFieldName, fragments = _a.fragments, variableDefinitions = _a.variableDefinitions, variableValues = _a.variableValues, targetOperation = _a.targetOperation, targetFieldName = _a.targetFieldName, selectionSet = _a.selectionSet, fieldNodes = _a.fieldNodes;
    var argumentNodes;
    var newSelectionSet = selectionSet;
    if (!selectionSet && fieldNodes != null) {
        var selections = fieldNodes.reduce(function (acc, fieldNode) {
            return fieldNode.selectionSet != null
                ? acc.concat(fieldNode.selectionSet.selections)
                : acc;
        }, []);
        newSelectionSet = selections.length
            ? {
                kind: Kind$1.SELECTION_SET,
                selections: selections,
            }
            : undefined;
        argumentNodes = fieldNodes[0].arguments;
    }
    else {
        argumentNodes = [];
    }
    var newVariables = {};
    var variableDefinitionMap = {};
    variableDefinitions.forEach(function (def) {
        var varName = def.variable.name.value;
        variableDefinitionMap[varName] = def;
        var varType = typeFromAST$2(sourceSchema, def.type);
        newVariables[varName] = serializeInputValue(varType, variableValues[varName]);
    });
    var argumentNodeMap = {};
    argumentNodes.forEach(function (argument) {
        argumentNodeMap[argument.name.value] = argument;
    });
    updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, newVariables);
    var rootfieldNode = {
        kind: Kind$1.FIELD,
        alias: null,
        arguments: Object.keys(argumentNodeMap).map(function (argName) { return argumentNodeMap[argName]; }),
        selectionSet: newSelectionSet,
        name: {
            kind: Kind$1.NAME,
            value: targetFieldName || fieldNodes[0].name.value,
        },
    };
    var operationDefinition = {
        kind: Kind$1.OPERATION_DEFINITION,
        operation: targetOperation,
        variableDefinitions: Object.keys(variableDefinitionMap).map(function (varName) { return variableDefinitionMap[varName]; }),
        selectionSet: {
            kind: Kind$1.SELECTION_SET,
            selections: [rootfieldNode],
        },
    };
    var fragmentDefinitions = Object.keys(fragments).map(function (fragmentName) { return fragments[fragmentName]; });
    var document = {
        kind: Kind$1.DOCUMENT,
        definitions: __spreadArrays([operationDefinition], fragmentDefinitions),
    };
    return {
        document: document,
        variables: newVariables,
    };
}
function updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, variableValues) {
    var sourceField = sourceParentType.getFields()[sourceFieldName];
    sourceField.args.forEach(function (argument) {
        var argName = argument.name;
        var sourceArgType = argument.type;
        if (argumentNodeMap[argName] === undefined) {
            var defaultValue = argument.defaultValue;
            if (defaultValue !== undefined) {
                updateArgument(argName, sourceArgType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(sourceArgType, defaultValue));
            }
        }
    });
}

function delegateToSchema(options) {
    if (isSchema(options)) {
        throw new Error('Passing positional arguments to delegateToSchema is deprecated. ' +
            'Please pass named parameters instead.');
    }
    var info = options.info, _a = options.operation, operation = _a === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _a, _b = options.fieldName, fieldName = _b === void 0 ? info.fieldName : _b, _c = options.returnType, returnType = _c === void 0 ? info.returnType : _c, selectionSet = options.selectionSet, fieldNodes = options.fieldNodes;
    var request = createRequestFromInfo({
        info: info,
        operation: operation,
        fieldName: fieldName,
        selectionSet: selectionSet,
        fieldNodes: fieldNodes,
    });
    return delegateRequest(__assign(__assign({}, options), { request: request,
        operation: operation,
        fieldName: fieldName,
        returnType: returnType }));
}
function buildDelegationTransforms(subschemaOrSubschemaConfig, info, context, targetSchema, fieldName, args, returnType, transforms, skipTypeMerging) {
    var delegationTransforms = [
        new CheckResultAndHandleErrors(info, fieldName, subschemaOrSubschemaConfig, context, returnType, skipTypeMerging),
    ];
    if (info.mergeInfo != null) {
        delegationTransforms.push(new AddReplacementSelectionSets(info.schema, info.mergeInfo.replacementSelectionSets), new AddMergedTypeFragments(info.schema, info.mergeInfo.mergedTypes));
    }
    delegationTransforms = delegationTransforms.concat(transforms);
    delegationTransforms.push(new ExpandAbstractTypes(info.schema, targetSchema));
    if (info.mergeInfo != null) {
        delegationTransforms.push(new AddReplacementFragments(targetSchema, info.mergeInfo.replacementFragments));
    }
    if (args != null) {
        delegationTransforms.push(new AddArgumentsAsVariables(targetSchema, args));
    }
    delegationTransforms.push(new FilterToSchema(targetSchema), new AddTypenameToAbstract(targetSchema));
    return delegationTransforms;
}
function delegateRequest(_a) {
    var request = _a.request, subschemaOrSubschemaConfig = _a.schema, rootValue = _a.rootValue, info = _a.info, _b = _a.operation, operation = _b === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _b, _c = _a.fieldName, fieldName = _c === void 0 ? info.fieldName : _c, args = _a.args, _d = _a.returnType, returnType = _d === void 0 ? info.returnType : _d, context = _a.context, _e = _a.transforms, transforms = _e === void 0 ? [] : _e, skipValidation = _a.skipValidation, skipTypeMerging = _a.skipTypeMerging;
    var targetSchema;
    var targetRootValue;
    var requestTransforms = transforms.slice();
    var subschemaConfig;
    if (isSubschemaConfig(subschemaOrSubschemaConfig)) {
        subschemaConfig = subschemaOrSubschemaConfig;
        targetSchema = subschemaConfig.schema;
        targetRootValue =
            rootValue != null
                ? rootValue
                : subschemaConfig.rootValue != null
                    ? subschemaConfig.rootValue
                    : info.rootValue;
        if (subschemaConfig.transforms != null) {
            requestTransforms = requestTransforms.concat(subschemaConfig.transforms);
        }
    }
    else {
        targetSchema = subschemaOrSubschemaConfig;
        targetRootValue = rootValue != null ? rootValue : info.rootValue;
    }
    var delegationTransforms = buildDelegationTransforms(subschemaOrSubschemaConfig, info, context, targetSchema, fieldName, args, returnType, requestTransforms.reverse(), skipTypeMerging);
    var processedRequest = applyRequestTransforms(request, delegationTransforms);
    if (!skipValidation) {
        var errors = validate(targetSchema, processedRequest.document);
        if (errors.length > 0) {
            var combinedError = combineErrors(errors);
            throw combinedError;
        }
    }
    if (operation === 'query' || operation === 'mutation') {
        var executor = createExecutor(targetSchema, targetRootValue, context, subschemaConfig);
        var executionResult = executor({
            document: processedRequest.document,
            context: context,
            variables: processedRequest.variables,
        });
        if (executionResult instanceof Promise) {
            return executionResult.then(function (originalResult) {
                return applyResultTransforms(originalResult, delegationTransforms);
            });
        }
        return applyResultTransforms(executionResult, delegationTransforms);
    }
    var subscriber = createSubscriber(targetSchema, targetRootValue, context, subschemaConfig);
    return subscriber({
        document: processedRequest.document,
        context: context,
        variables: processedRequest.variables,
    }).then(function (subscriptionResult) {
        if (isAsyncIterable(subscriptionResult)) {
            // "subscribe" to the subscription result and map the result through the transforms
            return mapAsyncIterator(subscriptionResult, function (result) {
                var _a;
                var transformedResult = applyResultTransforms(result, delegationTransforms);
                // wrap with fieldName to return for an additional round of resolutioon
                // with payload as rootValue
                return _a = {},
                    _a[info.fieldName] = transformedResult,
                    _a;
            });
        }
        return applyResultTransforms(subscriptionResult, delegationTransforms);
    });
}
function createExecutor(schema, rootValue, context, subschemaConfig) {
    var fetcher;
    var targetRootValue = rootValue;
    if (subschemaConfig != null) {
        if (subschemaConfig.dispatcher != null) {
            var dynamicLinkOrFetcher = subschemaConfig.dispatcher(context);
            fetcher =
                typeof dynamicLinkOrFetcher === 'function'
                    ? dynamicLinkOrFetcher
                    : linkToFetcher(dynamicLinkOrFetcher);
        }
        else if (subschemaConfig.link != null) {
            fetcher = linkToFetcher(subschemaConfig.link);
        }
        else if (subschemaConfig.fetcher != null) {
            fetcher = subschemaConfig.fetcher;
        }
        if (!fetcher && !rootValue && subschemaConfig.rootValue != null) {
            targetRootValue = subschemaConfig.rootValue;
        }
    }
    if (fetcher != null) {
        return function (_a) {
            var document = _a.document, graphqlContext = _a.context, variables = _a.variables;
            return fetcher({
                query: document,
                variables: variables,
                context: { graphqlContext: graphqlContext },
            });
        };
    }
    return function (_a) {
        var document = _a.document, graphqlContext = _a.context, variables = _a.variables;
        return execute$1({
            schema: schema,
            document: document,
            rootValue: targetRootValue,
            contextValue: graphqlContext,
            variableValues: variables,
        });
    };
}
function createSubscriber(schema, rootValue, context, subschemaConfig) {
    var link;
    var targetRootValue = rootValue;
    if (subschemaConfig != null) {
        if (subschemaConfig.dispatcher != null) {
            link = subschemaConfig.dispatcher(context);
        }
        else if (subschemaConfig.link != null) {
            link = subschemaConfig.link;
        }
        if (!link && !rootValue && subschemaConfig.rootValue != null) {
            targetRootValue = subschemaConfig.rootValue;
        }
    }
    if (link != null) {
        return function (_a) {
            var document = _a.document, graphqlContext = _a.context, variables = _a.variables;
            var operation = {
                query: document,
                variables: variables,
                context: { graphqlContext: graphqlContext },
            };
            var observable = execute(link, operation);
            return observableToAsyncIterable(observable);
        };
    }
    return function (_a) {
        var document = _a.document, graphqlContext = _a.context, variables = _a.variables;
        return subscribe({
            schema: schema,
            document: document,
            rootValue: targetRootValue,
            contextValue: graphqlContext,
            variableValues: variables,
        });
    };
}

// @schemaDefinition: A GraphQL type schema in shorthand
// @resolvers: Definitions for resolvers to be merged with schema
var SchemaError = /** @class */ (function (_super) {
    __extends(SchemaError, _super);
    function SchemaError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        Error.captureStackTrace(_this, _this.constructor);
        return _this;
    }
    return SchemaError;
}(Error));

// If we have any union or interface types throw if no there is no resolveType or isTypeOf resolvers
function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
    Object.keys(schema.getTypeMap())
        .map(function (typeName) { return schema.getType(typeName); })
        .forEach(function (type) {
        if (!isAbstractType$1(type)) {
            return;
        }
        if (!type.resolveType) {
            if (!requireResolversForResolveType) {
                return;
            }
            throw new SchemaError("Type \"" + type.name + "\" is missing a \"__resolveType\" resolver. Pass false into " +
                '"resolverValidationOptions.requireResolversForResolveType" to disable this error.');
        }
    });
}

function extendResolversFromInterfaces(schema, resolvers) {
    var typeNames = Object.keys(__assign(__assign({}, schema.getTypeMap()), resolvers));
    var extendedResolvers = {};
    typeNames.forEach(function (typeName) {
        var typeResolvers = resolvers[typeName];
        var type = schema.getType(typeName);
        if (isObjectType$1(type) ||
            (graphqlVersion() >= 15 && isInterfaceType$1(type))) {
            var interfaceResolvers = type
                .getInterfaces()
                .map(function (iFace) { return resolvers[iFace.name]; });
            extendedResolvers[typeName] = Object.assign.apply(Object, __spreadArrays([{}], interfaceResolvers, [typeResolvers]));
        }
        else if (typeResolvers != null) {
            extendedResolvers[typeName] = typeResolvers;
        }
    });
    return extendedResolvers;
}

function addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
    var options = isSchema(schemaOrOptions)
        ? {
            schema: schemaOrOptions,
            resolvers: legacyInputResolvers,
            resolverValidationOptions: legacyInputValidationOptions,
        }
        : schemaOrOptions;
    var schema = options.schema, inputResolvers = options.resolvers, defaultFieldResolver = options.defaultFieldResolver, _a = options.resolverValidationOptions, resolverValidationOptions = _a === void 0 ? {} : _a, _b = options.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _b === void 0 ? false : _b;
    var _c = resolverValidationOptions.allowResolversNotInSchema, allowResolversNotInSchema = _c === void 0 ? false : _c, requireResolversForResolveType = resolverValidationOptions.requireResolversForResolveType;
    var resolvers = inheritResolversFromInterfaces
        ? extendResolversFromInterfaces(schema, inputResolvers)
        : inputResolvers;
    var typeMap = schema.getTypeMap();
    Object.keys(resolvers).forEach(function (typeName) {
        var resolverValue = resolvers[typeName];
        var resolverType = typeof resolverValue;
        if (resolverType !== 'object' && resolverType !== 'function') {
            throw new SchemaError("\"" + typeName + "\" defined in resolvers, but has invalid value \"" + resolverValue + "\". A resolver's value must be of type object or function.");
        }
        var type = schema.getType(typeName);
        if (!type && typeName !== '__schema') {
            if (allowResolversNotInSchema) {
                return;
            }
            throw new SchemaError("\"" + typeName + "\" defined in resolvers, but not in schema");
        }
        if (isScalarType$1(type)) {
            // Support -- without recommending -- overriding default scalar types
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (fieldName.startsWith('__')) {
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                }
                else {
                    type[fieldName] = resolverValue[fieldName];
                }
            });
        }
        else if (isEnumType$1(type)) {
            // We've encountered an enum resolver that is being used to provide an
            // internal enum value.
            // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (!type.getValue(fieldName)) {
                    if (allowResolversNotInSchema) {
                        return;
                    }
                    throw new SchemaError(typeName + "." + fieldName + " was defined in resolvers, but enum is not in schema");
                }
            });
            var config = toConfig(type);
            var values = type.getValues();
            var newValues_1 = {};
            values.forEach(function (value) {
                var newValue = Object.keys(resolverValue).includes(value.name)
                    ? resolverValue[value.name]
                    : value.name;
                newValues_1[value.name] = {
                    value: newValue,
                    deprecationReason: value.deprecationReason,
                    description: value.description,
                    astNode: value.astNode,
                };
            });
            // healSchema called later to update all fields to new type
            typeMap[typeName] = new GraphQLEnumType$1(__assign(__assign({}, config), { values: newValues_1 }));
        }
        else if (isUnionType$1(type)) {
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (fieldName.startsWith('__')) {
                    // this is for isTypeOf and resolveType and all the other stuff.
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                    return;
                }
                if (allowResolversNotInSchema) {
                    return;
                }
                throw new SchemaError(typeName + " was defined in resolvers, but it's not an object");
            });
        }
        else if (isObjectType$1(type) || isInterfaceType$1(type)) {
            Object.keys(resolverValue).forEach(function (fieldName) {
                if (fieldName.startsWith('__')) {
                    // this is for isTypeOf and resolveType and all the other stuff.
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                    return;
                }
                var fields = type.getFields();
                var field = fields[fieldName];
                if (field == null) {
                    if (allowResolversNotInSchema) {
                        return;
                    }
                    throw new SchemaError(typeName + "." + fieldName + " defined in resolvers, but not in schema");
                }
                var fieldResolve = resolverValue[fieldName];
                if (typeof fieldResolve === 'function') {
                    // for convenience. Allows shorter syntax in resolver definition file
                    field.resolve = fieldResolve;
                }
                else {
                    if (typeof fieldResolve !== 'object') {
                        throw new SchemaError("Resolver " + typeName + "." + fieldName + " must be object or function");
                    }
                    setFieldProperties(field, fieldResolve);
                }
            });
        }
    });
    checkForResolveTypeResolver(schema, requireResolversForResolveType);
    // serialize all default values prior to healing fields with new scalar/enum types.
    forEachDefaultValue(schema, serializeInputValue);
    // schema may have new scalar/enum types that require healing
    healSchema(schema);
    // reparse all default values with new parsing functions.
    forEachDefaultValue(schema, parseInputValue);
    if (defaultFieldResolver != null) {
        forEachField(schema, function (field) {
            if (!field.resolve) {
                field.resolve = defaultFieldResolver;
            }
        });
    }
    return schema;
}
function setFieldProperties(field, propertiesObj) {
    Object.keys(propertiesObj).forEach(function (propertyName) {
        field[propertyName] = propertiesObj[propertyName];
    });
}

// wraps all resolvers of query, mutation or subscription fields
// with the provided function to simulate a root schema level resolver
function addSchemaLevelResolver(schema, fn) {
    // TODO test that schema is a schema, fn is a function
    var rootTypes = [
        schema.getQueryType(),
        schema.getMutationType(),
        schema.getSubscriptionType(),
    ].filter(function (x) { return Boolean(x); });
    rootTypes.forEach(function (type) {
        if (type != null) {
            // XXX this should run at most once per request to simulate a true root resolver
            // for graphql-js this is an approximation that works with queries but not mutations
            var rootResolveFn_1 = runAtMostOncePerRequest(fn);
            var fields_1 = type.getFields();
            Object.keys(fields_1).forEach(function (fieldName) {
                // XXX if the type is a subscription, a same query AST will be ran multiple times so we
                // deactivate here the runOnce if it's a subscription. This may not be optimal though...
                if (type === schema.getSubscriptionType()) {
                    fields_1[fieldName].resolve = wrapResolver(fields_1[fieldName].resolve, fn);
                }
                else {
                    fields_1[fieldName].resolve = wrapResolver(fields_1[fieldName].resolve, rootResolveFn_1);
                }
            });
        }
    });
}
// XXX badly named function. this doesn't really wrap, it just chains resolvers...
function wrapResolver(innerResolver, outerResolver) {
    return function (obj, args, ctx, info) {
        return Promise.resolve(outerResolver(obj, args, ctx, info)).then(function (root) {
            if (innerResolver != null) {
                return innerResolver(root, args, ctx, info);
            }
            return defaultFieldResolver(root, args, ctx, info);
        });
    };
}
// XXX this function only works for resolvers
// XXX very hacky way to remember if the function
// already ran for this request. This will only work
// if people don't actually cache the operation.
// if they do cache the operation, they will have to
// manually remove the __runAtMostOnce before every request.
function runAtMostOncePerRequest(fn) {
    var value;
    var randomNumber = Math.random();
    return function (root, args, ctx, info) {
        if (!info.operation['__runAtMostOnce']) {
            info.operation['__runAtMostOnce'] = {};
        }
        if (!info.operation['__runAtMostOnce'][randomNumber]) {
            info.operation['__runAtMostOnce'][randomNumber] = true;
            value = fn(root, args, ctx, info);
        }
        return value;
    };
}

function assertResolversPresent(schema, resolverValidationOptions) {
    if (resolverValidationOptions === void 0) { resolverValidationOptions = {}; }
    var _a = resolverValidationOptions.requireResolversForArgs, requireResolversForArgs = _a === void 0 ? false : _a, _b = resolverValidationOptions.requireResolversForNonScalar, requireResolversForNonScalar = _b === void 0 ? false : _b, _c = resolverValidationOptions.requireResolversForAllFields, requireResolversForAllFields = _c === void 0 ? false : _c;
    if (requireResolversForAllFields &&
        (requireResolversForArgs || requireResolversForNonScalar)) {
        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +
            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +
            'requireResolversForNonScalar, but not a combination of them.');
    }
    forEachField(schema, function (field, typeName, fieldName) {
        // requires a resolver for *every* field.
        if (requireResolversForAllFields) {
            expectResolver(field, typeName, fieldName);
        }
        // requires a resolver on every field that has arguments
        if (requireResolversForArgs && field.args.length > 0) {
            expectResolver(field, typeName, fieldName);
        }
        // requires a resolver on every field that returns a non-scalar type
        if (requireResolversForNonScalar &&
            !isScalarType$1(getNamedType(field.type))) {
            expectResolver(field, typeName, fieldName);
        }
    });
}
function expectResolver(field, typeName, fieldName) {
    if (!field.resolve) {
        // eslint-disable-next-line no-console
        console.warn("Resolver missing for \"" + typeName + "." + fieldName + "\". To disable this warning check https://github.com/apollostack/graphql-tools/issues/131");
        return;
    }
    if (typeof field.resolve !== 'function') {
        throw new SchemaError("Resolver \"" + typeName + "." + fieldName + "\" must be a function");
    }
}

function attachDirectiveResolvers(schema, directiveResolvers) {
    if (typeof directiveResolvers !== 'object') {
        throw new Error("Expected directiveResolvers to be of type object, got " + typeof directiveResolvers);
    }
    if (Array.isArray(directiveResolvers)) {
        throw new Error('Expected directiveResolvers to be of type object, got Array');
    }
    var schemaDirectives = Object.create(null);
    Object.keys(directiveResolvers).forEach(function (directiveName) {
        schemaDirectives[directiveName] = /** @class */ (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            class_1.prototype.visitFieldDefinition = function (field) {
                var resolver = directiveResolvers[directiveName];
                var originalResolver = field.resolve != null ? field.resolve : defaultFieldResolver;
                var directiveArgs = this.args;
                field.resolve = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var source = args[0] /* original args */, context = args[2], info = args[3];
                    return resolver(function () {
                        return new Promise(function (resolve, reject) {
                            var result = originalResolver.apply(field, args);
                            if (result instanceof Error) {
                                reject(result);
                            }
                            resolve(result);
                        });
                    }, source, directiveArgs, context, info);
                };
            };
            return class_1;
        }(SchemaDirectiveVisitor));
    });
    SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);
}

// takes a GraphQL-JS schema and an object of connectors, then attaches
// the connectors to the context by wrapping each query or mutation resolve
// function with a function that attaches connectors if they don't exist.
// attaches connectors only once to make sure they are singletons
var attachConnectorsToContext = deprecated({
    version: '0.7.0',
    url: 'https://github.com/apollostack/graphql-tools/issues/140',
}, function (schema, connectors) {
    if (!schema || !isSchema(schema)) {
        throw new Error('schema must be an instance of GraphQLSchema. ' +
            'This error could be caused by installing more than one version of GraphQL-JS');
    }
    if (typeof connectors !== 'object') {
        var connectorType = typeof connectors;
        throw new Error("Expected connectors to be of type object, got " + connectorType);
    }
    if (Object.keys(connectors).length === 0) {
        throw new Error('Expected connectors to not be an empty object');
    }
    if (Array.isArray(connectors)) {
        throw new Error('Expected connectors to be of type object, got Array');
    }
    if (schema['_apolloConnectorsAttached']) {
        throw new Error('Connectors already attached to context, cannot attach more than once');
    }
    schema['_apolloConnectorsAttached'] = true;
    var attachconnectorFn = function (root, _args, ctx) {
        if (typeof ctx !== 'object') {
            // if in any way possible, we should throw an error when the attachconnectors
            // function is called, not when a query is executed.
            var contextType = typeof ctx;
            throw new Error("Cannot attach connector because context is not an object: " + contextType);
        }
        if (typeof ctx.connectors === 'undefined') {
            ctx.connectors = {};
        }
        Object.keys(connectors).forEach(function (connectorName) {
            var connector = connectors[connectorName];
            if (connector.prototype != null) {
                ctx.connectors[connectorName] = new connector(ctx);
            }
            else {
                throw new Error('Connector must be a function or an class');
            }
        });
        return root;
    };
    addSchemaLevelResolver(schema, attachconnectorFn);
});

function extractExtensionDefinitions(ast) {
    var extensionDefs = ast.definitions.filter(function (def) {
        return def.kind === Kind$1.OBJECT_TYPE_EXTENSION ||
            (graphqlVersion() >= 13 && def.kind === Kind$1.INTERFACE_TYPE_EXTENSION) ||
            def.kind === Kind$1.INPUT_OBJECT_TYPE_EXTENSION ||
            def.kind === Kind$1.UNION_TYPE_EXTENSION ||
            def.kind === Kind$1.ENUM_TYPE_EXTENSION ||
            def.kind === Kind$1.SCALAR_TYPE_EXTENSION ||
            def.kind === Kind$1.SCHEMA_EXTENSION;
    });
    return __assign(__assign({}, ast), { definitions: extensionDefs });
}
function filterExtensionDefinitions(ast) {
    var extensionDefs = ast.definitions.filter(function (def) {
        return def.kind !== Kind$1.OBJECT_TYPE_EXTENSION &&
            def.kind !== Kind$1.INTERFACE_TYPE_EXTENSION &&
            def.kind !== Kind$1.INPUT_OBJECT_TYPE_EXTENSION &&
            def.kind !== Kind$1.UNION_TYPE_EXTENSION &&
            def.kind !== Kind$1.ENUM_TYPE_EXTENSION &&
            def.kind !== Kind$1.SCALAR_TYPE_EXTENSION &&
            def.kind !== Kind$1.SCHEMA_EXTENSION;
    });
    return __assign(__assign({}, ast), { definitions: extensionDefs });
}

function concatenateTypeDefs(typeDefinitionsAry, calledFunctionRefs) {
    if (calledFunctionRefs === void 0) { calledFunctionRefs = []; }
    var resolvedTypeDefinitions = [];
    typeDefinitionsAry.forEach(function (typeDef) {
        if (typeof typeDef === 'function') {
            if (calledFunctionRefs.indexOf(typeDef) === -1) {
                calledFunctionRefs.push(typeDef);
                resolvedTypeDefinitions = resolvedTypeDefinitions.concat(concatenateTypeDefs(typeDef(), calledFunctionRefs));
            }
        }
        else if (typeof typeDef === 'string') {
            resolvedTypeDefinitions.push(typeDef.trim());
        }
        else if (typeDef.kind !== undefined) {
            resolvedTypeDefinitions.push(print$1(typeDef).trim());
        }
        else {
            var type = typeof typeDef;
            throw new SchemaError("typeDef array must contain only strings and functions, got " + type);
        }
    });
    return uniq(resolvedTypeDefinitions.map(function (x) { return x.trim(); })).join('\n');
}
function uniq(array) {
    return array.reduce(function (accumulator, currentValue) {
        return accumulator.indexOf(currentValue) === -1
            ? __spreadArrays(accumulator, [currentValue]) : accumulator;
    }, []);
}

function buildSchemaFromTypeDefinitions(typeDefinitions, parseOptions) {
    // TODO: accept only array here, otherwise interfaces get confusing.
    var myDefinitions = typeDefinitions;
    var astDocument;
    if (isDocumentNode(typeDefinitions)) {
        astDocument = typeDefinitions;
    }
    else if (typeof myDefinitions !== 'string') {
        if (!Array.isArray(myDefinitions)) {
            var type = typeof myDefinitions;
            throw new SchemaError("typeDefs must be a string, array or schema AST, got " + type);
        }
        myDefinitions = concatenateTypeDefs(myDefinitions);
    }
    if (typeof myDefinitions === 'string') {
        astDocument = parse(myDefinitions, parseOptions);
    }
    var typesAst = filterExtensionDefinitions(astDocument);
    var backcompatOptions = { commentDescriptions: true };
    var schema = buildASTSchema(typesAst, backcompatOptions);
    var extensionsAst = extractExtensionDefinitions(astDocument);
    if (extensionsAst.definitions.length > 0) {
        schema = extendSchema$1(schema, extensionsAst, backcompatOptions);
    }
    return schema;
}
function isDocumentNode(typeDefinitions) {
    return typeDefinitions.kind !== undefined;
}

function chainResolvers(resolvers) {
    return function (root, args, ctx, info) {
        return resolvers.reduce(function (prev, curResolver) {
            if (curResolver != null) {
                return curResolver(prev, args, ctx, info);
            }
            return defaultFieldResolver(prev, args, ctx, info);
        }, root);
    };
}

/*
 * fn: The function to decorate with the logger
 * logger: an object instance of type Logger
 * hint: an optional hint to add to the error's message
 */
function decorateWithLogger(fn, logger, hint) {
    var resolver = fn != null ? fn : defaultFieldResolver;
    var logError = function (e) {
        // TODO: clone the error properly
        var newE = new Error();
        newE.stack = e.stack;
        /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */
        if (hint) {
            newE['originalMessage'] = e.message;
            newE['message'] = "Error in resolver " + hint + "\n" + e.message;
        }
        logger.log(newE);
    };
    return function (root, args, ctx, info) {
        try {
            var result = resolver(root, args, ctx, info);
            // If the resolver returns a Promise log any Promise rejects.
            if (result &&
                typeof result.then === 'function' &&
                typeof result.catch === 'function') {
                result.catch(function (reason) {
                    // make sure that it's an error we're logging.
                    var error = reason instanceof Error ? reason : new Error(reason);
                    logError(error);
                    // We don't want to leave an unhandled exception so pass on error.
                    return reason;
                });
            }
            return result;
        }
        catch (e) {
            logError(e);
            // we want to pass on the error, just in case.
            throw e;
        }
    };
}

function makeExecutableSchema(_a) {
    var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, connectors = _a.connectors, logger = _a.logger, _c = _a.allowUndefinedInResolve, allowUndefinedInResolve = _c === void 0 ? true : _c, _d = _a.resolverValidationOptions, resolverValidationOptions = _d === void 0 ? {} : _d, directiveResolvers = _a.directiveResolvers, schemaDirectives = _a.schemaDirectives, _e = _a.parseOptions, parseOptions = _e === void 0 ? {} : _e, _f = _a.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _f === void 0 ? false : _f;
    // Validate and clean up arguments
    if (typeof resolverValidationOptions !== 'object') {
        throw new SchemaError('Expected `resolverValidationOptions` to be an object');
    }
    if (!typeDefs) {
        throw new SchemaError('Must provide typeDefs');
    }
    // We allow passing in an array of resolver maps, in which case we merge them
    var resolverMap = Array.isArray(resolvers)
        ? resolvers
            .filter(function (resolverObj) { return typeof resolverObj === 'object'; })
            .reduce(mergeDeep, {})
        : resolvers;
    // Arguments are now validated and cleaned up
    var schema = buildSchemaFromTypeDefinitions(typeDefs, parseOptions);
    addResolversToSchema({
        schema: schema,
        resolvers: resolverMap,
        resolverValidationOptions: resolverValidationOptions,
        inheritResolversFromInterfaces: inheritResolversFromInterfaces,
    });
    assertResolversPresent(schema, resolverValidationOptions);
    if (!allowUndefinedInResolve) {
        addCatchUndefinedToSchema(schema);
    }
    if (logger != null) {
        addErrorLoggingToSchema(schema, logger);
    }
    if (typeof resolvers['__schema'] === 'function') {
        // TODO a bit of a hack now, better rewrite generateSchema to attach it there.
        // not doing that now, because I'd have to rewrite a lot of tests.
        addSchemaLevelResolver(schema, resolvers['__schema']);
    }
    if (connectors != null) {
        // connectors are optional, at least for now. That means you can just import them in the resolve
        // function if you want.
        attachConnectorsToContext(schema, connectors);
    }
    if (directiveResolvers != null) {
        attachDirectiveResolvers(schema, directiveResolvers);
    }
    if (schemaDirectives != null) {
        SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);
    }
    return schema;
}
function decorateToCatchUndefined(fn, hint) {
    var resolve = fn == null ? defaultFieldResolver : fn;
    return function (root, args, ctx, info) {
        var result = resolve(root, args, ctx, info);
        if (typeof result === 'undefined') {
            throw new Error("Resolver for \"" + hint + "\" returned undefined");
        }
        return result;
    };
}
function addCatchUndefinedToSchema(schema) {
    forEachField(schema, function (field, typeName, fieldName) {
        var errorHint = typeName + "." + fieldName;
        field.resolve = decorateToCatchUndefined(field.resolve, errorHint);
    });
}
function addErrorLoggingToSchema(schema, logger) {
    if (!logger) {
        throw new Error('Must provide a logger');
    }
    if (typeof logger.log !== 'function') {
        throw new Error('Logger.log must be a function');
    }
    forEachField(schema, function (field, typeName, fieldName) {
        var errorHint = typeName + "." + fieldName;
        field.resolve = decorateWithLogger(field.resolve, logger, errorHint);
    });
}

// These functions are preserved for backwards compatibility.
// They are not simply rexported with new (old) names so as to allow
// typedoc to annotate them.
function addResolveFunctionsToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
    return addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions);
}
function addSchemaLevelResolveFunction(schema, fn) {
    addSchemaLevelResolver(schema, fn);
}
function assertResolveFunctionsPresent(schema, resolverValidationOptions) {
    if (resolverValidationOptions === void 0) { resolverValidationOptions = {}; }
    assertResolversPresent(schema, resolverValidationOptions);
}

/* eslint-disable import/no-nodejs-modules */
var hasOwn$5 = Object.prototype.hasOwnProperty;
var FormData = /** @class */ (function (_super) {
    __extends(FormData, _super);
    function FormData(options) {
        var _this = _super.call(this, options) || this;
        _this.hasUnknowableLength = false;
        return _this;
    }
    FormData.prototype.append = function (key, value, optionsOrFilename) {
        if (optionsOrFilename === void 0) { optionsOrFilename = {}; }
        // allow filename as single option
        var options = typeof optionsOrFilename === 'string'
            ? { filename: optionsOrFilename }
            : optionsOrFilename;
        // empty or either doesn't have path or not an http response
        if (!options.knownLength &&
            !Buffer.isBuffer(value) &&
            typeof value !== 'string' &&
            !value.path &&
            !(value.readable && hasOwn$5.call(value, 'httpVersion'))) {
            this.hasUnknowableLength = true;
        }
        _super.prototype.append.call(this, key, value, options);
    };
    FormData.prototype.getLength = function (callback) {
        if (this.hasUnknowableLength) {
            return null;
        }
        return _super.prototype.getLength.call(this, callback);
    };
    FormData.prototype.getLengthSync = function () {
        if (this.hasUnknowableLength) {
            return null;
        }
        // eslint-disable-next-line no-sync
        return _super.prototype.getLengthSync.call(this);
    };
    return FormData;
}(KnownLengthFormData));
var createServerHttpLink = function (linkOptions) {
    if (linkOptions === void 0) { linkOptions = {}; }
    var _a = linkOptions.uri, uri = _a === void 0 ? '/graphql' : _a, _b = linkOptions.fetch, customFetch = _b === void 0 ? fetch : _b, _c = linkOptions.serializer, customSerializer = _c === void 0 ? defaultSerializer : _c, _d = linkOptions.appendFile, customAppendFile = _d === void 0 ? defaultAppendFile : _d, includeExtensions = linkOptions.includeExtensions, useGETForQueries = linkOptions.useGETForQueries, requestOptions = __rest(linkOptions, ["uri", "fetch", "serializer", "appendFile", "includeExtensions", "useGETForQueries"]);
    var linkConfig = {
        http: { includeExtensions: includeExtensions },
        options: requestOptions.fetchOptions,
        credentials: requestOptions.credentials,
        headers: requestOptions.headers,
    };
    return new ApolloLink(function (operation) {
        var chosenURI = selectURI(operation, uri);
        var context = operation.getContext();
        // `apollographql-client-*` headers are automatically set if a
        // `clientAwareness` object is found in the context. These headers are
        // set first, followed by the rest of the headers pulled from
        // `context.headers`. If desired, `apollographql-client-*` headers set by
        // the `clientAwareness` object can be overridden by
        // `apollographql-client-*` headers set in `context.headers`.
        var clientAwarenessHeaders = {};
        if (context.clientAwareness) {
            var _a = context.clientAwareness, name_1 = _a.name, version = _a.version;
            if (name_1) {
                clientAwarenessHeaders['apollographql-client-name'] = name_1;
            }
            if (version) {
                clientAwarenessHeaders['apollographql-client-version'] = version;
            }
        }
        var contextHeaders = __assign(__assign({}, clientAwarenessHeaders), context.headers);
        var contextConfig = {
            http: context.http,
            options: context.fetchOptions,
            credentials: context.credentials,
            headers: contextHeaders,
        };
        // uses fallback, link, and then context to build options
        var _b = selectHttpOptionsAndBody(operation, fallbackHttpConfig, linkConfig, contextConfig), options = _b.options, body = _b.body;
        var controller;
        if (!options.signal) {
            var _c = createSignalIfSupported(), _controller = _c.controller, signal = _c.signal;
            controller = _controller;
            if (controller) {
                options.signal = signal;
            }
        }
        // If requested, set method to GET if there are no mutations.
        var definitionIsMutation = function (d) {
            return d.kind === 'OperationDefinition' && d.operation === 'mutation';
        };
        if (useGETForQueries &&
            !operation.query.definitions.some(definitionIsMutation)) {
            options.method = 'GET';
        }
        if (options.method === 'GET') {
            var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;
            if (parseError) {
                return fromError(parseError);
            }
            chosenURI = newURI;
        }
        return new Observable(function (observer) {
            getFinalPromise(body)
                .then(function (resolvedBody) {
                if (options.method !== 'GET') {
                    options.body = customSerializer(resolvedBody, customAppendFile);
                    if (options.body instanceof FormData) {
                        // Automatically set by fetch when the body is a FormData instance.
                        delete options.headers['content-type'];
                    }
                }
                return options;
            })
                .then(function (newOptions) { return customFetch(chosenURI, newOptions); })
                .then(function (response) {
                operation.setContext({ response: response });
                return response;
            })
                .then(parseAndCheckHttpResponse(operation))
                .then(function (result) {
                // we have data and can send it to back up the link chain
                observer.next(result);
                observer.complete();
                return result;
            })
                .catch(function (err) {
                // fetch was cancelled so it's already been cleaned up in the unsubscribe
                if (err.name === 'AbortError') {
                    return;
                }
                // if it is a network error, BUT there is graphql result info
                // fire the next observer before calling error
                // this gives apollo-client (and react-apollo) the `graphqlErrors` and `networErrors`
                // to pass to UI
                // this should only happen if we *also* have data as part of the response key per
                // the spec
                if (err.result && err.result.errors && err.result.data) {
                    // if we don't call next, the UI can only show networkError because AC didn't
                    // get any graphqlErrors
                    // this is graphql execution result info (i.e errors and possibly data)
                    // this is because there is no formal spec how errors should translate to
                    // http status codes. So an auth error (401) could have both data
                    // from a public field, errors from a private field, and a status of 401
                    // {
                    //  user { // this will have errors
                    //    firstName
                    //  }
                    //  products { // this is public so will have data
                    //    cost
                    //  }
                    // }
                    //
                    // the result of above *could* look like this:
                    // {
                    //   data: { products: [{ cost: "$10" }] },
                    //   errors: [{
                    //      message: 'your session has timed out',
                    //      path: []
                    //   }]
                    // }
                    // status code of above would be a 401
                    // in the UI you want to show data where you can, errors as data where you can
                    // and use correct http status codes
                    observer.next(err.result);
                }
                observer.error(err);
            });
            return function () {
                // XXX support canceling this request
                // https://developers.google.com/web/updates/2017/09/abortable-fetch
                if (controller) {
                    controller.abort();
                }
            };
        });
    });
};
// For GET operations, returns the given URI rewritten with parameters, or a
// parse error.
function rewriteURIForGET(chosenURI, body) {
    // Implement the standard HTTP GET serialization, plus 'extensions'. Note
    // the extra level of JSON serialization!
    var queryParams = [];
    var addQueryParam = function (key, value) {
        queryParams.push(key + "=" + encodeURIComponent(value));
    };
    if ('query' in body) {
        addQueryParam('query', body.query);
    }
    if (body.operationName) {
        addQueryParam('operationName', body.operationName);
    }
    if (body.variables != null) {
        var serializedVariables = void 0;
        try {
            serializedVariables = serializeFetchParameter(body.variables, 'Variables map');
        }
        catch (parseError) {
            return { parseError: parseError };
        }
        addQueryParam('variables', serializedVariables);
    }
    if (body.extensions != null) {
        var serializedExtensions = void 0;
        try {
            serializedExtensions = serializeFetchParameter(body.extensions, 'Extensions map');
        }
        catch (parseError) {
            return { parseError: parseError };
        }
        addQueryParam('extensions', serializedExtensions);
    }
    // Reconstruct the URI with added query params.
    // XXX This assumes that the URI is well-formed and that it doesn't
    //     already contain any of these query params. We could instead use the
    //     URL API and take a polyfill (whatwg-url@6) for older browsers that
    //     don't support URLSearchParams. Note that some browsers (and
    //     versions of whatwg-url) support URL but not URLSearchParams!
    var fragment = '';
    var preFragment = chosenURI;
    var fragmentStart = chosenURI.indexOf('#');
    if (fragmentStart !== -1) {
        fragment = chosenURI.substr(fragmentStart);
        preFragment = chosenURI.substr(0, fragmentStart);
    }
    var queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';
    var newURI = preFragment + queryParamsPrefix + queryParams.join('&') + fragment;
    return { newURI: newURI };
}
function getFinalPromise(object) {
    return Promise.resolve(object).then(function (resolvedObject) {
        if (resolvedObject == null) {
            return resolvedObject;
        }
        if (Array.isArray(resolvedObject)) {
            return Promise.all(resolvedObject.map(function (o) { return getFinalPromise(o); }));
        }
        else if (typeof resolvedObject === 'object') {
            var keys_1 = Object.keys(resolvedObject);
            return Promise.all(keys_1.map(function (key) { return getFinalPromise(resolvedObject[key]); })).then(function (awaitedValues) {
                for (var i = 0; i < keys_1.length; i++) {
                    resolvedObject[keys_1[i]] = awaitedValues[i];
                }
                return resolvedObject;
            });
        }
        return resolvedObject;
    });
}
function defaultSerializer(body, appendFile) {
    var _a = extractFiles(body, undefined, function (value) { return isExtractableFile(value) || (value === null || value === void 0 ? void 0 : value.createReadStream); }), clone = _a.clone, files = _a.files;
    var payload = serializeFetchParameter(clone, 'Payload');
    if (!files.size) {
        return payload;
    }
    // GraphQL multipart request spec:
    // https://github.com/jaydenseric/graphql-multipart-request-spec
    var form = new FormData();
    form.append('operations', payload);
    var map = {};
    var i = 0;
    files.forEach(function (paths) {
        map[++i] = paths;
    });
    form.append('map', JSON.stringify(map));
    i = 0;
    files.forEach(function (_paths, file) {
        appendFile(form, (++i).toString(), file);
    });
    return form;
}
function defaultAppendFile(form, index, file) {
    if (file.createReadStream != null) {
        form.append(index, file.createReadStream(), {
            filename: file.filename,
            contentType: file.mimetype,
        });
    }
    else {
        form.append(index, file, file.name);
    }
}
var ServerHttpLink = /** @class */ (function (_super) {
    __extends(ServerHttpLink, _super);
    function ServerHttpLink(opts) {
        return _super.call(this, createServerHttpLink(opts).request) || this;
    }
    return ServerHttpLink;
}(ApolloLink));

/**
 * This function wraps addMocksToSchema for more convenience
 */
function mockServer(schema, mocks, preserveResolvers) {
    if (preserveResolvers === void 0) { preserveResolvers = false; }
    var mySchema;
    if (!isSchema(schema)) {
        // TODO: provide useful error messages here if this fails
        mySchema = buildSchemaFromTypeDefinitions(schema);
    }
    else {
        mySchema = schema;
    }
    addMocksToSchema({ schema: mySchema, mocks: mocks, preserveResolvers: preserveResolvers });
    return { query: function (query, vars) { return graphql(mySchema, query, {}, {}, vars); } };
}
var defaultMockMap = new Map();
defaultMockMap.set('Int', function () { return Math.round(Math.random() * 200) - 100; });
defaultMockMap.set('Float', function () { return Math.random() * 200 - 100; });
defaultMockMap.set('String', function () { return 'Hello World'; });
defaultMockMap.set('Boolean', function () { return Math.random() > 0.5; });
defaultMockMap.set('ID', function () { return v4(); });
// TODO allow providing a seed such that lengths of list could be deterministic
// this could be done by using casual to get a random list length if the casual
// object is global.
function addMocksToSchema(_a) {
    var schema = _a.schema, _b = _a.mocks, mocks = _b === void 0 ? {} : _b, _c = _a.preserveResolvers, preserveResolvers = _c === void 0 ? false : _c;
    if (!schema) {
        throw new Error('Must provide schema to mock');
    }
    if (!isSchema(schema)) {
        throw new Error('Value at "schema" must be of type GraphQLSchema');
    }
    if (!isObject$1(mocks)) {
        throw new Error('mocks must be of type Object');
    }
    // use Map internally, because that API is nicer.
    var mockFunctionMap = new Map();
    Object.keys(mocks).forEach(function (typeName) {
        mockFunctionMap.set(typeName, mocks[typeName]);
    });
    mockFunctionMap.forEach(function (mockFunction, mockTypeName) {
        if (typeof mockFunction !== 'function') {
            throw new Error("mockFunctionMap[" + mockTypeName + "] must be a function");
        }
    });
    var mockType = function (type, _typeName, fieldName) {
        // order of precendence for mocking:
        // 1. if the object passed in already has fieldName, just use that
        // --> if it's a function, that becomes your resolver
        // --> if it's a value, the mock resolver will return that
        // 2. if the nullableType is a list, recurse
        // 2. if there's a mock defined for this typeName, that will be used
        // 3. if there's no mock defined, use the default mocks for this type
        return function (root, args, context, info) {
            // nullability doesn't matter for the purpose of mocking.
            var fieldType = getNullableType(type);
            var namedFieldType = getNamedType(fieldType);
            if (fieldName && root && typeof root[fieldName] !== 'undefined') {
                var result = void 0;
                // if we're here, the field is already defined
                if (typeof root[fieldName] === 'function') {
                    result = root[fieldName](root, args, context, info);
                    if (result instanceof MockList) {
                        result = result.mock(root, args, context, info, fieldType, mockType);
                    }
                }
                else {
                    result = root[fieldName];
                }
                // Now we merge the result with the default mock for this type.
                // This allows overriding defaults while writing very little code.
                if (mockFunctionMap.has(namedFieldType.name)) {
                    var mock = mockFunctionMap.get(namedFieldType.name);
                    result = mergeMocks(mock.bind(null, root, args, context, info), result);
                }
                return result;
            }
            if (isListType$1(fieldType)) {
                return [
                    mockType(fieldType.ofType)(root, args, context, info),
                    mockType(fieldType.ofType)(root, args, context, info),
                ];
            }
            if (mockFunctionMap.has(fieldType.name) && !isAbstractType$1(fieldType)) {
                // the object passed doesn't have this field, so we apply the default mock
                var mock = mockFunctionMap.get(fieldType.name);
                return mock(root, args, context, info);
            }
            if (isObjectType$1(fieldType)) {
                // objects don't return actual data, we only need to mock scalars!
                return {};
            }
            // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type
            // otherwise randomly pick a type from all implementation types
            if (isAbstractType$1(fieldType)) {
                var implementationType = void 0;
                if (mockFunctionMap.has(fieldType.name)) {
                    var mock = mockFunctionMap.get(fieldType.name);
                    var interfaceMockObj = mock(root, args, context, info);
                    if (!interfaceMockObj || !interfaceMockObj.__typename) {
                        return Error("Please return a __typename in \"" + fieldType.name + "\"");
                    }
                    implementationType = schema.getType(interfaceMockObj.__typename);
                }
                else {
                    var possibleTypes = schema.getPossibleTypes(fieldType);
                    implementationType = getRandomElement(possibleTypes);
                }
                return __assign({ __typename: implementationType }, mockType(implementationType)(root, args, context, info));
            }
            if (isEnumType$1(fieldType)) {
                return getRandomElement(fieldType.getValues()).value;
            }
            if (defaultMockMap.has(fieldType.name)) {
                var defaultMock = defaultMockMap.get(fieldType.name);
                return defaultMock(root, args, context, info);
            }
            // if we get to here, we don't have a value, and we don't have a mock for this type,
            // we could return undefined, but that would be hard to debug, so we throw instead.
            // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.
            return Error("No mock defined for type \"" + fieldType.name + "\"");
        };
    };
    forEachField(schema, function (field, typeName, fieldName) {
        assignResolveType(field.type, preserveResolvers);
        var mockResolver = mockType(field.type, typeName, fieldName);
        // we have to handle the root mutation and root query types differently,
        // because no resolver is called at the root.
        var queryType = schema.getQueryType();
        var isOnQueryType = queryType != null && queryType.name === typeName;
        var mutationType = schema.getMutationType();
        var isOnMutationType = mutationType != null && mutationType.name === typeName;
        if (isOnQueryType || isOnMutationType) {
            if (mockFunctionMap.has(typeName)) {
                var rootMock_1 = mockFunctionMap.get(typeName);
                // XXX: BUG in here, need to provide proper signature for rootMock.
                if (typeof rootMock_1(undefined, {}, {}, {})[fieldName] ===
                    'function') {
                    mockResolver = function (root, args, context, info) {
                        var updatedRoot = root !== null && root !== void 0 ? root : {}; // TODO: should we clone instead?
                        updatedRoot[fieldName] = rootMock_1(root, args, context, info)[fieldName];
                        // XXX this is a bit of a hack to still use mockType, which
                        // lets you mock lists etc. as well
                        // otherwise we could just set field.resolve to rootMock()[fieldName]
                        // it's like pretending there was a resolver that ran before
                        // the root resolver.
                        return mockType(field.type, typeName, fieldName)(updatedRoot, args, context, info);
                    };
                }
            }
        }
        if (!preserveResolvers || !field.resolve) {
            field.resolve = mockResolver;
        }
        else {
            var oldResolver_1 = field.resolve;
            field.resolve = function (rootObject, args, context, info) {
                return Promise.all([
                    mockResolver(rootObject, args, context, info),
                    oldResolver_1(rootObject, args, context, info),
                ]).then(function (values) {
                    var mockedValue = values[0], resolvedValue = values[1];
                    // In case we couldn't mock
                    if (mockedValue instanceof Error) {
                        // only if value was not resolved, populate the error.
                        if (undefined === resolvedValue) {
                            throw mockedValue;
                        }
                        return resolvedValue;
                    }
                    if (resolvedValue instanceof Date && mockedValue instanceof Date) {
                        return undefined !== resolvedValue ? resolvedValue : mockedValue;
                    }
                    if (isObject$1(mockedValue) && isObject$1(resolvedValue)) {
                        // Object.assign() won't do here, as we need to all properties, including
                        // the non-enumerable ones and defined using Object.defineProperty
                        var emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));
                        return copyOwnProps(emptyObject, resolvedValue, mockedValue);
                    }
                    return undefined !== resolvedValue ? resolvedValue : mockedValue;
                });
            };
        }
    });
}
function isObject$1(thing) {
    return thing === Object(thing) && !Array.isArray(thing);
}
// returns a random element from that ary
function getRandomElement(ary) {
    var sample = Math.floor(Math.random() * ary.length);
    return ary[sample];
}
function mergeObjects(a, b) {
    return Object.assign(a, b);
}
function copyOwnPropsIfNotPresent(target, source) {
    Object.getOwnPropertyNames(source).forEach(function (prop) {
        if (!Object.getOwnPropertyDescriptor(target, prop)) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
            Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);
        }
    });
}
function copyOwnProps(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    sources.forEach(function (source) {
        var chain = source;
        while (chain != null) {
            copyOwnPropsIfNotPresent(target, chain);
            chain = Object.getPrototypeOf(chain);
        }
    });
    return target;
}
// takes either an object or a (possibly nested) array
// and completes the customMock object with any fields
// defined on genericMock
// only merges objects or arrays. Scalars are returned as is
function mergeMocks(genericMockFunction, customMock) {
    if (Array.isArray(customMock)) {
        return customMock.map(function (el) { return mergeMocks(genericMockFunction, el); });
    }
    if (isObject$1(customMock)) {
        return mergeObjects(genericMockFunction(), customMock);
    }
    return customMock;
}
function getResolveType(namedFieldType) {
    if (isAbstractType$1(namedFieldType)) {
        return namedFieldType.resolveType;
    }
}
function assignResolveType(type, preserveResolvers) {
    var fieldType = getNullableType(type);
    var namedFieldType = getNamedType(fieldType);
    var oldResolveType = getResolveType(namedFieldType);
    if (preserveResolvers && oldResolveType != null && oldResolveType.length) {
        return;
    }
    if (isInterfaceType$1(namedFieldType) || isUnionType$1(namedFieldType)) {
        // the default `resolveType` always returns null. We add a fallback
        // resolution that works with how unions and interface are mocked
        namedFieldType.resolveType = function (data, _context, info) { return info.schema.getType(data.__typename); };
    }
}
var MockList = /** @class */ (function () {
    // wrappedFunction can return another MockList or a value
    function MockList(len, wrappedFunction) {
        this.len = len;
        if (typeof wrappedFunction !== 'undefined') {
            if (typeof wrappedFunction !== 'function') {
                throw new Error('Second argument to MockList must be a function or undefined');
            }
            this.wrappedFunction = wrappedFunction;
        }
    }
    MockList.prototype.mock = function (root, args, context, info, fieldType, mockTypeFunc) {
        var arr;
        if (Array.isArray(this.len)) {
            arr = new Array(this.randint(this.len[0], this.len[1]));
        }
        else {
            arr = new Array(this.len);
        }
        for (var i = 0; i < arr.length; i++) {
            if (typeof this.wrappedFunction === 'function') {
                var res = this.wrappedFunction(root, args, context, info);
                if (res instanceof MockList) {
                    var nullableType = getNullableType(fieldType.ofType);
                    arr[i] = res.mock(root, args, context, info, nullableType, mockTypeFunc);
                }
                else {
                    arr[i] = res;
                }
            }
            else {
                arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);
            }
        }
        return arr;
    };
    MockList.prototype.randint = function (low, high) {
        return Math.floor(Math.random() * (high - low + 1) + low);
    };
    return MockList;
}());
// retain addMockFunctionsToSchema for backwards compatibility
function addMockFunctionsToSchema(_a) {
    var schema = _a.schema, _b = _a.mocks, mocks = _b === void 0 ? {} : _b, _c = _a.preserveResolvers, preserveResolvers = _c === void 0 ? false : _c;
    addMocksToSchema({ schema: schema, mocks: mocks, preserveResolvers: preserveResolvers });
}

var GraphQLUpload = new GraphQLScalarType$1({
    name: 'Upload',
    description: 'The `Upload` scalar type represents a file upload.',
    parseValue: function (value) {
        if (value != null && value.promise instanceof Promise) {
            // graphql-upload v10
            return value.promise;
        }
        else if (value instanceof Promise) {
            // graphql-upload v9
            return value;
        }
        throw new GraphQLError$1('Upload value invalid.');
    },
    // serialization requires to support schema stitching
    serialize: function (value) { return value; },
    parseLiteral: function (ast) {
        throw new GraphQLError$1('Upload literal unsupported.', ast);
    },
});

var parsedIntrospectionQuery = parse(getIntrospectionQuery());
function introspectSchema(linkOrFetcher, linkContext) {
    var fetcher = linkOrFetcher instanceof ApolloLink
        ? linkToFetcher(linkOrFetcher)
        : linkOrFetcher;
    return fetcher({
        query: parsedIntrospectionQuery,
        context: linkContext,
    }).then(function (introspectionResult) {
        if ((Array.isArray(introspectionResult.errors) &&
            introspectionResult.errors.length) ||
            !introspectionResult.data.__schema) {
            if (Array.isArray(introspectionResult.errors)) {
                var combinedError = combineErrors(introspectionResult.errors);
                throw combinedError;
            }
            else {
                throw new Error('Could not obtain introspection result, received: ' +
                    JSON.stringify(introspectionResult));
            }
        }
        else {
            var schema = buildClientSchema(introspectionResult.data);
            return schema;
        }
    });
}

/**
 * Resolver that knows how to:
 * a) handle aliases for proxied schemas
 * b) handle errors from proxied schemas
 * c) handle external to internal enum coversion
 */
function defaultMergedResolver(parent, args, context, info) {
    if (!parent) {
        return null;
    }
    var responseKey = getResponseKeyFromInfo(info);
    var errors = getErrors(parent, responseKey);
    // check to see if parent is not a proxied result, i.e. if parent resolver was manually overwritten
    // See https://github.com/apollographql/graphql-tools/issues/967
    if (!errors) {
        return defaultFieldResolver(parent, args, context, info);
    }
    var result = parent[responseKey];
    var subschema = getSubschema(parent, responseKey);
    return handleResult(result, errors, subschema, context, info);
}

function makeMergedType(type) {
    if (isObjectType$1(type)) {
        type.isTypeOf = undefined;
        var fieldMap_1 = type.getFields();
        Object.keys(fieldMap_1).forEach(function (fieldName) {
            fieldMap_1[fieldName].resolve = defaultMergedResolver;
            fieldMap_1[fieldName].subscribe = null;
        });
    }
    else if (isAbstractType$1(type)) {
        type.resolveType = function (parent) { return resolveFromParentTypename(parent); };
    }
}

function generateProxyingResolvers(_a) {
    var subschemaConfig = _a.subschemaConfig, transforms = _a.transforms, _b = _a.createProxyingResolver, createProxyingResolver = _b === void 0 ? defaultCreateProxyingResolver : _b;
    var targetSchema = subschemaConfig.schema;
    var mapping = generateSimpleMapping(targetSchema);
    var result = {};
    Object.keys(mapping).forEach(function (name) {
        result[name] = {};
        var innerMapping = mapping[name];
        Object.keys(innerMapping).forEach(function (from) {
            var _a;
            var to = innerMapping[from];
            var resolverType = to.operation === 'subscription' ? 'subscribe' : 'resolve';
            result[name][from] = (_a = {},
                _a[resolverType] = createProxyingResolver({
                    schema: subschemaConfig,
                    transforms: transforms,
                    operation: to.operation,
                    fieldName: to.name,
                }),
                _a);
        });
    });
    return result;
}
function generateSimpleMapping(targetSchema) {
    var query = targetSchema.getQueryType();
    var mutation = targetSchema.getMutationType();
    var subscription = targetSchema.getSubscriptionType();
    var result = {};
    if (query != null) {
        result[query.name] = generateMappingFromObjectType(query, 'query');
    }
    if (mutation != null) {
        result[mutation.name] = generateMappingFromObjectType(mutation, 'mutation');
    }
    if (subscription != null) {
        result[subscription.name] = generateMappingFromObjectType(subscription, 'subscription');
    }
    return result;
}
function generateMappingFromObjectType(type, operation) {
    var result = {};
    var fields = type.getFields();
    Object.keys(fields).forEach(function (fieldName) {
        result[fieldName] = {
            name: fieldName,
            operation: operation,
        };
    });
    return result;
}
function defaultCreateProxyingResolver(_a) {
    var schema = _a.schema, transforms = _a.transforms;
    return function (parent, _args, context, info) {
        if (parent != null) {
            var responseKey = getResponseKeyFromInfo(info);
            var errors = getErrors(parent, responseKey);
            if (errors != null) {
                var subschema = getSubschema(parent, responseKey);
                // if parent contains a proxied result from this subschema, can return that result
                if (schema === subschema) {
                    var result = parent[responseKey];
                    return handleResult(result, errors, subschema, context, info);
                }
            }
        }
        return delegateToSchema({
            schema: schema,
            context: context,
            info: info,
            transforms: transforms,
        });
    };
}
function stripResolvers(schema) {
    var typeMap = schema.getTypeMap();
    Object.keys(typeMap).forEach(function (typeName) {
        if (!typeName.startsWith('__')) {
            makeMergedType(typeMap[typeName]);
        }
    });
}

function wrapSchema(subschemaOrSubschemaConfig, transforms) {
    var subschemaConfig = isSubschemaConfig(subschemaOrSubschemaConfig)
        ? subschemaOrSubschemaConfig
        : { schema: subschemaOrSubschemaConfig };
    var schema = cloneSchema(subschemaConfig.schema);
    stripResolvers(schema);
    addResolversToSchema({
        schema: schema,
        resolvers: generateProxyingResolvers({ subschemaConfig: subschemaConfig, transforms: transforms }),
        resolverValidationOptions: {
            allowResolversNotInSchema: true,
        },
    });
    var schemaTransforms = [];
    if (subschemaConfig.transforms != null) {
        schemaTransforms = schemaTransforms.concat(subschemaConfig.transforms);
    }
    if (transforms != null) {
        schemaTransforms = schemaTransforms.concat(transforms);
    }
    return applySchemaTransforms(schema, schemaTransforms);
}

var backcompatOptions = { commentDescriptions: true };
function typeFromAST$1(node) {
    switch (node.kind) {
        case Kind$1.OBJECT_TYPE_DEFINITION:
            return makeObjectType(node);
        case Kind$1.INTERFACE_TYPE_DEFINITION:
            return makeInterfaceType(node);
        case Kind$1.ENUM_TYPE_DEFINITION:
            return makeEnumType(node);
        case Kind$1.UNION_TYPE_DEFINITION:
            return makeUnionType(node);
        case Kind$1.SCALAR_TYPE_DEFINITION:
            return makeScalarType(node);
        case Kind$1.INPUT_OBJECT_TYPE_DEFINITION:
            return makeInputObjectType(node);
        case Kind$1.DIRECTIVE_DEFINITION:
            return makeDirective(node);
        default:
            return null;
    }
}
function makeObjectType(node) {
    var config = {
        name: node.name.value,
        fields: function () { return makeFields(node.fields); },
        interfaces: function () {
            return node.interfaces.map(function (iface) {
                return createNamedStub(iface.name.value, 'interface');
            });
        },
        description: getDescription(node, backcompatOptions),
    };
    return new GraphQLObjectType$1(config);
}
function makeInterfaceType(node) {
    var config = {
        name: node.name.value,
        fields: function () { return makeFields(node.fields); },
        interfaces: graphqlVersion() >= 15
            ? function () {
                return node.interfaces.map(function (iface) {
                    return createNamedStub(iface.name.value, 'interface');
                });
            }
            : undefined,
        description: getDescription(node, backcompatOptions),
        resolveType: function (parent) { return resolveFromParentTypename(parent); },
    };
    return new GraphQLInterfaceType$1(config);
}
function makeEnumType(node) {
    var values = {};
    node.values.forEach(function (value) {
        values[value.name.value] = {
            description: getDescription(value, backcompatOptions),
        };
    });
    return new GraphQLEnumType$1({
        name: node.name.value,
        values: values,
        description: getDescription(node, backcompatOptions),
    });
}
function makeUnionType(node) {
    return new GraphQLUnionType$1({
        name: node.name.value,
        types: function () {
            return node.types.map(function (type) { return resolveType(type, 'object'); });
        },
        description: getDescription(node, backcompatOptions),
        resolveType: function (parent) { return resolveFromParentTypename(parent); },
    });
}
function makeScalarType(node) {
    return new GraphQLScalarType$1({
        name: node.name.value,
        description: getDescription(node, backcompatOptions),
        serialize: function () { return null; },
        // Note: validation calls the parse functions to determine if a
        // literal value is correct. Returning null would cause use of custom
        // scalars to always fail validation. Returning false causes them to
        // always pass validation.
        parseValue: function () { return false; },
        parseLiteral: function () { return false; },
    });
}
function makeInputObjectType(node) {
    return new GraphQLInputObjectType$1({
        name: node.name.value,
        fields: function () { return makeValues(node.fields); },
        description: getDescription(node, backcompatOptions),
    });
}
function makeFields(nodes) {
    var result = {};
    nodes.forEach(function (node) {
        var deprecatedDirective = node.directives.find(function (directive) { return directive.name.value === 'deprecated'; });
        var deprecationReason;
        if (deprecatedDirective != null) {
            var deprecatedArgument = deprecatedDirective.arguments.find(function (arg) { return arg.name.value === 'reason'; });
            deprecationReason = deprecatedArgument.value.value;
        }
        result[node.name.value] = {
            type: resolveType(node.type, 'object'),
            args: makeValues(node.arguments),
            description: getDescription(node, backcompatOptions),
            deprecationReason: deprecationReason,
        };
    });
    return result;
}
function makeValues(nodes) {
    var result = {};
    nodes.forEach(function (node) {
        var type = resolveType(node.type, 'input');
        result[node.name.value] = {
            type: type,
            defaultValue: node.defaultValue,
            description: getDescription(node, backcompatOptions),
        };
    });
    return result;
}
function resolveType(node, type) {
    switch (node.kind) {
        case Kind$1.LIST_TYPE:
            return new GraphQLList$1(resolveType(node.type, type));
        case Kind$1.NON_NULL_TYPE:
            return new GraphQLNonNull$1(resolveType(node.type, type));
        default:
            return createNamedStub(node.name.value, type);
    }
}
function makeDirective(node) {
    var locations = [];
    node.locations.forEach(function (location) {
        if (location.value in DirectiveLocation$1) {
            locations.push(location.value);
        }
    });
    return new GraphQLDirective$1({
        name: node.name.value,
        description: node.description != null ? node.description.value : null,
        args: makeValues(node.arguments),
        locations: locations,
    });
}
// graphql < v13 does not export getDescription
function getDescription(node, options) {
    if (node.description != null) {
        return node.description.value;
    }
    if (options.commentDescriptions) {
        var rawValue = getLeadingCommentBlock(node);
        if (rawValue !== undefined) {
            return dedentBlockStringValue("\n" + rawValue);
        }
    }
}
function getLeadingCommentBlock(node) {
    var loc = node.loc;
    if (!loc) {
        return;
    }
    var comments = [];
    var token = loc.startToken.prev;
    while (token != null &&
        token.kind === TokenKind.COMMENT &&
        token.next != null &&
        token.prev != null &&
        token.line + 1 === token.next.line &&
        token.line !== token.prev.line) {
        var value = String(token.value);
        comments.push(value);
        token = token.prev;
    }
    return comments.length > 0 ? comments.reverse().join('\n') : undefined;
}
function dedentBlockStringValue(rawString) {
    // Expand a block string's raw value into independent lines.
    var lines = rawString.split(/\r\n|[\n\r]/g);
    // Remove common indentation from all lines but first.
    var commonIndent = getBlockStringIndentation(lines);
    if (commonIndent !== 0) {
        for (var i = 1; i < lines.length; i++) {
            lines[i] = lines[i].slice(commonIndent);
        }
    }
    // Remove leading and trailing blank lines.
    while (lines.length > 0 && isBlank(lines[0])) {
        lines.shift();
    }
    while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
        lines.pop();
    }
    // Return a string of the lines joined with U+000A.
    return lines.join('\n');
}
/**
 * @internal
 */
function getBlockStringIndentation(lines) {
    var commonIndent = null;
    for (var i = 1; i < lines.length; i++) {
        var line = lines[i];
        var indent = leadingWhitespace(line);
        if (indent === line.length) {
            continue; // skip empty lines
        }
        if (commonIndent === null || indent < commonIndent) {
            commonIndent = indent;
            if (commonIndent === 0) {
                break;
            }
        }
    }
    return commonIndent === null ? 0 : commonIndent;
}
function leadingWhitespace(str) {
    var i = 0;
    while (i < str.length && (str[i] === ' ' || str[i] === '\t')) {
        i++;
    }
    return i;
}
function isBlank(str) {
    return leadingWhitespace(str) === str.length;
}

function createMergeInfo(allSchemas, typeCandidates, mergeTypes) {
    return {
        delegate: function (operation, fieldName, args, context, info, transforms) {
            if (transforms === void 0) { transforms = []; }
            var schema = guessSchemaByRootField(allSchemas, operation, fieldName);
            var expandTransforms = new ExpandAbstractTypes(info.schema, schema);
            var fragmentTransform = new AddReplacementFragments(schema, info.mergeInfo.replacementFragments);
            return delegateToSchema({
                schema: schema,
                operation: operation,
                fieldName: fieldName,
                args: args,
                context: context,
                info: info,
                transforms: __spreadArrays(transforms, [expandTransforms, fragmentTransform]),
            });
        },
        delegateToSchema: function (options) {
            return delegateToSchema(__assign(__assign({}, options), { transforms: options.transforms }));
        },
        fragments: [],
        replacementSelectionSets: undefined,
        replacementFragments: undefined,
        mergedTypes: createMergedTypes(typeCandidates, mergeTypes),
    };
}
function createMergedTypes(typeCandidates, mergeTypes) {
    var mergedTypes = {};
    Object.keys(typeCandidates).forEach(function (typeName) {
        if (isObjectType$1(typeCandidates[typeName][0].type)) {
            var mergedTypeCandidates = typeCandidates[typeName].filter(function (typeCandidate) {
                return typeCandidate.subschema != null &&
                    isSubschemaConfig(typeCandidate.subschema) &&
                    typeCandidate.subschema.merge != null &&
                    typeCandidate.subschema.merge[typeName] != null;
            });
            if (mergeTypes === true ||
                (typeof mergeTypes === 'function' &&
                    mergeTypes(typeName, typeCandidates[typeName])) ||
                (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||
                mergedTypeCandidates.length) {
                var subschemas_1 = [];
                var requiredSelections_1 = [
                    parseSelectionSet('{ __typename }').selections[0],
                ];
                var fields_1 = Object.create({});
                var typeMaps_1 = new Map();
                var selectionSets_1 = new Map();
                mergedTypeCandidates.forEach(function (typeCandidate) {
                    var subschemaConfig = typeCandidate.subschema;
                    var transformedSubschema = typeCandidate.transformedSubschema;
                    typeMaps_1.set(subschemaConfig, transformedSubschema.getTypeMap());
                    var type = transformedSubschema.getType(typeName);
                    var fieldMap = type.getFields();
                    Object.keys(fieldMap).forEach(function (fieldName) {
                        if (fields_1[fieldName] == null) {
                            fields_1[fieldName] = [];
                        }
                        fields_1[fieldName].push(subschemaConfig);
                    });
                    var mergedTypeConfig = subschemaConfig.merge[typeName];
                    if (mergedTypeConfig.selectionSet) {
                        var selectionSet = parseSelectionSet(mergedTypeConfig.selectionSet);
                        requiredSelections_1 = requiredSelections_1.concat(selectionSet.selections);
                        selectionSets_1.set(subschemaConfig, selectionSet);
                    }
                    if (!mergedTypeConfig.resolve) {
                        mergedTypeConfig.resolve = function (originalResult, context, info, subschema, selectionSet) {
                            return delegateToSchema({
                                schema: subschema,
                                operation: 'query',
                                fieldName: mergedTypeConfig.fieldName,
                                args: mergedTypeConfig.args(originalResult),
                                selectionSet: selectionSet,
                                context: context,
                                info: info,
                                skipTypeMerging: true,
                            });
                        };
                    }
                    subschemas_1.push(subschemaConfig);
                });
                mergedTypes[typeName] = {
                    subschemas: subschemas_1,
                    typeMaps: typeMaps_1,
                    selectionSets: selectionSets_1,
                    containsSelectionSet: new Map(),
                    uniqueFields: Object.create({}),
                    nonUniqueFields: Object.create({}),
                };
                subschemas_1.forEach(function (subschema) {
                    var type = typeMaps_1.get(subschema)[typeName];
                    var subschemaMap = new Map();
                    subschemas_1
                        .filter(function (s) { return s !== subschema; })
                        .forEach(function (s) {
                        var selectionSet = selectionSets_1.get(s);
                        if (selectionSet != null &&
                            typeContainsSelectionSet(type, selectionSet)) {
                            subschemaMap.set(selectionSet, true);
                        }
                    });
                    mergedTypes[typeName].containsSelectionSet.set(subschema, subschemaMap);
                });
                Object.keys(fields_1).forEach(function (fieldName) {
                    var supportedBySubschemas = fields_1[fieldName];
                    if (supportedBySubschemas.length === 1) {
                        mergedTypes[typeName].uniqueFields[fieldName] =
                            supportedBySubschemas[0];
                    }
                    else {
                        mergedTypes[typeName].nonUniqueFields[fieldName] = supportedBySubschemas;
                    }
                });
                mergedTypes[typeName].selectionSet = {
                    kind: Kind$1.SELECTION_SET,
                    selections: requiredSelections_1,
                };
            }
        }
    });
    return mergedTypes;
}
function completeMergeInfo(mergeInfo, resolvers) {
    var replacementSelectionSets = Object.create(null);
    Object.keys(resolvers).forEach(function (typeName) {
        var type = resolvers[typeName];
        if (isScalarType$1(type)) {
            return;
        }
        Object.keys(type).forEach(function (fieldName) {
            var field = type[fieldName];
            if (field.selectionSet) {
                var selectionSet = parseSelectionSet(field.selectionSet);
                if (replacementSelectionSets[typeName] == null) {
                    replacementSelectionSets[typeName] = {};
                }
                if (replacementSelectionSets[typeName][fieldName] == null) {
                    replacementSelectionSets[typeName][fieldName] = {
                        kind: Kind$1.SELECTION_SET,
                        selections: [],
                    };
                }
                replacementSelectionSets[typeName][fieldName].selections = replacementSelectionSets[typeName][fieldName].selections.concat(selectionSet.selections);
            }
            if (field.fragment) {
                mergeInfo.fragments.push({
                    field: fieldName,
                    fragment: field.fragment,
                });
            }
        });
    });
    var mapping = {};
    mergeInfo.fragments.forEach(function (_a) {
        var field = _a.field, fragment = _a.fragment;
        var parsedFragment = parseFragmentToInlineFragment(fragment);
        var actualTypeName = parsedFragment.typeCondition.name.value;
        if (mapping[actualTypeName] == null) {
            mapping[actualTypeName] = {};
        }
        if (mapping[actualTypeName][field] == null) {
            mapping[actualTypeName][field] = [];
        }
        mapping[actualTypeName][field].push(parsedFragment);
    });
    var replacementFragments = Object.create(null);
    Object.keys(mapping).forEach(function (typeName) {
        Object.keys(mapping[typeName]).forEach(function (field) {
            if (replacementFragments[typeName] == null) {
                replacementFragments[typeName] = {};
            }
            replacementFragments[typeName][field] = concatInlineFragments(typeName, mapping[typeName][field]);
        });
    });
    mergeInfo.replacementSelectionSets = replacementSelectionSets;
    mergeInfo.replacementFragments = replacementFragments;
    return mergeInfo;
}
function operationToRootType(operation, schema) {
    if (operation === 'subscription') {
        return schema.getSubscriptionType();
    }
    else if (operation === 'mutation') {
        return schema.getMutationType();
    }
    return schema.getQueryType();
}
function guessSchemaByRootField(schemas, operation, fieldName) {
    for (var _i = 0, schemas_1 = schemas; _i < schemas_1.length; _i++) {
        var schema = schemas_1[_i];
        var rootObject = operationToRootType(operation, schema);
        if (rootObject != null) {
            var fields = rootObject.getFields();
            if (fields[fieldName] != null) {
                return schema;
            }
        }
    }
    throw new Error("Could not find subschema with field `" + operation + "." + fieldName + "`");
}

function mergeSchemas(_a) {
    var _b = _a.subschemas, subschemas = _b === void 0 ? [] : _b, _c = _a.types, types = _c === void 0 ? [] : _c, typeDefs = _a.typeDefs, _d = _a.schemas, schemaLikeObjects = _d === void 0 ? [] : _d, onTypeConflict = _a.onTypeConflict, _e = _a.resolvers, resolvers = _e === void 0 ? {} : _e, schemaDirectives = _a.schemaDirectives, inheritResolversFromInterfaces = _a.inheritResolversFromInterfaces, _f = _a.mergeTypes, mergeTypes = _f === void 0 ? false : _f, mergeDirectives = _a.mergeDirectives, _g = _a.queryTypeName, queryTypeName = _g === void 0 ? 'Query' : _g, _h = _a.mutationTypeName, mutationTypeName = _h === void 0 ? 'Mutation' : _h, _j = _a.subscriptionTypeName, subscriptionTypeName = _j === void 0 ? 'Subscription' : _j;
    var allSchemas = [];
    var typeCandidates = {};
    var typeMap = {};
    var extensions = [];
    var directives = [];
    var schemas = __spreadArrays(subschemas);
    if (typeDefs) {
        schemas.push(typeDefs);
    }
    if (types != null) {
        schemas.push(types);
    }
    schemas = __spreadArrays(schemas, schemaLikeObjects);
    schemas.forEach(function (schemaLikeObject) {
        var _a;
        if (isSchema(schemaLikeObject) || isSubschemaConfig(schemaLikeObject)) {
            var schema_1 = wrapSchema(schemaLikeObject);
            allSchemas.push(schema_1);
            var operationTypes_1 = (_a = {},
                _a[queryTypeName] = schema_1.getQueryType(),
                _a[mutationTypeName] = schema_1.getMutationType(),
                _a[subscriptionTypeName] = schema_1.getSubscriptionType(),
                _a);
            Object.keys(operationTypes_1).forEach(function (typeName) {
                if (operationTypes_1[typeName] != null) {
                    addTypeCandidate(typeCandidates, typeName, {
                        schema: schema_1,
                        type: operationTypes_1[typeName],
                        subschema: schemaLikeObject,
                        transformedSubschema: schema_1,
                    });
                }
            });
            if (mergeDirectives) {
                var directiveInstances = schema_1.getDirectives();
                directiveInstances.forEach(function (directive) {
                    directives.push(directive);
                });
            }
            var originalTypeMap_1 = schema_1.getTypeMap();
            Object.keys(originalTypeMap_1).forEach(function (typeName) {
                var type = originalTypeMap_1[typeName];
                if (isNamedType(type) &&
                    getNamedType(type).name.slice(0, 2) !== '__' &&
                    type !== operationTypes_1.Query &&
                    type !== operationTypes_1.Mutation &&
                    type !== operationTypes_1.Subscription) {
                    addTypeCandidate(typeCandidates, type.name, {
                        schema: schema_1,
                        type: type,
                        subschema: schemaLikeObject,
                        transformedSubschema: schema_1,
                    });
                }
            });
        }
        else if (typeof schemaLikeObject === 'string' ||
            (schemaLikeObject != null &&
                schemaLikeObject.kind === Kind$1.DOCUMENT)) {
            var parsedSchemaDocument = typeof schemaLikeObject === 'string'
                ? parse(schemaLikeObject)
                : schemaLikeObject;
            parsedSchemaDocument.definitions.forEach(function (def) {
                var type = typeFromAST$1(def);
                if (isDirective(type) && mergeDirectives) {
                    directives.push(type);
                }
                else if (type != null && !isDirective(type)) {
                    addTypeCandidate(typeCandidates, type.name, {
                        type: type,
                    });
                }
            });
            var extensionsDocument = extractExtensionDefinitions(parsedSchemaDocument);
            if (extensionsDocument.definitions.length > 0) {
                extensions.push(extensionsDocument);
            }
        }
        else if (Array.isArray(schemaLikeObject)) {
            schemaLikeObject.forEach(function (type) {
                addTypeCandidate(typeCandidates, type.name, {
                    type: type,
                });
            });
        }
        else {
            throw new Error('Invalid schema passed');
        }
    });
    var mergeInfo = createMergeInfo(allSchemas, typeCandidates, mergeTypes);
    var finalResolvers;
    if (typeof resolvers === 'function') {
        finalResolvers = resolvers(mergeInfo);
    }
    else if (Array.isArray(resolvers)) {
        finalResolvers = resolvers.reduce(function (left, right) {
            return mergeDeep(left, typeof right === 'function' ? right(mergeInfo) : right);
        }, {});
        if (Array.isArray(resolvers)) {
            finalResolvers = resolvers.reduce(mergeDeep, {});
        }
    }
    else {
        finalResolvers = resolvers;
    }
    if (finalResolvers == null) {
        finalResolvers = {};
    }
    mergeInfo = completeMergeInfo(mergeInfo, finalResolvers);
    Object.keys(typeCandidates).forEach(function (typeName) {
        if (typeName === queryTypeName ||
            typeName === mutationTypeName ||
            typeName === subscriptionTypeName ||
            (mergeTypes === true &&
                !isScalarType$1(typeCandidates[typeName][0].type)) ||
            (typeof mergeTypes === 'function' &&
                mergeTypes(typeName, typeCandidates[typeName])) ||
            (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||
            mergeInfo.mergedTypes[typeName] != null) {
            typeMap[typeName] = merge(typeName, typeCandidates[typeName]);
        }
        else {
            var candidateSelector = onTypeConflict != null
                ? onTypeConflictToCandidateSelector(onTypeConflict)
                : function (cands) { return cands[cands.length - 1]; };
            typeMap[typeName] = candidateSelector(typeCandidates[typeName]).type;
        }
    });
    healTypes(typeMap, directives, { skipPruning: true });
    var mergedSchema = new GraphQLSchema({
        query: typeMap[queryTypeName],
        mutation: typeMap[mutationTypeName],
        subscription: typeMap[subscriptionTypeName],
        types: Object.keys(typeMap).map(function (key) { return typeMap[key]; }),
        directives: directives.length
            ? directives.map(function (directive) { return cloneDirective(directive); })
            : undefined,
    });
    extensions.forEach(function (extension) {
        mergedSchema = extendSchema(mergedSchema, extension, {
            commentDescriptions: true,
        });
    });
    addResolversToSchema({
        schema: mergedSchema,
        resolvers: finalResolvers,
        inheritResolversFromInterfaces: inheritResolversFromInterfaces,
    });
    forEachField(mergedSchema, function (field) {
        if (field.resolve != null) {
            var fieldResolver_1 = field.resolve;
            field.resolve = function (parent, args, context, info) {
                var newInfo = __assign(__assign({}, info), { mergeInfo: mergeInfo });
                return fieldResolver_1(parent, args, context, newInfo);
            };
        }
        if (field.subscribe != null) {
            var fieldResolver_2 = field.subscribe;
            field.subscribe = function (parent, args, context, info) {
                var newInfo = __assign(__assign({}, info), { mergeInfo: mergeInfo });
                return fieldResolver_2(parent, args, context, newInfo);
            };
        }
    });
    if (schemaDirectives != null) {
        SchemaDirectiveVisitor.visitSchemaDirectives(mergedSchema, schemaDirectives);
    }
    return mergedSchema;
}
function addTypeCandidate(typeCandidates, name, typeCandidate) {
    if (!typeCandidates[name]) {
        typeCandidates[name] = [];
    }
    typeCandidates[name].push(typeCandidate);
}
function onTypeConflictToCandidateSelector(onTypeConflict) {
    return function (cands) {
        return cands.reduce(function (prev, next) {
            var type = onTypeConflict(prev.type, next.type, {
                left: {
                    schema: prev.schema,
                },
                right: {
                    schema: next.schema,
                },
            });
            if (prev.type === type) {
                return prev;
            }
            else if (next.type === type) {
                return next;
            }
            return {
                schemaName: 'unknown',
                type: type,
            };
        });
    };
}
function merge(typeName, candidates) {
    var initialCandidateType = candidates[0].type;
    if (candidates.some(function (candidate) {
        return candidate.type.constructor !== initialCandidateType.constructor;
    })) {
        throw new Error("Cannot merge different type categories into common type " + typeName + ".");
    }
    if (isObjectType$1(initialCandidateType)) {
        return new GraphQLObjectType$1({
            name: typeName,
            fields: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), toConfig(candidate.type).fields)); }, {}),
            interfaces: candidates.reduce(function (acc, candidate) {
                var interfaces = toConfig(candidate.type).interfaces;
                return interfaces != null ? acc.concat(interfaces) : acc;
            }, []),
        });
    }
    else if (isInterfaceType$1(initialCandidateType)) {
        var config = {
            name: typeName,
            fields: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), toConfig(candidate.type).fields)); }, {}),
            interfaces: graphqlVersion() >= 15
                ? candidates.reduce(function (acc, candidate) {
                    var interfaces = toConfig(candidate.type).interfaces;
                    return interfaces != null ? acc.concat(interfaces) : acc;
                }, [])
                : undefined,
        };
        return new GraphQLInterfaceType$1(config);
    }
    else if (isUnionType$1(initialCandidateType)) {
        return new GraphQLUnionType$1({
            name: typeName,
            types: candidates.reduce(function (acc, candidate) { return acc.concat(toConfig(candidate.type).types); }, []),
        });
    }
    else if (isEnumType$1(initialCandidateType)) {
        return new GraphQLEnumType$1({
            name: typeName,
            values: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), toConfig(candidate.type).values)); }, {}),
        });
    }
    else if (isScalarType$1(initialCandidateType)) {
        throw new Error("Cannot merge type " + typeName + ". Merging not supported for GraphQLScalarType.");
    }
    else {
        // not reachable.
        throw new Error("Type " + typeName + " has unknown GraphQL type.");
    }
}

function createMergedResolver(_a) {
    var fromPath = _a.fromPath, dehoist = _a.dehoist, _b = _a.delimeter, delimeter = _b === void 0 ? '__gqltf__' : _b;
    var parentErrorResolver = function (parent, args, context, info) {
        return parent instanceof Error
            ? parent
            : defaultMergedResolver(parent, args, context, info);
    };
    var unwrappingResolver = fromPath != null
        ? function (parent, args, context, info) {
            return parentErrorResolver(unwrapResult(parent, info, fromPath), args, context, info);
        }
        : parentErrorResolver;
    var dehoistingResolver = dehoist
        ? function (parent, args, context, info) {
            return unwrappingResolver(dehoistResult(parent, delimeter), args, context, info);
        }
        : unwrappingResolver;
    var noParentResolver = function (parent, args, context, info) { return (parent ? dehoistingResolver(parent, args, context, info) : {}); };
    return noParentResolver;
}

// This function is deprecated in favor of wrapSchema as the name is misleading.
// transformSchema does not just "transform" a schema, it wraps a schema with transforms
// using a round of delegation.
// The applySchemaTransforms function actually "transforms" the schema and is used during wrapping.
function transformSchema(subschemaOrSubschemaConfig, transforms) {
    var schema = wrapSchema(subschemaOrSubschemaConfig, transforms);
    schema.transforms = transforms.slice().reverse();
    return schema;
}

var RenameTypes = /** @class */ (function () {
    function RenameTypes(renamer, options) {
        this.renamer = renamer;
        this.map = {};
        this.reverseMap = {};
        var _a = options != null ? options : {}, _b = _a.renameBuiltins, renameBuiltins = _b === void 0 ? false : _b, _c = _a.renameScalars, renameScalars = _c === void 0 ? true : _c;
        this.renameBuiltins = renameBuiltins;
        this.renameScalars = renameScalars;
    }
    RenameTypes.prototype.transformSchema = function (originalSchema) {
        var _a;
        var _this = this;
        return mapSchema(originalSchema, (_a = {},
            _a[MapperKind.TYPE] = function (type) {
                if (isSpecifiedScalarType(type) && !_this.renameBuiltins) {
                    return undefined;
                }
                if (isScalarType$1(type) && !_this.renameScalars) {
                    return undefined;
                }
                var oldName = type.name;
                var newName = _this.renamer(oldName);
                if (newName && newName !== oldName) {
                    _this.map[oldName] = type.name;
                    _this.reverseMap[newName] = oldName;
                    var newConfig = __assign(__assign({}, toConfig(type)), { name: newName });
                    if (isObjectType$1(type)) {
                        return new GraphQLObjectType$1(newConfig);
                    }
                    else if (isInterfaceType$1(type)) {
                        return new GraphQLInterfaceType$1(newConfig);
                    }
                    else if (isUnionType$1(type)) {
                        return new GraphQLUnionType$1(newConfig);
                    }
                    else if (isInputObjectType$1(type)) {
                        return new GraphQLInputObjectType$1(newConfig);
                    }
                    else if (isEnumType$1(type)) {
                        return new GraphQLEnumType$1(newConfig);
                    }
                    else if (isScalarType$1(type)) {
                        return new GraphQLScalarType$1(newConfig);
                    }
                    throw new Error("Unknown type " + type + ".");
                }
            },
            _a[MapperKind.ROOT_OBJECT] = function () {
                return undefined;
            },
            _a));
    };
    RenameTypes.prototype.transformRequest = function (originalRequest) {
        var _a;
        var _this = this;
        var newDocument = visit$1(originalRequest.document, (_a = {},
            _a[Kind$1.NAMED_TYPE] = function (node) {
                var name = node.name.value;
                if (name in _this.reverseMap) {
                    return __assign(__assign({}, node), { name: {
                            kind: Kind$1.NAME,
                            value: _this.reverseMap[name],
                        } });
                }
            },
            _a));
        return {
            document: newDocument,
            variables: originalRequest.variables,
        };
    };
    RenameTypes.prototype.transformResult = function (result) {
        return __assign(__assign({}, result), { data: this.renameTypes(result.data) });
    };
    RenameTypes.prototype.renameTypes = function (value) {
        var _this = this;
        if (value == null) {
            return value;
        }
        else if (Array.isArray(value)) {
            value.forEach(function (v, index) {
                value[index] = _this.renameTypes(v);
            });
            return value;
        }
        else if (typeof value === 'object') {
            Object.keys(value).forEach(function (key) {
                value[key] =
                    key === '__typename'
                        ? _this.renamer(value[key])
                        : _this.renameTypes(value[key]);
            });
            return value;
        }
        return value;
    };
    return RenameTypes;
}());

var FilterTypes = /** @class */ (function () {
    function FilterTypes(filter) {
        this.filter = filter;
    }
    FilterTypes.prototype.transformSchema = function (schema) {
        var _a;
        var _this = this;
        return mapSchema(schema, (_a = {},
            _a[MapperKind.TYPE] = function (type) {
                if (_this.filter(type)) {
                    return undefined;
                }
                return null;
            },
            _a));
    };
    return FilterTypes;
}());

var RenameRootTypes = /** @class */ (function () {
    function RenameRootTypes(renamer) {
        this.renamer = renamer;
        this.map = {};
        this.reverseMap = {};
    }
    RenameRootTypes.prototype.transformSchema = function (originalSchema) {
        var _a;
        var _this = this;
        return mapSchema(originalSchema, (_a = {},
            _a[MapperKind.ROOT_OBJECT] = function (type) {
                var oldName = type.name;
                var newName = _this.renamer(oldName);
                if (newName && newName !== oldName) {
                    _this.map[oldName] = type.name;
                    _this.reverseMap[newName] = oldName;
                    return new GraphQLObjectType$1(__assign(__assign({}, toConfig(type)), { name: newName }));
                }
            },
            _a));
    };
    RenameRootTypes.prototype.transformRequest = function (originalRequest) {
        var _a;
        var _this = this;
        var newDocument = visit$1(originalRequest.document, (_a = {},
            _a[Kind$1.NAMED_TYPE] = function (node) {
                var name = node.name.value;
                if (name in _this.reverseMap) {
                    return __assign(__assign({}, node), { name: {
                            kind: Kind$1.NAME,
                            value: _this.reverseMap[name],
                        } });
                }
            },
            _a));
        return {
            document: newDocument,
            variables: originalRequest.variables,
        };
    };
    RenameRootTypes.prototype.transformResult = function (result) {
        return __assign(__assign({}, result), { data: this.renameTypes(result.data) });
    };
    RenameRootTypes.prototype.renameTypes = function (value) {
        var _this = this;
        if (value == null) {
            return value;
        }
        else if (Array.isArray(value)) {
            value.forEach(function (v, index) {
                value[index] = _this.renameTypes(v);
            });
            return value;
        }
        else if (typeof value === 'object') {
            Object.keys(value).forEach(function (key) {
                value[key] =
                    key === '__typename'
                        ? _this.renamer(value[key])
                        : _this.renameTypes(value[key]);
            });
            return value;
        }
        return value;
    };
    return RenameRootTypes;
}());

function isEmptyObject(obj) {
    if (obj == null) {
        return true;
    }
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) {
            return false;
        }
    }
    return true;
}

var TransformCompositeFields = /** @class */ (function () {
    function TransformCompositeFields(fieldTransformer, fieldNodeTransformer) {
        this.fieldTransformer = fieldTransformer;
        this.fieldNodeTransformer = fieldNodeTransformer;
        this.mapping = {};
    }
    TransformCompositeFields.prototype.transformSchema = function (originalSchema) {
        var _a;
        var _this = this;
        this.transformedSchema = mapSchema(originalSchema, (_a = {},
            _a[MapperKind.OBJECT_TYPE] = function (type) {
                return _this.transformFields(type, _this.fieldTransformer);
            },
            _a[MapperKind.INTERFACE_TYPE] = function (type) {
                return _this.transformFields(type, _this.fieldTransformer);
            },
            _a));
        return this.transformedSchema;
    };
    TransformCompositeFields.prototype.transformRequest = function (originalRequest) {
        var fragments = {};
        originalRequest.document.definitions
            .filter(function (def) { return def.kind === Kind$1.FRAGMENT_DEFINITION; })
            .forEach(function (def) {
            fragments[def.name.value] = def;
        });
        var document = this.transformDocument(originalRequest.document, this.mapping, this.fieldNodeTransformer, fragments);
        return __assign(__assign({}, originalRequest), { document: document });
    };
    TransformCompositeFields.prototype.transformFields = function (type, fieldTransformer) {
        var _this = this;
        var typeConfig = toConfig(type);
        var fields = type.getFields();
        var newFields = {};
        Object.keys(fields).forEach(function (fieldName) {
            var field = fields[fieldName];
            var transformedField = fieldTransformer(type.name, fieldName, field);
            if (typeof transformedField === 'undefined') {
                newFields[fieldName] = typeConfig.fields[fieldName];
            }
            else if (transformedField !== null) {
                var newName = transformedField.name;
                if (newName) {
                    newFields[newName] =
                        transformedField.field != null
                            ? transformedField.field
                            : typeConfig.fields[fieldName];
                    if (newName !== fieldName) {
                        var typeName = type.name;
                        if (!_this.mapping[typeName]) {
                            _this.mapping[typeName] = {};
                        }
                        _this.mapping[typeName][newName] = fieldName;
                    }
                }
                else {
                    newFields[fieldName] = transformedField;
                }
            }
        });
        if (isEmptyObject(newFields)) {
            return null;
        }
        if (isObjectType$1(type)) {
            return new GraphQLObjectType$1(__assign(__assign({}, toConfig(type)), { fields: newFields }));
        }
        else if (isInterfaceType$1(type)) {
            return new GraphQLInterfaceType$1(__assign(__assign({}, toConfig(type)), { fields: newFields }));
        }
    };
    TransformCompositeFields.prototype.transformDocument = function (document, mapping, fieldNodeTransformer, fragments) {
        var _a;
        if (fragments === void 0) { fragments = {}; }
        var typeInfo = new TypeInfo(this.transformedSchema);
        var newDocument = visit$1(document, visitWithTypeInfo(typeInfo, {
            leave: (_a = {},
                _a[Kind$1.SELECTION_SET] = function (node) {
                    var parentType = typeInfo.getParentType();
                    if (parentType != null) {
                        var parentTypeName_1 = parentType.name;
                        var newSelections_1 = [];
                        node.selections.forEach(function (selection) {
                            if (selection.kind !== Kind$1.FIELD) {
                                newSelections_1.push(selection);
                                return;
                            }
                            var newName = selection.name.value;
                            var transformedSelection = fieldNodeTransformer != null
                                ? fieldNodeTransformer(parentTypeName_1, newName, selection, fragments)
                                : selection;
                            if (Array.isArray(transformedSelection)) {
                                newSelections_1 = newSelections_1.concat(transformedSelection);
                                return;
                            }
                            if (transformedSelection.kind !== Kind$1.FIELD) {
                                newSelections_1.push(transformedSelection);
                                return;
                            }
                            var typeMapping = mapping[parentTypeName_1];
                            if (typeMapping == null) {
                                newSelections_1.push(transformedSelection);
                                return;
                            }
                            var oldName = mapping[parentTypeName_1][newName];
                            if (oldName == null) {
                                newSelections_1.push(transformedSelection);
                                return;
                            }
                            newSelections_1.push(__assign(__assign({}, transformedSelection), { name: {
                                    kind: Kind$1.NAME,
                                    value: oldName,
                                }, alias: {
                                    kind: Kind$1.NAME,
                                    value: newName,
                                } }));
                        });
                        return __assign(__assign({}, node), { selections: newSelections_1 });
                    }
                },
                _a),
        }));
        return newDocument;
    };
    return TransformCompositeFields;
}());

var TransformObjectFields = /** @class */ (function () {
    function TransformObjectFields(objectFieldTransformer, fieldNodeTransformer) {
        this.objectFieldTransformer = objectFieldTransformer;
        this.fieldNodeTransformer = fieldNodeTransformer;
    }
    TransformObjectFields.prototype.transformSchema = function (originalSchema) {
        var _this = this;
        var compositeToObjectFieldTransformer = function (typeName, fieldName, field) {
            if (isObjectType$1(originalSchema.getType(typeName))) {
                return _this.objectFieldTransformer(typeName, fieldName, field);
            }
            return undefined;
        };
        this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);
        return this.transformer.transformSchema(originalSchema);
    };
    TransformObjectFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return TransformObjectFields;
}());

var TransformRootFields = /** @class */ (function () {
    function TransformRootFields(rootFieldTransformer, fieldNodeTransformer) {
        var rootToObjectFieldTransformer = function (typeName, fieldName, field) {
            if (typeName === 'Query' ||
                typeName === 'Mutation' ||
                typeName === 'Subscription') {
                return rootFieldTransformer(typeName, fieldName, field);
            }
            return undefined;
        };
        this.transformer = new TransformObjectFields(rootToObjectFieldTransformer, fieldNodeTransformer);
    }
    TransformRootFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    TransformRootFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return TransformRootFields;
}());

var RenameRootFields = /** @class */ (function () {
    function RenameRootFields(renamer) {
        this.transformer = new TransformRootFields(function (operation, fieldName, field) { return ({
            name: renamer(operation, fieldName, field),
        }); });
    }
    RenameRootFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    RenameRootFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return RenameRootFields;
}());

var FilterRootFields = /** @class */ (function () {
    function FilterRootFields(filter) {
        this.transformer = new TransformRootFields(function (operation, fieldName, field) {
            if (filter(operation, fieldName, field)) {
                return undefined;
            }
            return null;
        });
    }
    FilterRootFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    return FilterRootFields;
}());

var RenameObjectFields = /** @class */ (function () {
    function RenameObjectFields(renamer) {
        this.transformer = new TransformObjectFields(function (typeName, fieldName, field) { return ({
            name: renamer(typeName, fieldName, field),
        }); });
    }
    RenameObjectFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    RenameObjectFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return RenameObjectFields;
}());

var FilterObjectFields = /** @class */ (function () {
    function FilterObjectFields(filter) {
        this.transformer = new TransformObjectFields(function (typeName, fieldName, field) {
            return filter(typeName, fieldName, field) ? undefined : null;
        });
    }
    FilterObjectFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    return FilterObjectFields;
}());

var TransformInterfaceFields = /** @class */ (function () {
    function TransformInterfaceFields(interfaceFieldTransformer, fieldNodeTransformer) {
        this.interfaceFieldTransformer = interfaceFieldTransformer;
        this.fieldNodeTransformer = fieldNodeTransformer;
    }
    TransformInterfaceFields.prototype.transformSchema = function (originalSchema) {
        var _this = this;
        var compositeToObjectFieldTransformer = function (typeName, fieldName, field) {
            if (isInterfaceType$1(originalSchema.getType(typeName))) {
                return _this.interfaceFieldTransformer(typeName, fieldName, field);
            }
            return undefined;
        };
        this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);
        return this.transformer.transformSchema(originalSchema);
    };
    TransformInterfaceFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return TransformInterfaceFields;
}());

var RenameInterfaceFields = /** @class */ (function () {
    function RenameInterfaceFields(renamer) {
        this.transformer = new TransformInterfaceFields(function (typeName, fieldName, field) { return ({
            name: renamer(typeName, fieldName, field),
        }); });
    }
    RenameInterfaceFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    RenameInterfaceFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return RenameInterfaceFields;
}());

var FilterInterfaceFields = /** @class */ (function () {
    function FilterInterfaceFields(filter) {
        this.transformer = new TransformInterfaceFields(function (typeName, fieldName, field) {
            return filter(typeName, fieldName, field) ? undefined : null;
        });
    }
    FilterInterfaceFields.prototype.transformSchema = function (originalSchema) {
        return this.transformer.transformSchema(originalSchema);
    };
    return FilterInterfaceFields;
}());

var TransformQuery = /** @class */ (function () {
    function TransformQuery(_a) {
        var path = _a.path, queryTransformer = _a.queryTransformer, _b = _a.resultTransformer, resultTransformer = _b === void 0 ? function (result) { return result; } : _b, _c = _a.errorPathTransformer, errorPathTransformer = _c === void 0 ? function (errorPath) { return [].concat(errorPath); } : _c, _d = _a.fragments, fragments = _d === void 0 ? {} : _d;
        this.path = path;
        this.queryTransformer = queryTransformer;
        this.resultTransformer = resultTransformer;
        this.errorPathTransformer = errorPathTransformer;
        this.fragments = fragments;
    }
    TransformQuery.prototype.transformRequest = function (originalRequest) {
        var _a;
        var _this = this;
        var document = originalRequest.document;
        var pathLength = this.path.length;
        var index = 0;
        var newDocument = visit$1(document, (_a = {},
            _a[Kind$1.FIELD] = {
                enter: function (node) {
                    if (index === pathLength || node.name.value !== _this.path[index]) {
                        return false;
                    }
                    index++;
                    if (index === pathLength) {
                        var selectionSet = _this.queryTransformer(node.selectionSet, _this.fragments);
                        return __assign(__assign({}, node), { selectionSet: selectionSet });
                    }
                },
                leave: function () {
                    index--;
                },
            },
            _a));
        return __assign(__assign({}, originalRequest), { document: newDocument });
    };
    TransformQuery.prototype.transformResult = function (originalResult) {
        var data = this.transformData(originalResult.data);
        var errors = originalResult.errors;
        return {
            data: data,
            errors: errors != null ? this.transformErrors(errors) : undefined,
        };
    };
    TransformQuery.prototype.transformData = function (data) {
        var leafIndex = this.path.length - 1;
        var index = 0;
        var newData = data;
        if (newData) {
            var next = this.path[index];
            while (index < leafIndex) {
                if (data[next]) {
                    newData = newData[next];
                }
                else {
                    break;
                }
                index++;
                next = this.path[index];
            }
            newData[next] = this.resultTransformer(newData[next]);
        }
        return newData;
    };
    TransformQuery.prototype.transformErrors = function (errors) {
        var _this = this;
        return errors.map(function (error) {
            var path = error.path;
            var match = true;
            var index = 0;
            while (index < _this.path.length) {
                if (path[index] !== _this.path[index]) {
                    match = false;
                    break;
                }
                index++;
            }
            var newPath = match
                ? path
                    .slice(0, index)
                    .concat(_this.errorPathTransformer(path.slice(index)))
                : path;
            return new GraphQLError$1(error.message, error.nodes, error.source, error.positions, newPath, error.originalError, error.extensions);
        });
    };
    return TransformQuery;
}());

var MapFields = /** @class */ (function () {
    function MapFields(fieldNodeTransformerMap) {
        this.transformer = new TransformObjectFields(function (_typeName, _fieldName, field) { return toConfig(field); }, function (typeName, fieldName, fieldNode, fragments) {
            var typeTransformers = fieldNodeTransformerMap[typeName];
            if (typeTransformers == null) {
                return fieldNode;
            }
            var fieldNodeTransformer = typeTransformers[fieldName];
            if (fieldNodeTransformer == null) {
                return fieldNode;
            }
            return fieldNodeTransformer(fieldNode, fragments);
        });
    }
    MapFields.prototype.transformSchema = function (schema) {
        return this.transformer.transformSchema(schema);
    };
    MapFields.prototype.transformRequest = function (request) {
        return this.transformer.transformRequest(request);
    };
    return MapFields;
}());

var ExtendSchema = /** @class */ (function () {
    function ExtendSchema(_a) {
        var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, defaultFieldResolver = _a.defaultFieldResolver, fieldNodeTransformerMap = _a.fieldNodeTransformerMap;
        this.typeDefs = typeDefs;
        this.resolvers = resolvers;
        this.defaultFieldResolver =
            defaultFieldResolver != null
                ? defaultFieldResolver
                : defaultMergedResolver;
        this.transformer = new MapFields(fieldNodeTransformerMap != null ? fieldNodeTransformerMap : {});
    }
    ExtendSchema.prototype.transformSchema = function (schema) {
        this.transformer.transformSchema(schema);
        return addResolversToSchema({
            schema: this.typeDefs
                ? extendSchema$1(schema, parse(this.typeDefs))
                : schema,
            resolvers: this.resolvers != null ? this.resolvers : {},
            defaultFieldResolver: this.defaultFieldResolver,
        });
    };
    ExtendSchema.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return ExtendSchema;
}());

var WrapFields = /** @class */ (function () {
    function WrapFields(outerTypeName, wrappingFieldNames, wrappingTypeNames, fieldNames) {
        var _a, _b;
        var _this = this;
        this.outerTypeName = outerTypeName;
        this.wrappingFieldNames = wrappingFieldNames;
        this.wrappingTypeNames = wrappingTypeNames;
        this.numWraps = wrappingFieldNames.length;
        this.fieldNames = fieldNames;
        var remainingWrappingFieldNames = this.wrappingFieldNames.slice();
        var outerMostWrappingFieldName = remainingWrappingFieldNames.shift();
        this.transformer = new MapFields((_a = {},
            _a[outerTypeName] = (_b = {},
                _b[outerMostWrappingFieldName] = function (fieldNode, fragments) {
                    return hoistFieldNodes({
                        fieldNode: fieldNode,
                        path: remainingWrappingFieldNames,
                        fieldNames: _this.fieldNames,
                        fragments: fragments,
                    });
                },
                _b),
            _a));
    }
    WrapFields.prototype.transformSchema = function (schema) {
        var _a, _b;
        var _this = this;
        var typeMap = schema.getTypeMap();
        var targetFields = removeFields(typeMap, this.outerTypeName, !this.fieldNames
            ? function () { return true; }
            : function (fieldName) { return _this.fieldNames.includes(fieldName); });
        var wrapIndex = this.numWraps - 1;
        var innerMostWrappingTypeName = this.wrappingTypeNames[wrapIndex];
        appendFields(typeMap, innerMostWrappingTypeName, targetFields);
        for (wrapIndex--; wrapIndex > -1; wrapIndex--) {
            appendFields(typeMap, this.wrappingTypeNames[wrapIndex], (_a = {},
                _a[this.wrappingFieldNames[wrapIndex + 1]] = {
                    type: typeMap[this.wrappingTypeNames[wrapIndex + 1]],
                    resolve: defaultMergedResolver,
                },
                _a));
        }
        appendFields(typeMap, this.outerTypeName, (_b = {},
            _b[this.wrappingFieldNames[0]] = {
                type: typeMap[this.wrappingTypeNames[0]],
                resolve: createMergedResolver({ dehoist: true }),
            },
            _b));
        healSchema(schema);
        return this.transformer.transformSchema(schema);
    };
    WrapFields.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return WrapFields;
}());

var WrapType = /** @class */ (function () {
    function WrapType(outerTypeName, innerTypeName, fieldName) {
        this.transformer = new WrapFields(outerTypeName, [fieldName], [innerTypeName], undefined);
    }
    WrapType.prototype.transformSchema = function (schema) {
        return this.transformer.transformSchema(schema);
    };
    WrapType.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return WrapType;
}());

var HoistField = /** @class */ (function () {
    function HoistField(typeName, path, newFieldName) {
        var _a, _b;
        var _this = this;
        this.typeName = typeName;
        this.path = path;
        this.newFieldName = newFieldName;
        this.pathToField = this.path.slice();
        this.oldFieldName = this.pathToField.pop();
        this.transformer = new MapFields((_a = {},
            _a[typeName] = (_b = {},
                _b[newFieldName] = function (fieldNode) {
                    return wrapFieldNode(renameFieldNode(fieldNode, _this.oldFieldName), _this.pathToField);
                },
                _b),
            _a));
    }
    HoistField.prototype.transformSchema = function (schema) {
        var _a;
        var _this = this;
        var typeMap = schema.getTypeMap();
        var innerType = this.pathToField.reduce(function (acc, pathSegment) {
            return getNullableType(acc.getFields()[pathSegment].type);
        }, typeMap[this.typeName]);
        var targetField = removeFields(typeMap, innerType.name, function (fieldName) { return fieldName === _this.oldFieldName; })[this.oldFieldName];
        var targetType = targetField.type;
        appendFields(typeMap, this.typeName, (_a = {},
            _a[this.newFieldName] = {
                type: targetType,
                resolve: createMergedResolver({ fromPath: this.pathToField }),
            },
            _a));
        healSchema(schema);
        return this.transformer.transformSchema(schema);
    };
    HoistField.prototype.transformRequest = function (originalRequest) {
        return this.transformer.transformRequest(originalRequest);
    };
    return HoistField;
}());

var ReplaceFieldWithFragment = /** @class */ (function () {
    function ReplaceFieldWithFragment(targetSchema, fragments) {
        this.targetSchema = targetSchema;
        this.mapping = {};
        for (var _i = 0, fragments_1 = fragments; _i < fragments_1.length; _i++) {
            var _a = fragments_1[_i], field = _a.field, fragment = _a.fragment;
            var parsedFragment = parseFragmentToInlineFragment$1(fragment);
            var actualTypeName = parsedFragment.typeCondition.name.value;
            if (this.mapping[actualTypeName] == null) {
                this.mapping[actualTypeName] = {};
            }
            if (this.mapping[actualTypeName][field] == null) {
                this.mapping[actualTypeName][field] = [parsedFragment];
            }
            else {
                this.mapping[actualTypeName][field].push(parsedFragment);
            }
        }
    }
    ReplaceFieldWithFragment.prototype.transformRequest = function (originalRequest) {
        var document = replaceFieldsWithFragments$1(this.targetSchema, originalRequest.document, this.mapping);
        return __assign(__assign({}, originalRequest), { document: document });
    };
    return ReplaceFieldWithFragment;
}());
function replaceFieldsWithFragments$1(targetSchema, document, mapping) {
    var _a;
    var typeInfo = new TypeInfo(targetSchema);
    return visit$1(document, visitWithTypeInfo(typeInfo, (_a = {},
        _a[Kind$1.SELECTION_SET] = function (node) {
            var parentType = typeInfo.getParentType();
            if (parentType != null) {
                var parentTypeName_1 = parentType.name;
                var selections_1 = node.selections;
                if (mapping[parentTypeName_1] != null) {
                    node.selections.forEach(function (selection) {
                        if (selection.kind === Kind$1.FIELD) {
                            var name_1 = selection.name.value;
                            var fragments = mapping[parentTypeName_1][name_1];
                            if (fragments != null && fragments.length > 0) {
                                var fragment = concatInlineFragments(parentTypeName_1, fragments);
                                selections_1 = selections_1.concat(fragment);
                            }
                        }
                    });
                }
                if (selections_1 !== node.selections) {
                    return __assign(__assign({}, node), { selections: selections_1 });
                }
            }
        },
        _a)));
}
function parseFragmentToInlineFragment$1(definitions) {
    if (definitions.trim().startsWith('fragment')) {
        var document_1 = parse(definitions);
        for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {
            var definition = _a[_i];
            if (definition.kind === Kind$1.FRAGMENT_DEFINITION) {
                return {
                    kind: Kind$1.INLINE_FRAGMENT,
                    typeCondition: definition.typeCondition,
                    selectionSet: definition.selectionSet,
                };
            }
        }
    }
    var query = parse("{" + definitions + "}")
        .definitions[0];
    for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {
        var selection = _c[_b];
        if (selection.kind === Kind$1.INLINE_FRAGMENT) {
            return selection;
        }
    }
    throw new Error('Could not parse fragment');
}

var WrapQuery = /** @class */ (function () {
    function WrapQuery(path, wrapper, extractor) {
        this.path = path;
        this.wrapper = wrapper;
        this.extractor = extractor;
    }
    WrapQuery.prototype.transformRequest = function (originalRequest) {
        var _a;
        var _this = this;
        var document = originalRequest.document;
        var fieldPath = [];
        var ourPath = JSON.stringify(this.path);
        var newDocument = visit$1(document, (_a = {},
            _a[Kind$1.FIELD] = {
                enter: function (node) {
                    fieldPath.push(node.name.value);
                    if (ourPath === JSON.stringify(fieldPath)) {
                        var wrapResult = _this.wrapper(node.selectionSet);
                        // Selection can be either a single selection or a selection set. If it's just one selection,
                        // let's wrap it in a selection set. Otherwise, keep it as is.
                        var selectionSet = wrapResult != null && wrapResult.kind === Kind$1.SELECTION_SET
                            ? wrapResult
                            : {
                                kind: Kind$1.SELECTION_SET,
                                selections: [wrapResult],
                            };
                        return __assign(__assign({}, node), { selectionSet: selectionSet });
                    }
                },
                leave: function () {
                    fieldPath.pop();
                },
            },
            _a));
        return __assign(__assign({}, originalRequest), { document: newDocument });
    };
    WrapQuery.prototype.transformResult = function (originalResult) {
        var rootData = originalResult.data;
        if (rootData != null) {
            var data = rootData;
            var path = __spreadArrays(this.path);
            while (path.length > 1) {
                var next = path.shift();
                if (data[next]) {
                    data = data[next];
                }
            }
            data[path[0]] = this.extractor(data[path[0]]);
        }
        return {
            data: rootData,
            errors: originalResult.errors,
        };
    };
    return WrapQuery;
}());

var ExtractField = /** @class */ (function () {
    function ExtractField(_a) {
        var from = _a.from, to = _a.to;
        this.from = from;
        this.to = to;
    }
    ExtractField.prototype.transformRequest = function (originalRequest) {
        var _a, _b;
        var fromSelection;
        var ourPathFrom = JSON.stringify(this.from);
        var ourPathTo = JSON.stringify(this.to);
        var fieldPath = [];
        visit$1(originalRequest.document, (_a = {},
            _a[Kind$1.FIELD] = {
                enter: function (node) {
                    fieldPath.push(node.name.value);
                    if (ourPathFrom === JSON.stringify(fieldPath)) {
                        fromSelection = node.selectionSet;
                        return BREAK$1;
                    }
                },
                leave: function () {
                    fieldPath.pop();
                },
            },
            _a));
        fieldPath = [];
        var newDocument = visit$1(originalRequest.document, (_b = {},
            _b[Kind$1.FIELD] = {
                enter: function (node) {
                    fieldPath.push(node.name.value);
                    if (ourPathTo === JSON.stringify(fieldPath) &&
                        fromSelection != null) {
                        return __assign(__assign({}, node), { selectionSet: fromSelection });
                    }
                },
                leave: function () {
                    fieldPath.pop();
                },
            },
            _b));
        return __assign(__assign({}, originalRequest), { document: newDocument });
    };
    return ExtractField;
}());

function makeRemoteExecutableSchema(_a) {
    var schemaOrTypeDefs = _a.schema, link = _a.link, fetcher = _a.fetcher, _b = _a.createResolver, customCreateResolver = _b === void 0 ? createResolver : _b, buildSchemaOptions = _a.buildSchemaOptions;
    var finalFetcher = fetcher;
    if (finalFetcher == null && link != null) {
        finalFetcher = linkToFetcher(link);
    }
    var targetSchema = typeof schemaOrTypeDefs === 'string'
        ? buildSchema(schemaOrTypeDefs, buildSchemaOptions)
        : schemaOrTypeDefs;
    var remoteSchema = cloneSchema(targetSchema);
    stripResolvers(remoteSchema);
    function createProxyingResolver(_a) {
        var operation = _a.operation;
        if (operation === 'query' || operation === 'mutation') {
            return customCreateResolver(finalFetcher);
        }
        return createSubscriptionResolver(link);
    }
    addResolversToSchema({
        schema: remoteSchema,
        resolvers: generateProxyingResolvers({
            subschemaConfig: { schema: remoteSchema },
            createProxyingResolver: createProxyingResolver,
        }),
        resolverValidationOptions: {
            allowResolversNotInSchema: true,
        },
    });
    return remoteSchema;
}
function createResolver(fetcher) {
    var _this = this;
    return function (_root, _args, context, info) { return __awaiter(_this, void 0, void 0, function () {
        var fragments, query, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    fragments = Object.keys(info.fragments).map(function (fragment) { return info.fragments[fragment]; });
                    query = {
                        kind: Kind$1.DOCUMENT,
                        definitions: __spreadArrays([info.operation], fragments),
                    };
                    query = addTypenameToAbstract(info.schema, query);
                    return [4 /*yield*/, fetcher({
                            query: query,
                            variables: info.variableValues,
                            context: { graphqlContext: context },
                        })];
                case 1:
                    result = _a.sent();
                    return [2 /*return*/, checkResultAndHandleErrors(result, context, info)];
            }
        });
    }); };
}
function createSubscriptionResolver(link) {
    return function (_root, _args, context, info) {
        var fragments = Object.keys(info.fragments).map(function (fragment) { return info.fragments[fragment]; });
        var query = {
            kind: Kind$1.DOCUMENT,
            definitions: __spreadArrays([info.operation], fragments),
        };
        query = addTypenameToAbstract(info.schema, query);
        var operation = {
            query: query,
            variables: info.variableValues,
            context: { graphqlContext: context },
        };
        var observable = execute(link, operation);
        var originalAsyncIterator = observableToAsyncIterable(observable);
        return mapAsyncIterator(originalAsyncIterator, function (result) {
            var _a;
            return (_a = {},
                _a[info.fieldName] = checkResultAndHandleErrors(result, context, info),
                _a);
        });
    };
}

export { AddArgumentsAsVariables, AddMergedTypeFragments as AddMergedTypeSelectionSets, AddReplacementFragments, AddReplacementSelectionSets, AddTypenameToAbstract, CheckResultAndHandleErrors, ExpandAbstractTypes, ExtendSchema, ExtractField, FilterInterfaceFields, FilterObjectFields, FilterRootFields, FilterToSchema, FilterTypes, GraphQLUpload, HoistField, MapFields, MapperKind, MockList, RenameInterfaceFields, RenameObjectFields, RenameRootFields, RenameRootTypes, RenameTypes, ReplaceFieldWithFragment, SchemaDirectiveVisitor, SchemaError, SchemaVisitor, TransformCompositeFields, TransformInterfaceFields, TransformObjectFields, TransformQuery, TransformRootFields, VisitSchemaKind, WrapFields, WrapQuery, WrapType, addCatchUndefinedToSchema, addErrorLoggingToSchema, addMockFunctionsToSchema, addMocksToSchema, addResolveFunctionsToSchema, addResolversToSchema, addSchemaLevelResolveFunction, addSchemaLevelResolver, appendFields, applyRequestTransforms, applyResultTransforms, applySchemaTransforms, argumentMapToConfig, argumentToConfig, assertResolveFunctionsPresent, assertResolversPresent, attachConnectorsToContext, attachDirectiveResolvers, buildSchema, buildSchemaFromTypeDefinitions, chainResolvers, checkForResolveTypeResolver, cloneDirective, cloneSchema, cloneType, collectFields$1 as collectFields, concatInlineFragments, concatenateTypeDefs, createMergedResolver, createNamedStub, createRequest, createRequestFromInfo, createServerHttpLink, decorateWithLogger, createResolver as defaultCreateRemoteResolver, defaultMergedResolver, dehoistResult, delegateRequest, delegateToSchema, directiveToConfig, enumTypeToConfig, extendResolversFromInterfaces, extendSchema, extractExtensionDefinitions, fieldMapToConfig, fieldToConfig, filterExtensionDefinitions, filterSchema, forEachDefaultValue, forEachField, getResolversFromSchema, graphqlVersion, healSchema, healTypes, hoistFieldNodes, inputFieldMapToConfig, inputFieldToConfig, inputObjectTypeToConfig, interfaceTypeToConfig, introspectSchema, isSpecifiedScalarType, isSubschemaConfig, makeExecutableSchema, makeRemoteExecutableSchema, mapSchema, mergeDeep, mergeSchemas, mockServer, objectTypeToConfig, parseFragmentToInlineFragment, parseInputValue, parseInputValueLiteral, parseSelectionSet, removeFields, renameFieldNode, scalarTypeToConfig, schemaToConfig, serializeInputValue, toConfig, transformInputValue, transformSchema, typeContainsSelectionSet, typeToConfig, unionTypeToConfig, unwrapResult, visitSchema, wrapFieldNode, wrapSchema };
//# sourceMappingURL=index.mjs.map
